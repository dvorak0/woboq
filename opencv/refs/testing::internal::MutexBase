<def f='opencv/modules/ts/include/opencv2/ts/ts_gtest.h' l='2494' ll='2535'/>
<ovr f='opencv/modules/ts/include/opencv2/ts/ts_gtest.h' l='2552' c='testing::internal::Mutex'/>
<size>56</size>
<doc f='opencv/modules/ts/include/opencv2/ts/ts_gtest.h' l='2475'>// MutexBase and Mutex implement mutex on pthreads-based platforms. They
// are used in conjunction with class MutexLock:
//
//   Mutex mutex;
//   ...
//   MutexLock lock(&amp;mutex);  // Acquires the mutex and releases it at the end
//                            // of the current scope.
//
// MutexBase implements behavior for both statically and dynamically
// allocated mutexes.  Do not use MutexBase directly.  Instead, write
// the following to define a static mutex:
//
//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);
//
// You can forward declare a static mutex like this:
//
//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);
//
// To create a dynamic mutex, just define an object of type Mutex.</doc>
<fun r='_ZN7testing8internal9MutexBase4LockEv'/>
<fun r='_ZN7testing8internal9MutexBase6UnlockEv'/>
<fun r='_ZNK7testing8internal9MutexBase10AssertHeldEv'/>
<mbr r='testing::internal::MutexBase::mutex_' o='0' t='pthread_mutex_t'/>
<mbr r='testing::internal::MutexBase::has_owner_' o='320' t='bool'/>
<mbr r='testing::internal::MutexBase::owner_' o='384' t='pthread_t'/>
