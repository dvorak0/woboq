<def f='opencv/modules/flann/include/opencv2/flann/autotuned_index.h' l='329' ll='374' type='void cvflann::AutotunedIndex::optimizeKMeans(std::vector&lt;CostData&gt; &amp; costs)'/>
<use f='opencv/modules/flann/include/opencv2/flann/autotuned_index.h' l='459' u='c' c='_ZN7cvflann14AutotunedIndex19estimateBuildParamsEv'/>
<doc f='opencv/modules/flann/include/opencv2/flann/autotuned_index.h' l='281'>//    struct KMeansSimpleDownhillFunctor {
    //
    //        Autotune&amp; autotuner;
    //        KMeansSimpleDownhillFunctor(Autotune&amp; autotuner_) : autotuner(autotuner_) {};
    //
    //        float operator()(int* params) {
    //
    //            float maxFloat = numeric_limits&lt;float&gt;::max();
    //
    //            if (params[0]&lt;2) return maxFloat;
    //            if (params[1]&lt;0) return maxFloat;
    //
    //            CostData c;
    //            c.params[&quot;algorithm&quot;] = KMEANS;
    //            c.params[&quot;centers-init&quot;] = CENTERS_RANDOM;
    //            c.params[&quot;branching&quot;] = params[0];
    //            c.params[&quot;max-iterations&quot;] = params[1];
    //
    //            autotuner.evaluate_kmeans(c);
    //
    //            return c.timeCost;
    //
    //        }
    //    };
    //
    //    struct KDTreeSimpleDownhillFunctor {
    //
    //        Autotune&amp; autotuner;
    //        KDTreeSimpleDownhillFunctor(Autotune&amp; autotuner_) : autotuner(autotuner_) {};
    //
    //        float operator()(int* params) {
    //            float maxFloat = numeric_limits&lt;float&gt;::max();
    //
    //            if (params[0]&lt;1) return maxFloat;
    //
    //            CostData c;
    //            c.params[&quot;algorithm&quot;] = KDTREE;
    //            c.params[&quot;trees&quot;] = params[0];
    //
    //            autotuner.evaluate_kdtree(c);
    //
    //            return c.timeCost;
    //
    //        }
    //    };</doc>
