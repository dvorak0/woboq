<dec f='include/python2.7/unicodeobject.h' l='271' type='PyObject * PyUnicodeUCS4_EncodeUTF16(const Py_UNICODE * data, Py_ssize_t length, const char * errors, int byteorder)'/>
<doc f='include/python2.7/unicodeobject.h' l='898'>/* Returns a Python string object holding the UTF-16 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
   UCS-2. This trick makes it possible to add full UTF-16 capabilities
   at a later point without compromising the APIs.

*/</doc>
