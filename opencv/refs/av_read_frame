<dec f='include/libavformat/avformat.h' l='1332' type='int av_read_frame(AVFormatContext * s, AVPacket * pkt)'/>
<use f='opencv/modules/highgui/src/cap_ffmpeg_impl.hpp' l='891' u='c' c='_ZN16CvCapture_FFMPEG9grabFrameEv'/>
<use f='opencv/modules/highgui/src/cap_ffmpeg_impl.hpp' l='2554' u='c' c='_ZN23InputMediaStream_FFMPEG4readEPPhPiS2_'/>
<doc f='include/libavformat/avformat.h' l='1308'>/**
 * Return the next frame of a stream.
 * This function returns what is stored in the file, and does not validate
 * that what is there are valid frames for the decoder. It will split what is
 * stored in the file into frames and return one for each call. It will not
 * omit invalid data between valid frames so as to give the decoder the maximum
 * information possible for decoding.
 *
 * If pkt-&gt;destruct is NULL, then the packet is valid until the next
 * av_read_frame() or until av_close_input_file(). Otherwise the packet is valid
 * indefinitely. In both cases the packet must be freed with
 * av_free_packet when it is no longer needed. For video, the packet contains
 * exactly one frame. For audio, it contains an integer number of frames if each
 * frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames
 * have a variable size (e.g. MPEG audio), then it contains one frame.
 *
 * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct
 * values in AVStream.time_base units (and guessed if the format cannot
 * provide them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format
 * has B-frames, so it is better to rely on pkt-&gt;dts if you do not
 * decompress the payload.
 *
 * @return 0 if OK, &lt; 0 on error or end of file
 */</doc>
