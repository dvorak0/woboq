<def f='include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h' l='68' ll='360'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h' l='25'>/** \eigenvalues_module \ingroup Eigenvalues_Module
  *
  *
  * \class SelfAdjointEigenSolver
  *
  * \brief Computes eigenvalues and eigenvectors of selfadjoint matrices
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the
  * eigendecomposition; this is expected to be an instantiation of the Matrix
  * class template.
  *
  * A matrix \f$ A \f$ is selfadjoint if it equals its adjoint. For real
  * matrices, this means that the matrix is symmetric: it equals its
  * transpose. This class computes the eigenvalues and eigenvectors of a
  * selfadjoint matrix. These are the scalars \f$ \lambda \f$ and vectors
  * \f$ v \f$ such that \f$ Av = \lambda v \f$.  The eigenvalues of a
  * selfadjoint matrix are always real. If \f$ D \f$ is a diagonal matrix with
  * the eigenvalues on the diagonal, and \f$ V \f$ is a matrix with the
  * eigenvectors as its columns, then \f$ A = V D V^{-1} \f$ (for selfadjoint
  * matrices, the matrix \f$ V \f$ is always invertible). This is called the
  * eigendecomposition.
  *
  * The algorithm exploits the fact that the matrix is selfadjoint, making it
  * faster and more accurate than the general purpose eigenvalue algorithms
  * implemented in EigenSolver and ComplexEigenSolver.
  *
  * Only the \b lower \b triangular \b part of the input matrix is referenced.
  *
  * Call the function compute() to compute the eigenvalues and eigenvectors of
  * a given matrix. Alternatively, you can use the
  * SelfAdjointEigenSolver(const MatrixType&amp;, int) constructor which computes
  * the eigenvalues and eigenvectors at construction time. Once the eigenvalue
  * and eigenvectors are computed, they can be retrieved with the eigenvalues()
  * and eigenvectors() functions.
  *
  * The documentation for SelfAdjointEigenSolver(const MatrixType&amp;, int)
  * contains an example of the typical use of this class.
  *
  * To solve the \em generalized eigenvalue problem \f$ Av = \lambda Bv \f$ and
  * the likes, see the class GeneralizedSelfAdjointEigenSolver.
  *
  * \sa MatrixBase::eigenvalues(), class EigenSolver, class ComplexEigenSolver
  */</doc>
<fun r='_ZN5Eigen22SelfAdjointEigenSolverC1Ev'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolverC1ENT_5IndexE'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolverC1ERKT_i'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolver7computeERKT_i'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolver13computeDirectERKT_i'/>
<fun r='_ZNK5Eigen22SelfAdjointEigenSolver12eigenvectorsEv'/>
<fun r='_ZNK5Eigen22SelfAdjointEigenSolver11eigenvaluesEv'/>
<fun r='_ZNK5Eigen22SelfAdjointEigenSolver12operatorSqrtEv'/>
<fun r='_ZNK5Eigen22SelfAdjointEigenSolver19operatorInverseSqrtEv'/>
<fun r='_ZNK5Eigen22SelfAdjointEigenSolver4infoEv'/>
<smbr r='Eigen::SelfAdjointEigenSolver::m_maxIterations' t='const int'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_eivec' t='MatrixType'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_eivalues' t='RealVectorType'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_subdiag' t='typename TridiagonalizationType::SubDiagonalType'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_info' t='Eigen::ComputationInfo'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_isInitialized' t='bool'/>
<mbr r='Eigen::SelfAdjointEigenSolver::m_eigenvectorsOk' t='bool'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolver7computeERKT_i'/>
<fun r='_ZN5Eigen22SelfAdjointEigenSolver13computeDirectERKT_i'/>
