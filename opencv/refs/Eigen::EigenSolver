<def f='include/eigen3/Eigen/src/Eigenvalues/EigenSolver.h' l='64' ll='310'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/EigenSolver.h' l='18'>/** \eigenvalues_module \ingroup Eigenvalues_Module
  *
  *
  * \class EigenSolver
  *
  * \brief Computes eigenvalues and eigenvectors of general matrices
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the
  * eigendecomposition; this is expected to be an instantiation of the Matrix
  * class template. Currently, only real matrices are supported.
  *
  * The eigenvalues and eigenvectors of a matrix \f$ A \f$ are scalars
  * \f$ \lambda \f$ and vectors \f$ v \f$ such that \f$ Av = \lambda v \f$.  If
  * \f$ D \f$ is a diagonal matrix with the eigenvalues on the diagonal, and
  * \f$ V \f$ is a matrix with the eigenvectors as its columns, then \f$ A V =
  * V D \f$. The matrix \f$ V \f$ is almost always invertible, in which case we
  * have \f$ A = V D V^{-1} \f$. This is called the eigendecomposition.
  *
  * The eigenvalues and eigenvectors of a matrix may be complex, even when the
  * matrix is real. However, we can choose real matrices \f$ V \f$ and \f$ D
  * \f$ satisfying \f$ A V = V D \f$, just like the eigendecomposition, if the
  * matrix \f$ D \f$ is not required to be diagonal, but if it is allowed to
  * have blocks of the form
  * \f[ \begin{bmatrix} u &amp; v \\ -v &amp; u \end{bmatrix} \f]
  * (where \f$ u \f$ and \f$ v \f$ are real numbers) on the diagonal.  These
  * blocks correspond to complex eigenvalue pairs \f$ u \pm iv \f$. We call
  * this variant of the eigendecomposition the pseudo-eigendecomposition.
  *
  * Call the function compute() to compute the eigenvalues and eigenvectors of
  * a given matrix. Alternatively, you can use the 
  * EigenSolver(const MatrixType&amp;, bool) constructor which computes the
  * eigenvalues and eigenvectors at construction time. Once the eigenvalue and
  * eigenvectors are computed, they can be retrieved with the eigenvalues() and
  * eigenvectors() functions. The pseudoEigenvalueMatrix() and
  * pseudoEigenvectors() methods allow the construction of the
  * pseudo-eigendecomposition.
  *
  * The documentation for EigenSolver(const MatrixType&amp;, bool) contains an
  * example of the typical use of this class.
  *
  * \note The implementation is adapted from
  * &lt;a href=&quot;http://math.nist.gov/javanumerics/jama/&quot;&gt;JAMA&lt;/a&gt; (public domain).
  * Their code is based on EISPACK.
  *
  * \sa MatrixBase::eigenvalues(), class ComplexEigenSolver, class SelfAdjointEigenSolver
  */</doc>
<fun r='_ZN5Eigen11EigenSolverC1Ev'/>
<fun r='_ZN5Eigen11EigenSolverC1ENT_5IndexE'/>
<fun r='_ZN5Eigen11EigenSolverC1ERKT_b'/>
<fun r='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<fun r='_ZNK5Eigen11EigenSolver18pseudoEigenvectorsEv'/>
<fun r='_ZNK5Eigen11EigenSolver22pseudoEigenvalueMatrixEv'/>
<fun r='_ZNK5Eigen11EigenSolver11eigenvaluesEv'/>
<fun r='_ZN5Eigen11EigenSolver7computeERKT_b'/>
<fun r='_ZNK5Eigen11EigenSolver4infoEv'/>
<fun r='_ZN5Eigen11EigenSolver16setMaxIterationsENT_5IndexE'/>
<fun r='_ZN5Eigen11EigenSolver16getMaxIterationsEv'/>
<fun r='_ZN5Eigen11EigenSolver21doComputeEigenvectorsEv'/>
<mbr r='Eigen::EigenSolver::m_eivec' t='MatrixType'/>
<mbr r='Eigen::EigenSolver::m_eivalues' t='EigenvalueType'/>
<mbr r='Eigen::EigenSolver::m_isInitialized' t='bool'/>
<mbr r='Eigen::EigenSolver::m_eigenvectorsOk' t='bool'/>
<mbr r='Eigen::EigenSolver::m_realSchur' t='RealSchur&lt;MatrixType&gt;'/>
<mbr r='Eigen::EigenSolver::m_matT' t='MatrixType'/>
<mbr r='Eigen::EigenSolver::m_tmp' t='ColumnVectorType'/>
<fun r='_ZNK5Eigen11EigenSolver22pseudoEigenvalueMatrixEv'/>
<fun r='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<fun r='_ZN5Eigen11EigenSolver7computeERKT_b'/>
<fun r='_ZN5Eigen11EigenSolver21doComputeEigenvectorsEv'/>
