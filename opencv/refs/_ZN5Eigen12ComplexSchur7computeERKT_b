<use f='include/eigen3/Eigen/src/Eigenvalues/ComplexSchur.h' l='120' u='c' c='_ZN5Eigen12ComplexSchurC1ERKT_b'/>
<dec f='include/eigen3/Eigen/src/Eigenvalues/ComplexSchur.h' l='189' type='ComplexSchur&lt;_MatrixType&gt; &amp; Eigen::ComplexSchur::compute(const MatrixType &amp; matrix, bool computeU = true)'/>
<def f='include/eigen3/Eigen/src/Eigenvalues/ComplexSchur.h' l='315' ll='334' type='ComplexSchur&lt;MatrixType&gt; &amp; Eigen::ComplexSchur::compute(const MatrixType &amp; matrix, bool computeU = true)'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/ComplexSchur.h' l='167'>/** \brief Computes Schur decomposition of given matrix. 
      * 
      * \param[in]  matrix  Square matrix whose Schur decomposition is to be computed.
      * \param[in]  computeU  If true, both T and U are computed; if false, only T is computed.

      * \returns    Reference to \c *this
      *
      * The Schur decomposition is computed by first reducing the
      * matrix to Hessenberg form using the class
      * HessenbergDecomposition. The Hessenberg matrix is then reduced
      * to triangular form by performing QR iterations with a single
      * shift. The cost of computing the Schur decomposition depends
      * on the number of iterations; as a rough guide, it may be taken
      * on the number of iterations; as a rough guide, it may be taken
      * to be \f$25n^3\f$ complex flops, or \f$10n^3\f$ complex flops
      * if \a computeU is false.
      *
      * Example: \include ComplexSchur_compute.cpp
      * Output: \verbinclude ComplexSchur_compute.out
      *
      * \sa compute(const MatrixType&amp;, bool, Index)
      */</doc>
