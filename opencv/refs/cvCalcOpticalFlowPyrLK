<dec f='opencv/modules/video/include/opencv2/video/tracking.hpp' l='73' type='void cvCalcOpticalFlowPyrLK(const CvArr * prev, const CvArr * curr, CvArr * prev_pyr, CvArr * curr_pyr, const CvPoint2D32f * prev_features, CvPoint2D32f * curr_features, int count, CvSize win_size, int level, char * status, float * track_error, CvTermCriteria criteria, int flags)'/>
<doc f='opencv/modules/video/include/opencv2/video/tracking.hpp' l='68'>/* It is Lucas &amp; Kanade method, modified to use pyramids.
   Also it does several iterations to get optical flow for
   every point at every pyramid level.
   Calculates optical flow between two images for certain set of points (i.e.
   it is a &quot;sparse&quot; optical flow, which is opposite to the previous 3 methods) */</doc>
<use f='opencv/modules/python/src2/cv2.cv.hpp' l='3519' u='c' c='_ZL24pycvCalcOpticalFlowPyrLKP7_objectS0_'/>
<def f='opencv/modules/video/src/lkpyramid.cpp' l='1428' ll='1452' type='void cvCalcOpticalFlowPyrLK(const void * arrA, const void * arrB, void * , void * , const CvPoint2D32f * featuresA, CvPoint2D32f * featuresB, int count, CvSize winSize, int level, char * status, float * error, CvTermCriteria criteria, int flags)'/>
<use f='opencv/modules/video/src/lkpyramid.cpp' l='2021' u='c' c='cvEstimateRigidTransform'/>
<use f='opencv/modules/video/test/test_optflowpyrlk.cpp' l='142' u='c' c='_ZN19CV_OptFlowPyrLKTest3runEi'/>
