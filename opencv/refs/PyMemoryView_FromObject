<dec f='include/python2.7/memoryobject.h' l='54' type='PyObject * PyMemoryView_FromObject(PyObject * base)'/>
<doc f='include/python2.7/memoryobject.h' l='23'>/* Return a contiguous chunk of memory representing the buffer
       from an object in a memory view object.  If a copy is made then the
       base object for the memory view will be a *new* bytes object. 
       
       Otherwise, the base-object will be the object itself and no 
       data-copying will be done. 

       The buffertype argument can be PyBUF_READ, PyBUF_WRITE,
       PyBUF_SHADOW to determine whether the returned buffer
       should be READONLY, WRITABLE, or set to update the
       original buffer if a copy must be made.  If buffertype is
       PyBUF_WRITE and the buffer is not contiguous an error will
       be raised.  In this circumstance, the user can use
       PyBUF_SHADOW to ensure that a a writable temporary
       contiguous buffer is returned.  The contents of this
       contiguous buffer will be copied back into the original
       object after the memoryview object is deleted as long as
       the original object is writable and allows setting an
       exclusive write lock. If this is not allowed by the
       original object, then a BufferError is raised.
       
       If the object is multi-dimensional and if fortran is &apos;F&apos;,
       the first dimension of the underlying array will vary the
       fastest in the buffer.  If fortran is &apos;C&apos;, then the last
       dimension will vary the fastest (C-style contiguous).  If
       fortran is &apos;A&apos;, then it does not matter and you will get
       whatever the object decides is more efficient.  

       A new reference is returned that must be DECREF&apos;d when finished.
    */</doc>
