<dec f='include/python2.7/ceval.h' l='117' type='PyThreadState * PyEval_SaveThread()'/>
<use f='opencv/modules/python/src2/cv2.cpp' l='71' u='c' c='_ZN14PyAllowThreadsC1Ev'/>
<use f='opencv/modules/python/src2/cv2.cv.hpp' l='2605' macro='1' u='c'/>
<use f='opencv/modules/python/src2/cv2.cv.hpp' l='2626' macro='1' u='c'/>
<use f='opencv/modules/python/src2/cv2.cv.hpp' l='2653' macro='1' u='c'/>
<doc f='include/python2.7/ceval.h' l='72'>/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn&apos;t touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_IOError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_IOError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of &apos;errno&apos; is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   initthread() in &quot;threadmodule.c&quot;.

   Note that not yet all candidates have been converted to use this
   mechanism!
*/</doc>
