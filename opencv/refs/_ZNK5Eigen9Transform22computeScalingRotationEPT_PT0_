<dec f='include/eigen3/Eigen/src/Geometry/Transform.h' l='553' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<def f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1046' ll='1062' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<doc f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1035'>/** decomposes the linear part of the transformation as a product rotation x scaling, the scaling being
  * not necessarily positive.
  *
  * If either pointer is zero, the corresponding computation is skipped.
  *
  *
  *
  * \svd_module
  *
  * \sa computeRotationScaling(), rotation(), class SVD
  */</doc>
