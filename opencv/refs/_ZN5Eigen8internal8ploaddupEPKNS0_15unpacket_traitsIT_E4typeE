<def f='include/eigen3/Eigen/src/Core/GenericPacketMath.h' l='164' ll='165' type='Packet Eigen::internal::ploaddup(const typename unpacket_traits&lt;Packet&gt;::type * from)'/>
<def f='include/eigen3/Eigen/src/Core/arch/SSE/PacketMath.h' l='295' ll='298' type='Packet4f Eigen::internal::ploaddup(const float * from)'/>
<def f='include/eigen3/Eigen/src/Core/arch/SSE/PacketMath.h' l='299' ll='300' type='Packet2d Eigen::internal::ploaddup(const double * from)'/>
<def f='include/eigen3/Eigen/src/Core/arch/SSE/PacketMath.h' l='301' ll='306' type='Packet4i Eigen::internal::ploaddup(const int * from)'/>
<def f='include/eigen3/Eigen/src/Core/arch/SSE/Complex.h' l='105' type='Eigen::internal::Packet2cf Eigen::internal::ploaddup(const std::complex&lt;float&gt; * from)'/>
<def f='include/eigen3/Eigen/src/Core/arch/SSE/Complex.h' l='311' type='Eigen::internal::Packet1cd Eigen::internal::ploaddup(const std::complex&lt;double&gt; * from)'/>
<doc f='include/eigen3/Eigen/src/Core/GenericPacketMath.h' l='159'>/** \internal \returns a packet with elements of \a *from duplicated.
  * For instance, for a packet of 8 elements, 4 scalar will be read from \a *from and
  * duplicated to form: {from[0],from[0],from[1],from[1],,from[2],from[2],,from[3],from[3]}
  * Currently, this function is only used for scalar * complex products.
 */</doc>
