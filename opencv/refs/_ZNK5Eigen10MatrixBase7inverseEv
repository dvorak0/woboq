<dec f='include/eigen3/Eigen/src/Core/MatrixBase.h' l='349' type='const internal::inverse_impl&lt;Derived&gt; Eigen::MatrixBase::inverse() const'/>
<def f='include/eigen3/Eigen/src/LU/Inverse.h' l='319' ll='325' type='const internal::inverse_impl&lt;Derived&gt; Eigen::MatrixBase::inverse() const'/>
<doc f='include/eigen3/Eigen/src/LU/Inverse.h' l='302'>/** \lu_module
  *
  * \returns the matrix inverse of this matrix.
  *
  * For small fixed sizes up to 4x4, this method uses cofactors.
  * In the general case, this method uses class PartialPivLU.
  *
  * \note This matrix must be invertible, otherwise the result is undefined. If you need an
  * invertibility check, do the following:
  * \li for fixed sizes up to 4x4, use computeInverseAndDetWithCheck().
  * \li for the general case, use class FullPivLU.
  *
  * Example: \include MatrixBase_inverse.cpp
  * Output: \verbinclude MatrixBase_inverse.out
  *
  * \sa computeInverseAndDetWithCheck()
  */</doc>
