<dec f='opencv/modules/calib3d/include/opencv2/calib3d/calib3d.hpp' l='118' type='void cvCorrectMatches(CvMat * F, CvMat * points1, CvMat * points2, CvMat * new_points1, CvMat * new_points2)'/>
<def f='opencv/modules/calib3d/src/triangulate.cpp' l='198' ll='408' type='void cvCorrectMatches(CvMat * F_, CvMat * points1_, CvMat * points2_, CvMat * new_points1, CvMat * new_points2)'/>
<use f='opencv/modules/calib3d/src/triangulate.cpp' l='445' u='c' c='_ZN2cv14correctMatchesERKNS_11_InputArrayES2_S2_RKNS_12_OutputArrayES5_'/>
<doc f='opencv/modules/calib3d/src/triangulate.cpp' l='184'>/*
 *	The Optimal Triangulation Method (see HZ for details)
 *		For each given point correspondence points1[i] &lt;-&gt; points2[i], and a fundamental matrix F,
 *		computes the corrected correspondences new_points1[i] &lt;-&gt; new_points2[i] that minimize the
 *		geometric error d(points1[i],new_points1[i])^2 + d(points2[i],new_points2[i])^2 (where d(a,b)
 *		is the geometric distance between points a and b) subject to the epipolar constraint
 *		new_points2&apos; * F * new_points1 = 0.
 *
 *		F_			:	3x3 fundamental matrix
 *		points1_	:	1xN matrix containing the first set of points
 *		points2_	:	1xN matrix containing the second set of points
 *		new_points1	:	the optimized points1_. if this is NULL, the corrected points are placed back in points1_
 *		new_points2	:	the optimized points2_. if this is NULL, the corrected points are placed back in points2_
 */</doc>
<use f='opencv/modules/calib3d/test/test_cameracalibration.cpp' l='1789' u='c' c='_ZN26CV_StereoCalibrationTest_C7correctERKN2cv3MatES3_S3_RS1_S4_'/>
