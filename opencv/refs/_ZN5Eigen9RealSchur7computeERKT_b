<use f='include/eigen3/Eigen/src/Eigenvalues/RealSchur.h' l='112' u='c' c='_ZN5Eigen9RealSchurC1ERKT_b'/>
<dec f='include/eigen3/Eigen/src/Eigenvalues/RealSchur.h' l='168' type='RealSchur&lt;_MatrixType&gt; &amp; Eigen::RealSchur::compute(const MatrixType &amp; matrix, bool computeU = true)'/>
<def f='include/eigen3/Eigen/src/Eigenvalues/RealSchur.h' l='245' ll='260' type='RealSchur&lt;MatrixType&gt; &amp; Eigen::RealSchur::compute(const MatrixType &amp; matrix, bool computeU = true)'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/RealSchur.h' l='149'>/** \brief Computes Schur decomposition of given matrix. 
      * 
      * \param[in]  matrix    Square matrix whose Schur decomposition is to be computed.
      * \param[in]  computeU  If true, both T and U are computed; if false, only T is computed.
      * \returns    Reference to \c *this
      *
      * The Schur decomposition is computed by first reducing the matrix to
      * Hessenberg form using the class HessenbergDecomposition. The Hessenberg
      * matrix is then reduced to triangular form by performing Francis QR
      * iterations with implicit double shift. The cost of computing the Schur
      * decomposition depends on the number of iterations; as a rough guide, it
      * may be taken to be \f$25n^3\f$ flops if \a computeU is true and
      * \f$10n^3\f$ flops if \a computeU is false.
      *
      * Example: \include RealSchur_compute.cpp
      * Output: \verbinclude RealSchur_compute.out
      *
      * \sa compute(const MatrixType&amp;, bool, Index)
      */</doc>
