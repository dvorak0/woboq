<dec f='include/eigen3/Eigen/src/Core/MatrixBase.h' l='304' type='NoAlias&lt;Derived, Eigen::MatrixBase&gt; Eigen::MatrixBase::noalias()'/>
<def f='include/eigen3/Eigen/src/Core/NoAlias.h' l='126' ll='130' type='NoAlias&lt;Derived, MatrixBase&gt; Eigen::MatrixBase::noalias()'/>
<doc f='include/eigen3/Eigen/src/Core/NoAlias.h' l='98'>/** \returns a pseudo expression of \c *this with an operator= assuming
  * no aliasing between \c *this and the source expression.
  *
  * More precisely, noalias() allows to bypass the EvalBeforeAssignBit flag.
  * Currently, even though several expressions may alias, only product
  * expressions have this flag. Therefore, noalias() is only usefull when
  * the source expression contains a matrix product.
  *
  * Here are some examples where noalias is usefull:
  * \code
  * D.noalias()  = A * B;
  * D.noalias() += A.transpose() * B;
  * D.noalias() -= 2 * A * B.adjoint();
  * \endcode
  *
  * On the other hand the following example will lead to a \b wrong result:
  * \code
  * A.noalias() = A * B;
  * \endcode
  * because the result matrix A is also an operand of the matrix product. Therefore,
  * there is no alternative than evaluating A * B in a temporary, that is the default
  * behavior when you write:
  * \code
  * A = A * B;
  * \endcode
  *
  * \sa class NoAlias
  */</doc>
