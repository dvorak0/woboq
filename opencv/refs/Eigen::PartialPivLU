<def f='include/eigen3/Eigen/src/LU/PartialPivLU.h' l='47' ll='179'/>
<doc f='include/eigen3/Eigen/src/LU/PartialPivLU.h' l='16'>/** \ingroup LU_Module
  *
  * \class PartialPivLU
  *
  * \brief LU decomposition of a matrix with partial pivoting, and related features
  *
  * \param MatrixType the type of the matrix of which we are computing the LU decomposition
  *
  * This class represents a LU decomposition of a \b square \b invertible matrix, with partial pivoting: the matrix A
  * is decomposed as A = PLU where L is unit-lower-triangular, U is upper-triangular, and P
  * is a permutation matrix.
  *
  * Typically, partial pivoting LU decomposition is only considered numerically stable for square invertible
  * matrices. Thus LAPACK&apos;s dgesv and dgesvx require the matrix to be square and invertible. The present class
  * does the same. It will assert that the matrix is square, but it won&apos;t (actually it can&apos;t) check that the
  * matrix is invertible: it is your task to check that you only use this decomposition on invertible matrices.
  *
  * The guaranteed safe alternative, working for all matrices, is the full pivoting LU decomposition, provided
  * by class FullPivLU.
  *
  * This is \b not a rank-revealing LU decomposition. Many features are intentionally absent from this class,
  * such as rank computation. If you need these features, use class FullPivLU.
  *
  * This LU decomposition is suitable to invert invertible matrices. It is what MatrixBase::inverse() uses
  * in the general case.
  * On the other hand, it is \b not suitable to determine whether a given matrix is invertible.
  *
  * The data of the LU decomposition can be directly accessed through the methods matrixLU(), permutationP().
  *
  * \sa MatrixBase::partialPivLu(), MatrixBase::determinant(), MatrixBase::inverse(), MatrixBase::computeInverse(), class FullPivLU
  */</doc>
<fun r='_ZN5Eigen12PartialPivLUC1Ev'/>
<fun r='_ZN5Eigen12PartialPivLUC1ENT_5IndexE'/>
<fun r='_ZN5Eigen12PartialPivLUC1ERKT_'/>
<fun r='_ZN5Eigen12PartialPivLU7computeERKT_'/>
<fun r='_ZNK5Eigen12PartialPivLU8matrixLUEv'/>
<fun r='_ZNK5Eigen12PartialPivLU12permutationPEv'/>
<fun r='_ZNK5Eigen12PartialPivLU5solveERKNS_10MatrixBaseIT_EE'/>
<fun r='_ZNK5Eigen12PartialPivLU7inverseEv'/>
<fun r='_ZNK5Eigen12PartialPivLU11determinantEv'/>
<fun r='_ZNK5Eigen12PartialPivLU19reconstructedMatrixEv'/>
<fun r='_ZNK5Eigen12PartialPivLU4rowsEv'/>
<fun r='_ZNK5Eigen12PartialPivLU4colsEv'/>
<mbr r='Eigen::PartialPivLU::m_lu' t='MatrixType'/>
<mbr r='Eigen::PartialPivLU::m_p' t='PermutationType'/>
<mbr r='Eigen::PartialPivLU::m_rowsTranspositions' t='TranspositionType'/>
<mbr r='Eigen::PartialPivLU::m_det_p' t='Index'/>
<mbr r='Eigen::PartialPivLU::m_isInitialized' t='bool'/>
<fun r='_ZN5Eigen12PartialPivLUC1Ev'/>
<fun r='_ZN5Eigen12PartialPivLUC1ENT_5IndexE'/>
<fun r='_ZN5Eigen12PartialPivLUC1ERKT_'/>
<fun r='_ZN5Eigen12PartialPivLU7computeERKT_'/>
<fun r='_ZNK5Eigen12PartialPivLU11determinantEv'/>
<fun r='_ZNK5Eigen12PartialPivLU19reconstructedMatrixEv'/>
