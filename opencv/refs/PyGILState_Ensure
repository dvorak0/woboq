<dec f='include/python2.7/pystate.h' l='160' type='PyGILState_STATE PyGILState_Ensure()'/>
<use f='opencv/modules/python/src2/cv2.cpp' l='83' u='c' c='_ZN11PyEnsureGILC1Ev'/>
<use f='opencv/modules/python/src2/cv2.cpp' l='1059' u='c' c='_ZL7OnMouseiiiiPv'/>
<use f='opencv/modules/python/src2/cv2.cpp' l='1096' u='c' c='_ZL8OnChangeiPv'/>
<doc f='include/python2.7/pystate.h' l='139'>/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque &quot;handle&quot; to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/</doc>
