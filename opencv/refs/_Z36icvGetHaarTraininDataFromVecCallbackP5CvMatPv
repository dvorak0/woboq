<dec f='opencv/apps/haartraining/_cvhaartraining.h' l='339' type='int icvGetHaarTraininDataFromVecCallback(CvMat * img, void * userdata)'/>
<def f='opencv/apps/haartraining/cvhaartraining.cpp' l='1852' ll='1882' type='int icvGetHaarTraininDataFromVecCallback(CvMat * img, void * userdata)'/>
<use f='opencv/apps/haartraining/cvhaartraining.cpp' l='1944' u='r' c='_ZL29icvGetHaarTrainingDataFromVecP18CvHaarTrainingDataiiP19CvIntHaarClassifierPKcPi'/>
<use f='opencv/apps/haartraining/cvhaartraining.cpp' l='1996' u='r' c='_ZL28icvGetHaarTrainingDataFromBGP18CvHaarTrainingDataiiP19CvIntHaarClassifierPdPKc'/>
<doc f='opencv/apps/haartraining/cvhaartraining.cpp' l='1741'>/*
 * icvGetHaarTrainingDataFromBG
 *
 * Fill &lt;data&gt; with background samples, passed &lt;cascade&gt;
 * Background reading process must be initialized before call.
 */
//static
//int icvGetHaarTrainingDataFromBG( CvHaarTrainingData* data, int first, int count,
//                                  CvIntHaarClassifier* cascade, double* acceptance_ratio )
//{
//    int i = 0;
//    ccounter_t consumed_count;
//    ccounter_t thread_consumed_count;
//
//    /* private variables */
//    CvMat img;
//    CvMat sum;
//    CvMat tilted;
//    CvMat sqsum;
//
//    sum_type* sumdata;
//    sum_type* tilteddata;
//    float*    normfactor;
//
//    /* end private variables */
//
//    assert( data != NULL );
//    assert( first + count &lt;= data-&gt;maxnum );
//    assert( cascade != NULL );
//
//    if( !cvbgdata ) return 0;
//
//    CCOUNTER_SET_ZERO(consumed_count);
//    CCOUNTER_SET_ZERO(thread_consumed_count);
//
//    #ifdef CV_OPENMP
//    #pragma omp parallel private(img, sum, tilted, sqsum, sumdata, tilteddata,
//                                 normfactor, thread_consumed_count)
//    #endif /* CV_OPENMP */
//    {
//        sumdata    = NULL;
//        tilteddata = NULL;
//        normfactor = NULL;
//
//        CCOUNTER_SET_ZERO(thread_consumed_count);
//
//        img = cvMat( data-&gt;winsize.height, data-&gt;winsize.width, CV_8UC1,
//            cvAlloc( sizeof( uchar ) * data-&gt;winsize.height * data-&gt;winsize.width ) );
//        sum = cvMat( data-&gt;winsize.height + 1, data-&gt;winsize.width + 1,
//                     CV_SUM_MAT_TYPE, NULL );
//        tilted = cvMat( data-&gt;winsize.height + 1, data-&gt;winsize.width + 1,
//                        CV_SUM_MAT_TYPE, NULL );
//        sqsum = cvMat( data-&gt;winsize.height + 1, data-&gt;winsize.width + 1,
//                       CV_SQSUM_MAT_TYPE,
//                       cvAlloc( sizeof( sqsum_type ) * (data-&gt;winsize.height + 1)
//                                                     * (data-&gt;winsize.width + 1) ) );
//
//        #ifdef CV_OPENMP
//        #pragma omp for schedule(static, 1)
//        #endif /* CV_OPENMP */
//        for( i = first; i &lt; first + count; i++ )
//        {
//            for( ; ; )
//            {
//                icvGetBackgroundImage( cvbgdata, cvbgreader, &amp;img );
//
//                CCOUNTER_INC(thread_consumed_count);
//
//                sumdata = (sum_type*) (data-&gt;sum.data.ptr + i * data-&gt;sum.step);
//                tilteddata = (sum_type*) (data-&gt;tilted.data.ptr + i * data-&gt;tilted.step);
//                normfactor = data-&gt;normfactor.data.fl + i;
//                sum.data.ptr = (uchar*) sumdata;
//                tilted.data.ptr = (uchar*) tilteddata;
//                icvGetAuxImages( &amp;img, &amp;sum, &amp;tilted, &amp;sqsum, normfactor );
//                if( cascade-&gt;eval( cascade, sumdata, tilteddata, *normfactor ) != 0.0F )
//                {
//                    break;
//                }
//            }
//
//#ifdef CV_VERBOSE
//            if( (i - first) % 500 == 0 )
//            {
//                fprintf( stderr, &quot;%3d%%\r&quot;, (int) ( 100.0 * (i - first) / count ) );
//                fflush( stderr );
//            }
//#endif /* CV_VERBOSE */
//
//        }
//
//        cvFree( &amp;(img.data.ptr) );
//        cvFree( &amp;(sqsum.data.ptr) );
//
//        #ifdef CV_OPENMP
//        #pragma omp critical (c_consumed_count)
//        #endif /* CV_OPENMP */
//        {
//            /* consumed_count += thread_consumed_count; */
//            CCOUNTER_ADD(consumed_count, thread_consumed_count);
//        }
//    } /* omp parallel */
//
//    if( acceptance_ratio != NULL )
//    {
//        /* *acceptance_ratio = ((double) count) / consumed_count; */
//        *acceptance_ratio = CCOUNTER_DIV(count, consumed_count);
//    }
//
//    return count;
//}</doc>
<use f='opencv/apps/haartraining/cvsamples.cpp' l='939' u='c' c='_Z16cvShowVecSamplesPKciid'/>
