<def f='include/eigen3/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h' l='57' ll='276'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h' l='18'>/** \eigenvalues_module \ingroup Eigenvalues_Module
  *
  *
  * \class GeneralizedEigenSolver
  *
  * \brief Computes the generalized eigenvalues and eigenvectors of a pair of general matrices
  *
  * \tparam _MatrixType the type of the matrices of which we are computing the
  * eigen-decomposition; this is expected to be an instantiation of the Matrix
  * class template. Currently, only real matrices are supported.
  *
  * The generalized eigenvalues and eigenvectors of a matrix pair \f$ A \f$ and \f$ B \f$ are scalars
  * \f$ \lambda \f$ and vectors \f$ v \f$ such that \f$ Av = \lambda Bv \f$.  If
  * \f$ D \f$ is a diagonal matrix with the eigenvalues on the diagonal, and
  * \f$ V \f$ is a matrix with the eigenvectors as its columns, then \f$ A V =
  * B V D \f$. The matrix \f$ V \f$ is almost always invertible, in which case we
  * have \f$ A = B V D V^{-1} \f$. This is called the generalized eigen-decomposition.
  *
  * The generalized eigenvalues and eigenvectors of a matrix pair may be complex, even when the
  * matrices are real. Moreover, the generalized eigenvalue might be infinite if the matrix B is
  * singular. To workaround this difficulty, the eigenvalues are provided as a pair of complex \f$ \alpha \f$
  * and real \f$ \beta \f$ such that: \f$ \lambda_i = \alpha_i / \beta_i \f$. If \f$ \beta_i \f$ is (nearly) zero,
  * then one can consider the well defined left eigenvalue \f$ \mu = \beta_i / \alpha_i\f$ such that:
  * \f$ \mu_i A v_i = B v_i \f$, or even \f$ \mu_i u_i^T A  = u_i^T B \f$ where \f$ u_i \f$ is
  * called the left eigenvector.
  *
  * Call the function compute() to compute the generalized eigenvalues and eigenvectors of
  * a given matrix pair. Alternatively, you can use the
  * GeneralizedEigenSolver(const MatrixType&amp;, const MatrixType&amp;, bool) constructor which computes the
  * eigenvalues and eigenvectors at construction time. Once the eigenvalue and
  * eigenvectors are computed, they can be retrieved with the eigenvalues() and
  * eigenvectors() functions.
  *
  * Here is an usage example of this class:
  * Example: \include GeneralizedEigenSolver.cpp
  * Output: \verbinclude GeneralizedEigenSolver.out
  *
  * \sa MatrixBase::eigenvalues(), class ComplexEigenSolver, class SelfAdjointEigenSolver
  */</doc>
<fun r='_ZN5Eigen22GeneralizedEigenSolverC1Ev'/>
<fun r='_ZN5Eigen22GeneralizedEigenSolverC1ENT_5IndexE'/>
<fun r='_ZN5Eigen22GeneralizedEigenSolverC1ERKT_S3_b'/>
<fun r='_ZNK5Eigen22GeneralizedEigenSolver11eigenvaluesEv'/>
<fun r='_ZNK5Eigen22GeneralizedEigenSolver6alphasEv'/>
<fun r='_ZNK5Eigen22GeneralizedEigenSolver5betasEv'/>
<fun r='_ZN5Eigen22GeneralizedEigenSolver7computeERKT_S3_b'/>
<fun r='_ZNK5Eigen22GeneralizedEigenSolver4infoEv'/>
<fun r='_ZN5Eigen22GeneralizedEigenSolver16setMaxIterationsENT_5IndexE'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_eivec' t='MatrixType'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_alphas' t='ComplexVectorType'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_betas' t='VectorType'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_isInitialized' t='bool'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_eigenvectorsOk' t='bool'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_realQZ' t='RealQZ&lt;MatrixType&gt;'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_matS' t='MatrixType'/>
<mbr r='Eigen::GeneralizedEigenSolver::m_tmp' t='ColumnVectorType'/>
<fun r='_ZN5Eigen22GeneralizedEigenSolver7computeERKT_S3_b'/>
