<dec f='include/eigen3/Eigen/src/Core/TriangularMatrix.h' l='330' type='const internal::triangular_solve_retval&lt;Side, TriangularView&lt;MatrixType, Mode&gt;, Other&gt; Eigen::TriangularView::solve(const MatrixBase&lt;Other&gt; &amp; other) const'/>
<def f='include/eigen3/Eigen/src/Core/SolveTriangular.h' l='213' ll='219' type='const internal::triangular_solve_retval&lt;Side, TriangularView&lt;Derived, Mode&gt;, Other&gt; Eigen::TriangularView::solve(const MatrixBase&lt;Other&gt; &amp; other) const'/>
<doc f='include/eigen3/Eigen/src/Core/SolveTriangular.h' l='192'>/** \returns the product of the inverse of \c *this with \a other, \a *this being triangular.
  *
  * This function computes the inverse-matrix matrix product inverse(\c *this) * \a other if
  * \a Side==OnTheLeft (the default), or the right-inverse-multiply  \a other * inverse(\c *this) if
  * \a Side==OnTheRight.
  *
  * The matrix \c *this must be triangular and invertible (i.e., all the coefficients of the
  * diagonal must be non zero). It works as a forward (resp. backward) substitution if \c *this
  * is an upper (resp. lower) triangular matrix.
  *
  * Example: \include MatrixBase_marked.cpp
  * Output: \verbinclude MatrixBase_marked.out
  *
  * This function returns an expression of the inverse-multiply and can works in-place if it is assigned
  * to the same matrix or vector \a other.
  *
  * For users coming from BLAS, this function (and more specifically solveInPlace()) offer
  * all the operations supported by the \c *TRSV and \c *TRSM BLAS routines.
  *
  * \sa TriangularView::solveInPlace()
  */</doc>
