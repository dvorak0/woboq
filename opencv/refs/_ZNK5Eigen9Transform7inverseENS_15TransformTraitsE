<dec f='include/eigen3/Eigen/src/Geometry/Transform.h' l='559' type='Transform&lt;Scalar, Dim, Mode, _Options&gt; Eigen::Transform::inverse(Eigen::TransformTraits traits = (Eigen::TransformTraits)Mode) const'/>
<def f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1122' ll='1151' type='Transform&lt;Scalar, Dim, Mode, Options&gt; Eigen::Transform::inverse(Eigen::TransformTraits hint = (Eigen::TransformTraits)Mode) const'/>
<doc f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1102'>/**
  *
  * \returns the inverse transformation according to some given knowledge
  * on \c *this.
  *
  * \param hint allows to optimize the inversion process when the transformation
  * is known to be not a general transformation (optional). The possible values are:
  *  - #Projective if the transformation is not necessarily affine, i.e., if the
  *    last row is not guaranteed to be [0 ... 0 1]
  *  - #Affine if the last row can be assumed to be [0 ... 0 1]
  *  - #Isometry if the transformation is only a concatenations of translations
  *    and rotations.
  *  The default is the template class parameter \c Mode.
  *
  * \warning unless \a traits is always set to NoShear or NoScaling, this function
  * requires the generic inverse method of MatrixBase defined in the LU module. If
  * you forget to include this module, then you will get hard to debug linking errors.
  *
  * \sa MatrixBase::inverse()
  */</doc>
