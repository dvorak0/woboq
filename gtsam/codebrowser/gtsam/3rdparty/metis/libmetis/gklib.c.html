<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>gklib.c source code [codebrowser/gtsam/3rdparty/metis/libmetis/gklib.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/gtsam/3rdparty/metis/libmetis/gklib.c'; var root_path = '../../../../..'; var data_path = '../../../../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>codebrowser</a>/<a href='../../..'>gtsam</a>/<a href='../..'>3rdparty</a>/<a href='..'>metis</a>/<a href='./'>libmetis</a>/<a href='gklib.c.html'>gklib.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i class="doc">/*!</i></td></tr>
<tr><th id="2">2</th><td><i class="doc"><span class="command">\file</span> <span class="verb"> gklib.c</span></i></td></tr>
<tr><th id="3">3</th><td><i class="doc"><span class="command">\brief</span> Various helper routines generated using GKlib's templates</i></td></tr>
<tr><th id="4">4</th><td><i class="doc"></i></td></tr>
<tr><th id="5">5</th><td><i class="doc"><span class="command">\date</span>   Started 4/12/2007</i></td></tr>
<tr><th id="6">6</th><td><i class="doc"><span class="command">\author</span> George  </i></td></tr>
<tr><th id="7">7</th><td><i class="doc"><span class="command">\author</span> Copyright 1997-2009, Regents of the University of Minnesota </i></td></tr>
<tr><th id="8">8</th><td><i class="doc"><span class="command">\version</span><span class="command">\verbatim</span><span class="verb"> $Id: gklib.c 10395 2011-06-23 23:28:06Z karypis $ \</span>endverbatim</i></td></tr>
<tr><th id="9">9</th><td><i class="doc">*/</i></td></tr>
<tr><th id="10">10</th><td></td></tr>
<tr><th id="11">11</th><td></td></tr>
<tr><th id="12">12</th><td><u>#include <a href="metislib.h.html">"metislib.h"</a></u></td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td></td></tr>
<tr><th id="15">15</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="16">16</th><td><i class="doc">/*! BLAS routines */</i></td></tr>
<tr><th id="17">17</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="18">18</th><td><a class="macro" href="../GKlib/gk_mkblas.h.html#14" title="idx_t *libmetis__iincset(size_t n, idx_t baseval, idx_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} idx_t libmetis__imax(size_t n, idx_t *x){ size_t i, max=0; if (n &lt;= 0) return (idx_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} idx_t libmetis__imin(size_t n, idx_t *x){ size_t i, min=0; if (n &lt;= 0) return (idx_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t libmetis__iargmax(size_t n, idx_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t libmetis__iargmin(size_t n, idx_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t libmetis__iargmax_n(size_t n, idx_t *x, size_t k){ size_t i, max_n; ikv_t *cand; cand = libmetis__ikvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } libmetis__ikvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} idx_t libmetis__isum(size_t n, idx_t *x, size_t incx){ size_t i; idx_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} idx_t *libmetis__iscale(size_t n, idx_t alpha, idx_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} idx_t libmetis__inorm2(size_t n, idx_t *x, size_t incx){ size_t i; idx_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (idx_t)sqrt((double)partial) : (idx_t)0);} idx_t libmetis__idot(size_t n, idx_t *x, size_t incx, idx_t *y, size_t incy){ size_t i; idx_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} idx_t *libmetis__iaxpy(size_t n, idx_t alpha, idx_t *x, size_t incx, idx_t *y, size_t incy){ size_t i; idx_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(i,  <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>,  <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>)</td></tr>
<tr><th id="19">19</th><td><a class="macro" href="../GKlib/gk_mkblas.h.html#14" title="real_t *libmetis__rincset(size_t n, real_t baseval, real_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} real_t libmetis__rmax(size_t n, real_t *x){ size_t i, max=0; if (n &lt;= 0) return (real_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} real_t libmetis__rmin(size_t n, real_t *x){ size_t i, min=0; if (n &lt;= 0) return (real_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t libmetis__rargmax(size_t n, real_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t libmetis__rargmin(size_t n, real_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t libmetis__rargmax_n(size_t n, real_t *x, size_t k){ size_t i, max_n; rkv_t *cand; cand = libmetis__rkvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } libmetis__rkvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} real_t libmetis__rsum(size_t n, real_t *x, size_t incx){ size_t i; real_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} real_t *libmetis__rscale(size_t n, real_t alpha, real_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} real_t libmetis__rnorm2(size_t n, real_t *x, size_t incx){ size_t i; real_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (real_t)sqrt((double)partial) : (real_t)0);} real_t libmetis__rdot(size_t n, real_t *x, size_t incx, real_t *y, size_t incy){ size_t i; real_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} real_t *libmetis__raxpy(size_t n, real_t alpha, real_t *x, size_t incx, real_t *y, size_t incy){ size_t i; real_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(r,  <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>, <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>)</td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="22">22</th><td><i class="doc">/*! Memory allocation routines */</i></td></tr>
<tr><th id="23">23</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="24">24</th><td><a class="macro" href="../GKlib/gk_mkmemory.h.html#14" title="idx_t *libmetis__imalloc(size_t n, char *msg){ return (idx_t *)gk_malloc(sizeof(idx_t)*n, msg);} idx_t *libmetis__irealloc(idx_t *ptr, size_t n, char *msg){ return (idx_t *)gk_realloc((void *)ptr, sizeof(idx_t)*n, msg);} idx_t *libmetis__ismalloc(size_t n, idx_t ival, char *msg){ idx_t *ptr; ptr = (idx_t *)gk_malloc(sizeof(idx_t)*n, msg); if (ptr == ((void*)0)) return ((void*)0); return libmetis__iset(n, ival, ptr); } idx_t *libmetis__iset(size_t n, idx_t val, idx_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = val; return x;} idx_t *libmetis__icopy(size_t n, idx_t *a, idx_t *b){ return (idx_t *)memmove((void *)b, (void *)a, sizeof(idx_t)*n);} idx_t **libmetis__iAllocMatrix(size_t ndim1, size_t ndim2, idx_t value, char *errmsg){ gk_idx_t i, j; idx_t **matrix; matrix = (idx_t **)gk_malloc(ndim1*sizeof(idx_t *), errmsg); if (matrix == ((void*)0)) return ((void*)0); for (i=0; i&lt;ndim1; i++) { matrix[i] = libmetis__ismalloc(ndim2, value, errmsg); if (matrix[i] == ((void*)0)) { for (j=0; j&lt;i; j++) gk_free((void **)&amp;matrix[j], (void **) 0); return ((void*)0); } } return matrix;} void libmetis__iFreeMatrix(idx_t ***r_matrix, size_t ndim1, size_t ndim2){ gk_idx_t i; idx_t **matrix; if (*r_matrix == ((void*)0)) return; matrix = *r_matrix; for (i=0; i&lt;ndim1; i++) gk_free((void **)&amp;(matrix[i]), (void **) 0); gk_free((void **)r_matrix, (void **) 0);} void libmetis__iSetMatrix(idx_t **matrix, size_t ndim1, size_t ndim2, idx_t value){ gk_idx_t i, j; for (i=0; i&lt;ndim1; i++) { for (j=0; j&lt;ndim2; j++) matrix[i][j] = value; }}" data-ref="_M/GK_MKALLOC">GK_MKALLOC</a>(i,    <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>)</td></tr>
<tr><th id="25">25</th><td><a class="macro" href="../GKlib/gk_mkmemory.h.html#14" title="real_t *libmetis__rmalloc(size_t n, char *msg){ return (real_t *)gk_malloc(sizeof(real_t)*n, msg);} real_t *libmetis__rrealloc(real_t *ptr, size_t n, char *msg){ return (real_t *)gk_realloc((void *)ptr, sizeof(real_t)*n, msg);} real_t *libmetis__rsmalloc(size_t n, real_t ival, char *msg){ real_t *ptr; ptr = (real_t *)gk_malloc(sizeof(real_t)*n, msg); if (ptr == ((void*)0)) return ((void*)0); return libmetis__rset(n, ival, ptr); } real_t *libmetis__rset(size_t n, real_t val, real_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = val; return x;} real_t *libmetis__rcopy(size_t n, real_t *a, real_t *b){ return (real_t *)memmove((void *)b, (void *)a, sizeof(real_t)*n);} real_t **libmetis__rAllocMatrix(size_t ndim1, size_t ndim2, real_t value, char *errmsg){ gk_idx_t i, j; real_t **matrix; matrix = (real_t **)gk_malloc(ndim1*sizeof(real_t *), errmsg); if (matrix == ((void*)0)) return ((void*)0); for (i=0; i&lt;ndim1; i++) { matrix[i] = libmetis__rsmalloc(ndim2, value, errmsg); if (matrix[i] == ((void*)0)) { for (j=0; j&lt;i; j++) gk_free((void **)&amp;matrix[j], (void **) 0); return ((void*)0); } } return matrix;} void libmetis__rFreeMatrix(real_t ***r_matrix, size_t ndim1, size_t ndim2){ gk_idx_t i; real_t **matrix; if (*r_matrix == ((void*)0)) return; matrix = *r_matrix; for (i=0; i&lt;ndim1; i++) gk_free((void **)&amp;(matrix[i]), (void **) 0); gk_free((void **)r_matrix, (void **) 0);} void libmetis__rSetMatrix(real_t **matrix, size_t ndim1, size_t ndim2, real_t value){ gk_idx_t i, j; for (i=0; i&lt;ndim1; i++) { for (j=0; j&lt;ndim2; j++) matrix[i][j] = value; }}" data-ref="_M/GK_MKALLOC">GK_MKALLOC</a>(r,    <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>)</td></tr>
<tr><th id="26">26</th><td><a class="macro" href="../GKlib/gk_mkmemory.h.html#14" title="ikv_t *libmetis__ikvmalloc(size_t n, char *msg){ return (ikv_t *)gk_malloc(sizeof(ikv_t)*n, msg);} ikv_t *libmetis__ikvrealloc(ikv_t *ptr, size_t n, char *msg){ return (ikv_t *)gk_realloc((void *)ptr, sizeof(ikv_t)*n, msg);} ikv_t *libmetis__ikvsmalloc(size_t n, ikv_t ival, char *msg){ ikv_t *ptr; ptr = (ikv_t *)gk_malloc(sizeof(ikv_t)*n, msg); if (ptr == ((void*)0)) return ((void*)0); return libmetis__ikvset(n, ival, ptr); } ikv_t *libmetis__ikvset(size_t n, ikv_t val, ikv_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = val; return x;} ikv_t *libmetis__ikvcopy(size_t n, ikv_t *a, ikv_t *b){ return (ikv_t *)memmove((void *)b, (void *)a, sizeof(ikv_t)*n);} ikv_t **libmetis__ikvAllocMatrix(size_t ndim1, size_t ndim2, ikv_t value, char *errmsg){ gk_idx_t i, j; ikv_t **matrix; matrix = (ikv_t **)gk_malloc(ndim1*sizeof(ikv_t *), errmsg); if (matrix == ((void*)0)) return ((void*)0); for (i=0; i&lt;ndim1; i++) { matrix[i] = libmetis__ikvsmalloc(ndim2, value, errmsg); if (matrix[i] == ((void*)0)) { for (j=0; j&lt;i; j++) gk_free((void **)&amp;matrix[j], (void **) 0); return ((void*)0); } } return matrix;} void libmetis__ikvFreeMatrix(ikv_t ***r_matrix, size_t ndim1, size_t ndim2){ gk_idx_t i; ikv_t **matrix; if (*r_matrix == ((void*)0)) return; matrix = *r_matrix; for (i=0; i&lt;ndim1; i++) gk_free((void **)&amp;(matrix[i]), (void **) 0); gk_free((void **)r_matrix, (void **) 0);} void libmetis__ikvSetMatrix(ikv_t **matrix, size_t ndim1, size_t ndim2, ikv_t value){ gk_idx_t i, j; for (i=0; i&lt;ndim1; i++) { for (j=0; j&lt;ndim2; j++) matrix[i][j] = value; }}" data-ref="_M/GK_MKALLOC">GK_MKALLOC</a>(ikv,  <a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a>)</td></tr>
<tr><th id="27">27</th><td><a class="macro" href="../GKlib/gk_mkmemory.h.html#14" title="rkv_t *libmetis__rkvmalloc(size_t n, char *msg){ return (rkv_t *)gk_malloc(sizeof(rkv_t)*n, msg);} rkv_t *libmetis__rkvrealloc(rkv_t *ptr, size_t n, char *msg){ return (rkv_t *)gk_realloc((void *)ptr, sizeof(rkv_t)*n, msg);} rkv_t *libmetis__rkvsmalloc(size_t n, rkv_t ival, char *msg){ rkv_t *ptr; ptr = (rkv_t *)gk_malloc(sizeof(rkv_t)*n, msg); if (ptr == ((void*)0)) return ((void*)0); return libmetis__rkvset(n, ival, ptr); } rkv_t *libmetis__rkvset(size_t n, rkv_t val, rkv_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = val; return x;} rkv_t *libmetis__rkvcopy(size_t n, rkv_t *a, rkv_t *b){ return (rkv_t *)memmove((void *)b, (void *)a, sizeof(rkv_t)*n);} rkv_t **libmetis__rkvAllocMatrix(size_t ndim1, size_t ndim2, rkv_t value, char *errmsg){ gk_idx_t i, j; rkv_t **matrix; matrix = (rkv_t **)gk_malloc(ndim1*sizeof(rkv_t *), errmsg); if (matrix == ((void*)0)) return ((void*)0); for (i=0; i&lt;ndim1; i++) { matrix[i] = libmetis__rkvsmalloc(ndim2, value, errmsg); if (matrix[i] == ((void*)0)) { for (j=0; j&lt;i; j++) gk_free((void **)&amp;matrix[j], (void **) 0); return ((void*)0); } } return matrix;} void libmetis__rkvFreeMatrix(rkv_t ***r_matrix, size_t ndim1, size_t ndim2){ gk_idx_t i; rkv_t **matrix; if (*r_matrix == ((void*)0)) return; matrix = *r_matrix; for (i=0; i&lt;ndim1; i++) gk_free((void **)&amp;(matrix[i]), (void **) 0); gk_free((void **)r_matrix, (void **) 0);} void libmetis__rkvSetMatrix(rkv_t **matrix, size_t ndim1, size_t ndim2, rkv_t value){ gk_idx_t i, j; for (i=0; i&lt;ndim1; i++) { for (j=0; j&lt;ndim2; j++) matrix[i][j] = value; }}" data-ref="_M/GK_MKALLOC">GK_MKALLOC</a>(rkv,  <a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a>)</td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="30">30</th><td><i class="doc">/*! Priority queues routines */</i></td></tr>
<tr><th id="31">31</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="32">32</th><td><u>#define <dfn class="macro" id="_M/key_gt" data-ref="_M/key_gt">key_gt</dfn>(a, b) ((a) &gt; (b))</u></td></tr>
<tr><th id="33">33</th><td><a class="macro" href="../GKlib/gk_mkpqueue.h.html#15" title="ipq_t *libmetis__ipqCreate(size_t maxnodes){ ipq_t *queue; queue = (ipq_t *)gk_malloc(sizeof(ipq_t), &quot;gk_pqCreate: queue&quot;); libmetis__ipqInit(queue, maxnodes); return queue;} void libmetis__ipqInit(ipq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = libmetis__ikvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void libmetis__ipqReset(ipq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; ikv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void libmetis__ipqFree(ipq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void libmetis__ipqDestroy(ipq_t *queue){ if (queue == ((void*)0)) return; libmetis__ipqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t libmetis__ipqLength(ipq_t *queue){ return queue-&gt;nnodes;} int libmetis__ipqInsert(ipq_t *queue, idx_t node, idx_t key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; ikv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int libmetis__ipqDelete(ipq_t *queue, idx_t node){ gk_idx_t i, j, nnodes; idx_t newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; ikv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void libmetis__ipqUpdate(ipq_t *queue, idx_t node, idx_t newkey){ gk_idx_t i, j, nnodes; idx_t oldkey; gk_idx_t *locator=queue-&gt;locator; ikv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} idx_t libmetis__ipqGetTop(ipq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; ikv_t *heap; idx_t vtx, node; idx_t key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} idx_t libmetis__ipqSeeTopVal(ipq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} idx_t libmetis__ipqSeeTopKey(ipq_t *queue){ return (queue-&gt;nnodes == 0 ? (2147483647) : queue-&gt;heap[0].key);} idx_t libmetis__ipqSeeKey(ipq_t *queue, idx_t node){ gk_idx_t *locator; ikv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int libmetis__ipqCheckHeap(ipq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; ikv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(ipq, <a class="typedef" href="gklib_defs.h.html#27" title='ipq_t' data-type='struct ipq_t' data-ref="ipq_t">ipq_t</a>, <a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="macro" href="gklib_rename.h.html#35" title="libmetis__ikvmalloc" data-ref="_M/ikvmalloc">ikvmalloc</a>, <a class="macro" href="../include/metis.h.html#103" title="(2147483647)" data-ref="_M/IDX_MAX">IDX_MAX</a>, key_gt)</td></tr>
<tr><th id="34">34</th><td><a class="macro" href="../GKlib/gk_mkpqueue.h.html#15" title="rpq_t *libmetis__rpqCreate(size_t maxnodes){ rpq_t *queue; queue = (rpq_t *)gk_malloc(sizeof(rpq_t), &quot;gk_pqCreate: queue&quot;); libmetis__rpqInit(queue, maxnodes); return queue;} void libmetis__rpqInit(rpq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = libmetis__rkvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void libmetis__rpqReset(rpq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; rkv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void libmetis__rpqFree(rpq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void libmetis__rpqDestroy(rpq_t *queue){ if (queue == ((void*)0)) return; libmetis__rpqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t libmetis__rpqLength(rpq_t *queue){ return queue-&gt;nnodes;} int libmetis__rpqInsert(rpq_t *queue, idx_t node, real_t key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; rkv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int libmetis__rpqDelete(rpq_t *queue, idx_t node){ gk_idx_t i, j, nnodes; real_t newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; rkv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void libmetis__rpqUpdate(rpq_t *queue, idx_t node, real_t newkey){ gk_idx_t i, j, nnodes; real_t oldkey; gk_idx_t *locator=queue-&gt;locator; rkv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} idx_t libmetis__rpqGetTop(rpq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; rkv_t *heap; idx_t vtx, node; real_t key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} idx_t libmetis__rpqSeeTopVal(rpq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} real_t libmetis__rpqSeeTopKey(rpq_t *queue){ return (queue-&gt;nnodes == 0 ? 3.40282347e+38F : queue-&gt;heap[0].key);} real_t libmetis__rpqSeeKey(rpq_t *queue, idx_t node){ gk_idx_t *locator; rkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int libmetis__rpqCheckHeap(rpq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; rkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(rpq, <a class="typedef" href="gklib_defs.h.html#28" title='rpq_t' data-type='struct rpq_t' data-ref="rpq_t">rpq_t</a>, <a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a>, <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="macro" href="gklib_rename.h.html#87" title="libmetis__rkvmalloc" data-ref="_M/rkvmalloc">rkvmalloc</a>, <a class="macro" href="../include/metis.h.html#136" title="3.40282347e+38F" data-ref="_M/REAL_MAX">REAL_MAX</a>, key_gt)</td></tr>
<tr><th id="35">35</th><td><u>#undef <a class="macro" href="#32" data-ref="_M/key_gt">key_gt</a></u></td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="38">38</th><td><i class="doc">/*! Random number generation routines */</i></td></tr>
<tr><th id="39">39</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="40">40</th><td><a class="macro" href="../GKlib/gk_mkrandom.h.html#23" title="void libmetis__isrand(idx_t seed) { gk_randinit((uint64_t) seed);} idx_t libmetis__irand() { if (sizeof(idx_t) &lt;= sizeof(int32_t)) return (idx_t)gk_randint32(); else return (idx_t)gk_randint64(); } idx_t libmetis__irandInRange(idx_t max) { return (idx_t)((libmetis__irand())%max); } void libmetis__irandArrayPermute(idx_t n, idx_t *p, idx_t nshuffles, int flag){ idx_t i, u, v; idx_t tmp; if (flag == 1) { for (i=0; i&lt;n; i++) p[i] = (idx_t)i; } if (n &lt; 10) { for (i=0; i&lt;n; i++) { v = libmetis__irandInRange(n); u = libmetis__irandInRange(n); do {(tmp) = (p[v]); (p[v]) = (p[u]); (p[u]) = (tmp);} while(0); } } else { for (i=0; i&lt;nshuffles; i++) { v = libmetis__irandInRange(n-3); u = libmetis__irandInRange(n-3); do {(tmp) = (p[v+0]); (p[v+0]) = (p[u+2]); (p[u+2]) = (tmp);} while(0); do {(tmp) = (p[v+1]); (p[v+1]) = (p[u+3]); (p[u+3]) = (tmp);} while(0); do {(tmp) = (p[v+2]); (p[v+2]) = (p[u+0]); (p[u+0]) = (tmp);} while(0); do {(tmp) = (p[v+3]); (p[v+3]) = (p[u+1]); (p[u+1]) = (tmp);} while(0); } }} void libmetis__irandArrayPermuteFine(idx_t n, idx_t *p, int flag){ idx_t i, v; idx_t tmp; if (flag == 1) { for (i=0; i&lt;n; i++) p[i] = (idx_t)i; } for (i=0; i&lt;n; i++) { v = libmetis__irandInRange(n); do {(tmp) = (p[i]); (p[i]) = (p[v]); (p[v]) = (tmp);} while(0); }}" data-ref="_M/GK_MKRANDOM">GK_MKRANDOM</a>(i, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>)</td></tr>
<tr><th id="41">41</th><td></td></tr>
<tr><th id="42">42</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="43">43</th><td><i class="doc">/*! Utility routines */</i></td></tr>
<tr><th id="44">44</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="45">45</th><td><a class="macro" href="../GKlib/gk_mkutils.h.html#14" title="void libmetis__iarray2csr(idx_t n, idx_t range, idx_t *array, idx_t *ptr, idx_t *ind){ idx_t i; for (i=0; i&lt;=range; i++) ptr[i] = 0; for (i=0; i&lt;n; i++) ptr[array[i]]++; do { for (i=1; i&lt;range; i++) ptr[i] += ptr[i-1]; for (i=range; i&gt;0; i--) ptr[i] = ptr[i-1]; ptr[0] = 0; } while(0); for (i=0; i&lt;n; i++) ind[ptr[array[i]]++] = i; do { for (i=range; i&gt;0; i--) ptr[i] = ptr[i-1]; ptr[0] = 0; } while(0);}" data-ref="_M/GK_MKARRAY2CSR">GK_MKARRAY2CSR</a>(i, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>)</td></tr>
<tr><th id="46">46</th><td></td></tr>
<tr><th id="47">47</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="48">48</th><td><i class="doc">/*! Sorting routines */</i></td></tr>
<tr><th id="49">49</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="50">50</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#70" title="libmetis__isorti" data-ref="_M/isorti">isorti</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col1 decl" id="1n" title='n' data-type='size_t' data-ref="1n">n</dfn>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a> *<dfn class="local col2 decl" id="2base" title='base' data-type='idx_t *' data-ref="2base">base</dfn>)</td></tr>
<tr><th id="51">51</th><td>{</td></tr>
<tr><th id="52">52</th><td><u>#define <dfn class="macro" id="_M/i_lt" data-ref="_M/i_lt">i_lt</dfn>(a, b) ((*a) &lt; (*b))</u></td></tr>
<tr><th id="53">53</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ idx_t *const _base = (base); const size_t _elems = (n); idx_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { idx_t *_lo = _base; idx_t *_hi = _lo + _elems - 1; struct { idx_t *_hi; idx_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { idx_t *_left_ptr; idx_t *_right_ptr; idx_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((*_mid) &lt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((*_hi) &lt; (*_mid))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((*_mid) &lt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((*_left_ptr) &lt; (*_mid))) ++_left_ptr; while (((*_mid) &lt; (*_right_ptr))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { idx_t *const _end_ptr = _base + _elems - 1; idx_t *_tmp_ptr = _base; register idx_t *_run_ptr; idx_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((*_run_ptr) &lt; (*_tmp_ptr))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((*_run_ptr) &lt; (*_tmp_ptr))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { idx_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { idx_t *_hi; idx_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="local col2 ref" href="#2base" title='base' data-ref="2base">base</a>, <a class="local col1 ref" href="#1n" title='n' data-ref="1n">n</a>, i_lt);</td></tr>
<tr><th id="54">54</th><td><u>#undef <a class="macro" href="#52" data-ref="_M/i_lt">i_lt</a></u></td></tr>
<tr><th id="55">55</th><td>}</td></tr>
<tr><th id="56">56</th><td></td></tr>
<tr><th id="57">57</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#69" title="libmetis__isortd" data-ref="_M/isortd">isortd</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col3 decl" id="3n" title='n' data-type='size_t' data-ref="3n">n</dfn>, <a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a> *<dfn class="local col4 decl" id="4base" title='base' data-type='idx_t *' data-ref="4base">base</dfn>)</td></tr>
<tr><th id="58">58</th><td>{</td></tr>
<tr><th id="59">59</th><td><u>#define <dfn class="macro" id="_M/i_gt" data-ref="_M/i_gt">i_gt</dfn>(a, b) ((*a) &gt; (*b))</u></td></tr>
<tr><th id="60">60</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ idx_t *const _base = (base); const size_t _elems = (n); idx_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { idx_t *_lo = _base; idx_t *_hi = _lo + _elems - 1; struct { idx_t *_hi; idx_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { idx_t *_left_ptr; idx_t *_right_ptr; idx_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((*_mid) &gt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((*_hi) &gt; (*_mid))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((*_mid) &gt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((*_left_ptr) &gt; (*_mid))) ++_left_ptr; while (((*_mid) &gt; (*_right_ptr))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { idx_t *const _end_ptr = _base + _elems - 1; idx_t *_tmp_ptr = _base; register idx_t *_run_ptr; idx_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((*_run_ptr) &gt; (*_tmp_ptr))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((*_run_ptr) &gt; (*_tmp_ptr))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { idx_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { idx_t *_hi; idx_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="../include/metis.h.html#idx_t" title='idx_t' data-type='int32_t' data-ref="idx_t">idx_t</a>, <a class="local col4 ref" href="#4base" title='base' data-ref="4base">base</a>, <a class="local col3 ref" href="#3n" title='n' data-ref="3n">n</a>, i_gt);</td></tr>
<tr><th id="61">61</th><td><u>#undef <a class="macro" href="#59" data-ref="_M/i_gt">i_gt</a></u></td></tr>
<tr><th id="62">62</th><td>}</td></tr>
<tr><th id="63">63</th><td></td></tr>
<tr><th id="64">64</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#116" title="libmetis__rsorti" data-ref="_M/rsorti">rsorti</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col5 decl" id="5n" title='n' data-type='size_t' data-ref="5n">n</dfn>, <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a> *<dfn class="local col6 decl" id="6base" title='base' data-type='real_t *' data-ref="6base">base</dfn>)</td></tr>
<tr><th id="65">65</th><td>{</td></tr>
<tr><th id="66">66</th><td><u>#define <dfn class="macro" id="_M/r_lt" data-ref="_M/r_lt">r_lt</dfn>(a, b) ((*a) &lt; (*b))</u></td></tr>
<tr><th id="67">67</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ real_t *const _base = (base); const size_t _elems = (n); real_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { real_t *_lo = _base; real_t *_hi = _lo + _elems - 1; struct { real_t *_hi; real_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { real_t *_left_ptr; real_t *_right_ptr; real_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((*_mid) &lt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((*_hi) &lt; (*_mid))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((*_mid) &lt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((*_left_ptr) &lt; (*_mid))) ++_left_ptr; while (((*_mid) &lt; (*_right_ptr))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { real_t *const _end_ptr = _base + _elems - 1; real_t *_tmp_ptr = _base; register real_t *_run_ptr; real_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((*_run_ptr) &lt; (*_tmp_ptr))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((*_run_ptr) &lt; (*_tmp_ptr))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { real_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { real_t *_hi; real_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>, <a class="local col6 ref" href="#6base" title='base' data-ref="6base">base</a>, <a class="local col5 ref" href="#5n" title='n' data-ref="5n">n</a>, r_lt);</td></tr>
<tr><th id="68">68</th><td><u>#undef <a class="macro" href="#66" data-ref="_M/r_lt">r_lt</a></u></td></tr>
<tr><th id="69">69</th><td>}</td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#115" title="libmetis__rsortd" data-ref="_M/rsortd">rsortd</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col7 decl" id="7n" title='n' data-type='size_t' data-ref="7n">n</dfn>, <a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a> *<dfn class="local col8 decl" id="8base" title='base' data-type='real_t *' data-ref="8base">base</dfn>)</td></tr>
<tr><th id="72">72</th><td>{</td></tr>
<tr><th id="73">73</th><td><u>#define <dfn class="macro" id="_M/r_gt" data-ref="_M/r_gt">r_gt</dfn>(a, b) ((*a) &gt; (*b))</u></td></tr>
<tr><th id="74">74</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ real_t *const _base = (base); const size_t _elems = (n); real_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { real_t *_lo = _base; real_t *_hi = _lo + _elems - 1; struct { real_t *_hi; real_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { real_t *_left_ptr; real_t *_right_ptr; real_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((*_mid) &gt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((*_hi) &gt; (*_mid))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((*_mid) &gt; (*_lo))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((*_left_ptr) &gt; (*_mid))) ++_left_ptr; while (((*_mid) &gt; (*_right_ptr))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { real_t *const _end_ptr = _base + _elems - 1; real_t *_tmp_ptr = _base; register real_t *_run_ptr; real_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((*_run_ptr) &gt; (*_tmp_ptr))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((*_run_ptr) &gt; (*_tmp_ptr))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { real_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { real_t *_hi; real_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="../include/metis.h.html#real_t" title='real_t' data-type='float' data-ref="real_t">real_t</a>, <a class="local col8 ref" href="#8base" title='base' data-ref="8base">base</a>, <a class="local col7 ref" href="#7n" title='n' data-ref="7n">n</a>, r_gt);</td></tr>
<tr><th id="75">75</th><td><u>#undef <a class="macro" href="#73" data-ref="_M/r_gt">r_gt</a></u></td></tr>
<tr><th id="76">76</th><td>}</td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#40" title="libmetis__ikvsorti" data-ref="_M/ikvsorti">ikvsorti</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col9 decl" id="9n" title='n' data-type='size_t' data-ref="9n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a> *<dfn class="local col0 decl" id="10base" title='base' data-type='ikv_t *' data-ref="10base">base</dfn>)</td></tr>
<tr><th id="79">79</th><td>{</td></tr>
<tr><th id="80">80</th><td><u>#define <dfn class="macro" id="_M/ikey_lt" data-ref="_M/ikey_lt">ikey_lt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a>)</u></td></tr>
<tr><th id="81">81</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ ikv_t *const _base = (base); const size_t _elems = (n); ikv_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { ikv_t *_lo = _base; ikv_t *_hi = _lo + _elems - 1; struct { ikv_t *_hi; ikv_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { ikv_t *_left_ptr; ikv_t *_right_ptr; ikv_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;key &lt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;key &lt; (_mid)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;key &lt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;key &lt; (_mid)-&gt;key)) ++_left_ptr; while (((_mid)-&gt;key &lt; (_right_ptr)-&gt;key)) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { ikv_t *const _end_ptr = _base + _elems - 1; ikv_t *_tmp_ptr = _base; register ikv_t *_run_ptr; ikv_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key)) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key)) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { ikv_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { ikv_t *_hi; ikv_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a>, <a class="local col0 ref" href="#10base" title='base' data-ref="10base">base</a>, <a class="local col9 ref" href="#9n" title='n' data-ref="9n">n</a>, ikey_lt);</td></tr>
<tr><th id="82">82</th><td><u>#undef <a class="macro" href="#80" data-ref="_M/ikey_lt">ikey_lt</a></u></td></tr>
<tr><th id="83">83</th><td>}</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><i>/* Sorts based both on key and val */</i></td></tr>
<tr><th id="86">86</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#41" title="libmetis__ikvsortii" data-ref="_M/ikvsortii">ikvsortii</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col1 decl" id="11n" title='n' data-type='size_t' data-ref="11n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a> *<dfn class="local col2 decl" id="12base" title='base' data-type='ikv_t *' data-ref="12base">base</dfn>)</td></tr>
<tr><th id="87">87</th><td>{</td></tr>
<tr><th id="88">88</th><td><u>#define <dfn class="macro" id="_M/ikeyval_lt" data-ref="_M/ikeyval_lt">ikeyval_lt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> || ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> == (b)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> &amp;&amp; (a)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::val' data-ref="ikv_t::val">val</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::val' data-ref="ikv_t::val">val</a>))</u></td></tr>
<tr><th id="89">89</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ ikv_t *const _base = (base); const size_t _elems = (n); ikv_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { ikv_t *_lo = _base; ikv_t *_hi = _lo + _elems - 1; struct { ikv_t *_hi; ikv_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { ikv_t *_left_ptr; ikv_t *_right_ptr; ikv_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;key &lt; (_lo)-&gt;key || ((_mid)-&gt;key == (_lo)-&gt;key &amp;&amp; (_mid)-&gt;val &lt; (_lo)-&gt;val))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;key &lt; (_mid)-&gt;key || ((_hi)-&gt;key == (_mid)-&gt;key &amp;&amp; (_hi)-&gt;val &lt; (_mid)-&gt;val))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;key &lt; (_lo)-&gt;key || ((_mid)-&gt;key == (_lo)-&gt;key &amp;&amp; (_mid)-&gt;val &lt; (_lo)-&gt;val))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;key &lt; (_mid)-&gt;key || ((_left_ptr)-&gt;key == (_mid)-&gt;key &amp;&amp; (_left_ptr)-&gt;val &lt; (_mid)-&gt;val))) ++_left_ptr; while (((_mid)-&gt;key &lt; (_right_ptr)-&gt;key || ((_mid)-&gt;key == (_right_ptr)-&gt;key &amp;&amp; (_mid)-&gt;val &lt; (_right_ptr)-&gt;val))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { ikv_t *const _end_ptr = _base + _elems - 1; ikv_t *_tmp_ptr = _base; register ikv_t *_run_ptr; ikv_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key || ((_run_ptr)-&gt;key == (_tmp_ptr)-&gt;key &amp;&amp; (_run_ptr)-&gt;val &lt; (_tmp_ptr)-&gt;val))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key || ((_run_ptr)-&gt;key == (_tmp_ptr)-&gt;key &amp;&amp; (_run_ptr)-&gt;val &lt; (_tmp_ptr)-&gt;val))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { ikv_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { ikv_t *_hi; ikv_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a>, <a class="local col2 ref" href="#12base" title='base' data-ref="12base">base</a>, <a class="local col1 ref" href="#11n" title='n' data-ref="11n">n</a>, ikeyval_lt);</td></tr>
<tr><th id="90">90</th><td><u>#undef <a class="macro" href="#88" data-ref="_M/ikeyval_lt">ikeyval_lt</a></u></td></tr>
<tr><th id="91">91</th><td>}</td></tr>
<tr><th id="92">92</th><td></td></tr>
<tr><th id="93">93</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#39" title="libmetis__ikvsortd" data-ref="_M/ikvsortd">ikvsortd</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col3 decl" id="13n" title='n' data-type='size_t' data-ref="13n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a> *<dfn class="local col4 decl" id="14base" title='base' data-type='ikv_t *' data-ref="14base">base</dfn>)</td></tr>
<tr><th id="94">94</th><td>{</td></tr>
<tr><th id="95">95</th><td><u>#define <dfn class="macro" id="_M/ikey_gt" data-ref="_M/ikey_gt">ikey_gt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a> &gt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#25" title='(anonymous struct)::key' data-ref="ikv_t::key">key</a>)</u></td></tr>
<tr><th id="96">96</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ ikv_t *const _base = (base); const size_t _elems = (n); ikv_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { ikv_t *_lo = _base; ikv_t *_hi = _lo + _elems - 1; struct { ikv_t *_hi; ikv_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { ikv_t *_left_ptr; ikv_t *_right_ptr; ikv_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;key &gt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;key &gt; (_mid)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;key &gt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;key &gt; (_mid)-&gt;key)) ++_left_ptr; while (((_mid)-&gt;key &gt; (_right_ptr)-&gt;key)) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { ikv_t *const _end_ptr = _base + _elems - 1; ikv_t *_tmp_ptr = _base; register ikv_t *_run_ptr; ikv_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;key &gt; (_tmp_ptr)-&gt;key)) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;key &gt; (_tmp_ptr)-&gt;key)) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { ikv_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { ikv_t *_hi; ikv_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#25" title='ikv_t' data-type='struct ikv_t' data-ref="ikv_t">ikv_t</a>, <a class="local col4 ref" href="#14base" title='base' data-ref="14base">base</a>, <a class="local col3 ref" href="#13n" title='n' data-ref="13n">n</a>, ikey_gt);</td></tr>
<tr><th id="97">97</th><td><u>#undef <a class="macro" href="#95" data-ref="_M/ikey_gt">ikey_gt</a></u></td></tr>
<tr><th id="98">98</th><td>}</td></tr>
<tr><th id="99">99</th><td></td></tr>
<tr><th id="100">100</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#92" title="libmetis__rkvsorti" data-ref="_M/rkvsorti">rkvsorti</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col5 decl" id="15n" title='n' data-type='size_t' data-ref="15n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a> *<dfn class="local col6 decl" id="16base" title='base' data-type='rkv_t *' data-ref="16base">base</dfn>)</td></tr>
<tr><th id="101">101</th><td>{</td></tr>
<tr><th id="102">102</th><td><u>#define <dfn class="macro" id="_M/rkey_lt" data-ref="_M/rkey_lt">rkey_lt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#26" title='(anonymous struct)::key' data-ref="rkv_t::key">key</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#26" title='(anonymous struct)::key' data-ref="rkv_t::key">key</a>)</u></td></tr>
<tr><th id="103">103</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ rkv_t *const _base = (base); const size_t _elems = (n); rkv_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { rkv_t *_lo = _base; rkv_t *_hi = _lo + _elems - 1; struct { rkv_t *_hi; rkv_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { rkv_t *_left_ptr; rkv_t *_right_ptr; rkv_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;key &lt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;key &lt; (_mid)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;key &lt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;key &lt; (_mid)-&gt;key)) ++_left_ptr; while (((_mid)-&gt;key &lt; (_right_ptr)-&gt;key)) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { rkv_t *const _end_ptr = _base + _elems - 1; rkv_t *_tmp_ptr = _base; register rkv_t *_run_ptr; rkv_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key)) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;key &lt; (_tmp_ptr)-&gt;key)) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { rkv_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { rkv_t *_hi; rkv_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a>, <a class="local col6 ref" href="#16base" title='base' data-ref="16base">base</a>, <a class="local col5 ref" href="#15n" title='n' data-ref="15n">n</a>, rkey_lt);</td></tr>
<tr><th id="104">104</th><td><u>#undef <a class="macro" href="#102" data-ref="_M/rkey_lt">rkey_lt</a></u></td></tr>
<tr><th id="105">105</th><td>}</td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#91" title="libmetis__rkvsortd" data-ref="_M/rkvsortd">rkvsortd</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col7 decl" id="17n" title='n' data-type='size_t' data-ref="17n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a> *<dfn class="local col8 decl" id="18base" title='base' data-type='rkv_t *' data-ref="18base">base</dfn>)</td></tr>
<tr><th id="108">108</th><td>{</td></tr>
<tr><th id="109">109</th><td><u>#define <dfn class="macro" id="_M/rkey_gt" data-ref="_M/rkey_gt">rkey_gt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#26" title='(anonymous struct)::key' data-ref="rkv_t::key">key</a> &gt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#26" title='(anonymous struct)::key' data-ref="rkv_t::key">key</a>)</u></td></tr>
<tr><th id="110">110</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ rkv_t *const _base = (base); const size_t _elems = (n); rkv_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { rkv_t *_lo = _base; rkv_t *_hi = _lo + _elems - 1; struct { rkv_t *_hi; rkv_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { rkv_t *_left_ptr; rkv_t *_right_ptr; rkv_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;key &gt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;key &gt; (_mid)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;key &gt; (_lo)-&gt;key)) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;key &gt; (_mid)-&gt;key)) ++_left_ptr; while (((_mid)-&gt;key &gt; (_right_ptr)-&gt;key)) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { rkv_t *const _end_ptr = _base + _elems - 1; rkv_t *_tmp_ptr = _base; register rkv_t *_run_ptr; rkv_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;key &gt; (_tmp_ptr)-&gt;key)) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;key &gt; (_tmp_ptr)-&gt;key)) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { rkv_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { rkv_t *_hi; rkv_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#26" title='rkv_t' data-type='struct rkv_t' data-ref="rkv_t">rkv_t</a>, <a class="local col8 ref" href="#18base" title='base' data-ref="18base">base</a>, <a class="local col7 ref" href="#17n" title='n' data-ref="17n">n</a>, rkey_gt);</td></tr>
<tr><th id="111">111</th><td><u>#undef <a class="macro" href="#109" data-ref="_M/rkey_gt">rkey_gt</a></u></td></tr>
<tr><th id="112">112</th><td>}</td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><em>void</em> <a class="macro" href="gklib_rename.h.html#118" title="libmetis__uvwsorti" data-ref="_M/uvwsorti">uvwsorti</a>(<span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="local col9 decl" id="19n" title='n' data-type='size_t' data-ref="19n">n</dfn>, <a class="typedef" href="gklib_defs.h.html#uvw_t" title='uvw_t' data-type='struct uvw_t' data-ref="uvw_t">uvw_t</a> *<dfn class="local col0 decl" id="20base" title='base' data-type='uvw_t *' data-ref="20base">base</dfn>)</td></tr>
<tr><th id="115">115</th><td>{</td></tr>
<tr><th id="116">116</th><td><u>#define <dfn class="macro" id="_M/uvwkey_lt" data-ref="_M/uvwkey_lt">uvwkey_lt</dfn>(a, b) ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::u" title='(anonymous struct)::u' data-ref="uvw_t::u">u</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::u" title='(anonymous struct)::u' data-ref="uvw_t::u">u</a> || ((a)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::u" title='(anonymous struct)::u' data-ref="uvw_t::u">u</a> == (b)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::u" title='(anonymous struct)::u' data-ref="uvw_t::u">u</a> &amp;&amp; (a)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::v" title='(anonymous struct)::v' data-ref="uvw_t::v">v</a> &lt; (b)-&gt;<a class="ref field" href="gklib_defs.h.html#uvw_t::v" title='(anonymous struct)::v' data-ref="uvw_t::v">v</a>))</u></td></tr>
<tr><th id="117">117</th><td>  <a class="macro" href="../GKlib/gk_mksort.h.html#120" title="{ uvw_t *const _base = (base); const size_t _elems = (n); uvw_t _hold; if (_elems == 0) return; if (_elems &gt; 4) { uvw_t *_lo = _base; uvw_t *_hi = _lo + _elems - 1; struct { uvw_t *_hi; uvw_t *_lo; } _stack[(8 * sizeof(size_t))], *_top = _stack + 1; while ((_stack &lt; _top)) { uvw_t *_left_ptr; uvw_t *_right_ptr; uvw_t *_mid = _lo + ((_hi - _lo) &gt;&gt; 1); if (((_mid)-&gt;u &lt; (_lo)-&gt;u || ((_mid)-&gt;u == (_lo)-&gt;u &amp;&amp; (_mid)-&gt;v &lt; (_lo)-&gt;v))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); if (((_hi)-&gt;u &lt; (_mid)-&gt;u || ((_hi)-&gt;u == (_mid)-&gt;u &amp;&amp; (_hi)-&gt;v &lt; (_mid)-&gt;v))) ((void)((_hold = *_mid), (*_mid = *_hi), (*_hi = _hold))); else goto _jump_over; if (((_mid)-&gt;u &lt; (_lo)-&gt;u || ((_mid)-&gt;u == (_lo)-&gt;u &amp;&amp; (_mid)-&gt;v &lt; (_lo)-&gt;v))) ((void)((_hold = *_mid), (*_mid = *_lo), (*_lo = _hold))); _jump_over:; _left_ptr = _lo + 1; _right_ptr = _hi - 1; do { while (((_left_ptr)-&gt;u &lt; (_mid)-&gt;u || ((_left_ptr)-&gt;u == (_mid)-&gt;u &amp;&amp; (_left_ptr)-&gt;v &lt; (_mid)-&gt;v))) ++_left_ptr; while (((_mid)-&gt;u &lt; (_right_ptr)-&gt;u || ((_mid)-&gt;u == (_right_ptr)-&gt;u &amp;&amp; (_mid)-&gt;v &lt; (_right_ptr)-&gt;v))) --_right_ptr; if (_left_ptr &lt; _right_ptr) { ((void)((_hold = *_left_ptr), (*_left_ptr = *_right_ptr), (*_right_ptr = _hold))); if (_mid == _left_ptr) _mid = _right_ptr; else if (_mid == _right_ptr) _mid = _left_ptr; ++_left_ptr; --_right_ptr; } else if (_left_ptr == _right_ptr) { ++_left_ptr; --_right_ptr; break; } } while (_left_ptr &lt;= _right_ptr); if (_right_ptr - _lo &lt;= 4) { if (_hi - _left_ptr &lt;= 4) ((--_top, (_lo = _top-&gt;_lo), (_hi = _top-&gt;_hi))); else _lo = _left_ptr; } else if (_hi - _left_ptr &lt;= 4) _hi = _right_ptr; else if (_right_ptr - _lo &gt; _hi - _left_ptr) { (((_top-&gt;_lo = (_lo)), (_top-&gt;_hi = (_right_ptr)), ++_top)); _lo = _left_ptr; } else { (((_top-&gt;_lo = (_left_ptr)), (_top-&gt;_hi = (_hi)), ++_top)); _hi = _right_ptr; } } } { uvw_t *const _end_ptr = _base + _elems - 1; uvw_t *_tmp_ptr = _base; register uvw_t *_run_ptr; uvw_t *_thresh; _thresh = _base + 4; if (_thresh &gt; _end_ptr) _thresh = _end_ptr; for (_run_ptr = _tmp_ptr + 1; _run_ptr &lt;= _thresh; ++_run_ptr) if (((_run_ptr)-&gt;u &lt; (_tmp_ptr)-&gt;u || ((_run_ptr)-&gt;u == (_tmp_ptr)-&gt;u &amp;&amp; (_run_ptr)-&gt;v &lt; (_tmp_ptr)-&gt;v))) _tmp_ptr = _run_ptr; if (_tmp_ptr != _base) ((void)((_hold = *_tmp_ptr), (*_tmp_ptr = *_base), (*_base = _hold))); _run_ptr = _base + 1; while (++_run_ptr &lt;= _end_ptr) { _tmp_ptr = _run_ptr - 1; while (((_run_ptr)-&gt;u &lt; (_tmp_ptr)-&gt;u || ((_run_ptr)-&gt;u == (_tmp_ptr)-&gt;u &amp;&amp; (_run_ptr)-&gt;v &lt; (_tmp_ptr)-&gt;v))) --_tmp_ptr; ++_tmp_ptr; if (_tmp_ptr != _run_ptr) { uvw_t *_trav = _run_ptr + 1; while (--_trav &gt;= _run_ptr) { uvw_t *_hi; uvw_t *_lo; _hold = *_trav; for (_hi = _lo = _trav; --_lo &gt;= _tmp_ptr; _hi = _lo) *_hi = *_lo; *_hi = _hold; } } } } }" data-ref="_M/GK_MKQSORT">GK_MKQSORT</a>(<a class="typedef" href="gklib_defs.h.html#uvw_t" title='uvw_t' data-type='struct uvw_t' data-ref="uvw_t">uvw_t</a>, <a class="local col0 ref" href="#20base" title='base' data-ref="20base">base</a>, <a class="local col9 ref" href="#19n" title='n' data-ref="19n">n</a>, uvwkey_lt);</td></tr>
<tr><th id="118">118</th><td><u>#undef <a class="macro" href="#116" data-ref="_M/uvwkey_lt">uvwkey_lt</a></u></td></tr>
<tr><th id="119">119</th><td>}</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2025-Nov-28</em> from project codebrowser revision <em>4.2.0-ros-3988-g645c5741e</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
