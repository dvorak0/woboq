<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>pqueue.c source code [codebrowser/gtsam/3rdparty/metis/GKlib/pqueue.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/gtsam/3rdparty/metis/GKlib/pqueue.c'; var root_path = '../../../../..'; var data_path = '../../../../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>codebrowser</a>/<a href='../../..'>gtsam</a>/<a href='../..'>3rdparty</a>/<a href='..'>metis</a>/<a href='./'>GKlib</a>/<a href='pqueue.c.html'>pqueue.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i class="doc">/*!</i></td></tr>
<tr><th id="2">2</th><td><i class="doc"><span class="command">\file</span> <span class="verb"> pqueue.c</span></i></td></tr>
<tr><th id="3">3</th><td><i class="doc"><span class="command">\brief</span> This file implements various max-priority queues.</i></td></tr>
<tr><th id="4">4</th><td><i class="doc"></i></td></tr>
<tr><th id="5">5</th><td><i class="doc">The priority queues are generated using the GK_MKPQUEUE macro.</i></td></tr>
<tr><th id="6">6</th><td><i class="doc"></i></td></tr>
<tr><th id="7">7</th><td><i class="doc"><span class="command">\date</span>   Started 3/27/2007</i></td></tr>
<tr><th id="8">8</th><td><i class="doc"><span class="command">\author</span> George</i></td></tr>
<tr><th id="9">9</th><td><i class="doc"><span class="command">\version</span><span class="command">\verbatim</span><span class="verb"> $Id: pqueue.c 10711 2011-08-31 22:23:04Z karypis $ \</span>endverbatim</i></td></tr>
<tr><th id="10">10</th><td><i class="doc">*/</i></td></tr>
<tr><th id="11">11</th><td></td></tr>
<tr><th id="12">12</th><td><u>#include <a href="GKlib.h.html">&lt;GKlib.h&gt;</a></u></td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td></td></tr>
<tr><th id="15">15</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="16">16</th><td><i class="doc">/*! Create the various max priority queues */</i></td></tr>
<tr><th id="17">17</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="18">18</th><td><u>#define <dfn class="macro" id="_M/key_gt" data-ref="_M/key_gt">key_gt</dfn>(a, b) ((a) &gt; (b))</u></td></tr>
<tr><th id="19">19</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_ipq_t *gk_ipqCreate(size_t maxnodes){ gk_ipq_t *queue; queue = (gk_ipq_t *)gk_malloc(sizeof(gk_ipq_t), &quot;gk_pqCreate: queue&quot;); gk_ipqInit(queue, maxnodes); return queue;} void gk_ipqInit(gk_ipq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_ikvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_ipqReset(gk_ipq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_ikv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_ipqFree(gk_ipq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_ipqDestroy(gk_ipq_t *queue){ if (queue == ((void*)0)) return; gk_ipqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_ipqLength(gk_ipq_t *queue){ return queue-&gt;nnodes;} int gk_ipqInsert(gk_ipq_t *queue, gk_idx_t node, int key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_ikv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_ipqDelete(gk_ipq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; int newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_ikv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_ipqUpdate(gk_ipq_t *queue, gk_idx_t node, int newkey){ gk_idx_t i, j, nnodes; int oldkey; gk_idx_t *locator=queue-&gt;locator; gk_ikv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_ipqGetTop(gk_ipq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_ikv_t *heap; gk_idx_t vtx, node; int key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_ipqSeeTopVal(gk_ipq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} int gk_ipqSeeTopKey(gk_ipq_t *queue){ return (queue-&gt;nnodes == 0 ? 2147483647 : queue-&gt;heap[0].key);} int gk_ipqSeeKey(gk_ipq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_ikv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_ipqCheckHeap(gk_ipq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_ikv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_ipq,   <a class="typedef" href="gk_struct.h.html#49" title='gk_ipq_t' data-type='struct gk_ipq_t' data-ref="gk_ipq_t">gk_ipq_t</a>,   <a class="typedef" href="gk_struct.h.html#25" title='gk_ikv_t' data-type='struct gk_ikv_t' data-ref="gk_ikv_t">gk_ikv_t</a>,   <em>int</em>,      <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#80" title='gk_ikvmalloc' data-ref="gk_ikvmalloc">gk_ikvmalloc</a>,   <span class="macro" title="2147483647" data-ref="_M/INT_MAX">INT_MAX</span>,    key_gt)</td></tr>
<tr><th id="20">20</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_i32pq_t *gk_i32pqCreate(size_t maxnodes){ gk_i32pq_t *queue; queue = (gk_i32pq_t *)gk_malloc(sizeof(gk_i32pq_t), &quot;gk_pqCreate: queue&quot;); gk_i32pqInit(queue, maxnodes); return queue;} void gk_i32pqInit(gk_i32pq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_i32kvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_i32pqReset(gk_i32pq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_i32kv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_i32pqFree(gk_i32pq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_i32pqDestroy(gk_i32pq_t *queue){ if (queue == ((void*)0)) return; gk_i32pqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_i32pqLength(gk_i32pq_t *queue){ return queue-&gt;nnodes;} int gk_i32pqInsert(gk_i32pq_t *queue, gk_idx_t node, int32_t key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_i32kv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_i32pqDelete(gk_i32pq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; int32_t newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_i32kv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_i32pqUpdate(gk_i32pq_t *queue, gk_idx_t node, int32_t newkey){ gk_idx_t i, j, nnodes; int32_t oldkey; gk_idx_t *locator=queue-&gt;locator; gk_i32kv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_i32pqGetTop(gk_i32pq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_i32kv_t *heap; gk_idx_t vtx, node; int32_t key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_i32pqSeeTopVal(gk_i32pq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} int32_t gk_i32pqSeeTopKey(gk_i32pq_t *queue){ return (queue-&gt;nnodes == 0 ? (2147483647) : queue-&gt;heap[0].key);} int32_t gk_i32pqSeeKey(gk_i32pq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_i32kv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_i32pqCheckHeap(gk_i32pq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_i32kv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_i32pq, <a class="typedef" href="gk_struct.h.html#50" title='gk_i32pq_t' data-type='struct gk_i32pq_t' data-ref="gk_i32pq_t">gk_i32pq_t</a>, <a class="typedef" href="gk_struct.h.html#26" title='gk_i32kv_t' data-type='struct gk_i32kv_t' data-ref="gk_i32kv_t">gk_i32kv_t</a>, <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int32_t" title='int32_t' data-type='__int32_t' data-ref="int32_t">int32_t</a>,  <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#81" title='gk_i32kvmalloc' data-ref="gk_i32kvmalloc">gk_i32kvmalloc</a>, <a class="macro" href="../../../../../include/stdint.h.html#112" title="(2147483647)" data-ref="_M/INT32_MAX">INT32_MAX</a>,  key_gt)</td></tr>
<tr><th id="21">21</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_i64pq_t *gk_i64pqCreate(size_t maxnodes){ gk_i64pq_t *queue; queue = (gk_i64pq_t *)gk_malloc(sizeof(gk_i64pq_t), &quot;gk_pqCreate: queue&quot;); gk_i64pqInit(queue, maxnodes); return queue;} void gk_i64pqInit(gk_i64pq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_i64kvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_i64pqReset(gk_i64pq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_i64kv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_i64pqFree(gk_i64pq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_i64pqDestroy(gk_i64pq_t *queue){ if (queue == ((void*)0)) return; gk_i64pqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_i64pqLength(gk_i64pq_t *queue){ return queue-&gt;nnodes;} int gk_i64pqInsert(gk_i64pq_t *queue, gk_idx_t node, int64_t key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_i64kv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_i64pqDelete(gk_i64pq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; int64_t newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_i64kv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_i64pqUpdate(gk_i64pq_t *queue, gk_idx_t node, int64_t newkey){ gk_idx_t i, j, nnodes; int64_t oldkey; gk_idx_t *locator=queue-&gt;locator; gk_i64kv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_i64pqGetTop(gk_i64pq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_i64kv_t *heap; gk_idx_t vtx, node; int64_t key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_i64pqSeeTopVal(gk_i64pq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} int64_t gk_i64pqSeeTopKey(gk_i64pq_t *queue){ return (queue-&gt;nnodes == 0 ? (9223372036854775807L) : queue-&gt;heap[0].key);} int64_t gk_i64pqSeeKey(gk_i64pq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_i64kv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_i64pqCheckHeap(gk_i64pq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_i64kv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_i64pq, <a class="typedef" href="gk_struct.h.html#51" title='gk_i64pq_t' data-type='struct gk_i64pq_t' data-ref="gk_i64pq_t">gk_i64pq_t</a>, <a class="typedef" href="gk_struct.h.html#27" title='gk_i64kv_t' data-type='struct gk_i64kv_t' data-ref="gk_i64kv_t">gk_i64kv_t</a>, <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int64_t" title='int64_t' data-type='__int64_t' data-ref="int64_t">int64_t</a>,  <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#82" title='gk_i64kvmalloc' data-ref="gk_i64kvmalloc">gk_i64kvmalloc</a>, <a class="macro" href="../../../../../include/stdint.h.html#113" title="(9223372036854775807L)" data-ref="_M/INT64_MAX">INT64_MAX</a>,  key_gt)</td></tr>
<tr><th id="22">22</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_fpq_t *gk_fpqCreate(size_t maxnodes){ gk_fpq_t *queue; queue = (gk_fpq_t *)gk_malloc(sizeof(gk_fpq_t), &quot;gk_pqCreate: queue&quot;); gk_fpqInit(queue, maxnodes); return queue;} void gk_fpqInit(gk_fpq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_fkvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_fpqReset(gk_fpq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_fkv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_fpqFree(gk_fpq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_fpqDestroy(gk_fpq_t *queue){ if (queue == ((void*)0)) return; gk_fpqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_fpqLength(gk_fpq_t *queue){ return queue-&gt;nnodes;} int gk_fpqInsert(gk_fpq_t *queue, gk_idx_t node, float key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_fkv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_fpqDelete(gk_fpq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; float newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_fkv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_fpqUpdate(gk_fpq_t *queue, gk_idx_t node, float newkey){ gk_idx_t i, j, nnodes; float oldkey; gk_idx_t *locator=queue-&gt;locator; gk_fkv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_fpqGetTop(gk_fpq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_fkv_t *heap; gk_idx_t vtx, node; float key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_fpqSeeTopVal(gk_fpq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} float gk_fpqSeeTopKey(gk_fpq_t *queue){ return (queue-&gt;nnodes == 0 ? 3.40282347e+38F : queue-&gt;heap[0].key);} float gk_fpqSeeKey(gk_fpq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_fkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_fpqCheckHeap(gk_fpq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_fkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_fpq,   <a class="typedef" href="gk_struct.h.html#52" title='gk_fpq_t' data-type='struct gk_fpq_t' data-ref="gk_fpq_t">gk_fpq_t</a>,   <a class="typedef" href="gk_struct.h.html#29" title='gk_fkv_t' data-type='struct gk_fkv_t' data-ref="gk_fkv_t">gk_fkv_t</a>,   <em>float</em>,    <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#84" title='gk_fkvmalloc' data-ref="gk_fkvmalloc">gk_fkvmalloc</a>,   <span class="macro" title="3.40282347e+38F" data-ref="_M/FLT_MAX">FLT_MAX</span>,    key_gt)</td></tr>
<tr><th id="23">23</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_dpq_t *gk_dpqCreate(size_t maxnodes){ gk_dpq_t *queue; queue = (gk_dpq_t *)gk_malloc(sizeof(gk_dpq_t), &quot;gk_pqCreate: queue&quot;); gk_dpqInit(queue, maxnodes); return queue;} void gk_dpqInit(gk_dpq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_dkvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_dpqReset(gk_dpq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_dkv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_dpqFree(gk_dpq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_dpqDestroy(gk_dpq_t *queue){ if (queue == ((void*)0)) return; gk_dpqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_dpqLength(gk_dpq_t *queue){ return queue-&gt;nnodes;} int gk_dpqInsert(gk_dpq_t *queue, gk_idx_t node, double key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_dkv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_dpqDelete(gk_dpq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; double newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_dkv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_dpqUpdate(gk_dpq_t *queue, gk_idx_t node, double newkey){ gk_idx_t i, j, nnodes; double oldkey; gk_idx_t *locator=queue-&gt;locator; gk_dkv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_dpqGetTop(gk_dpq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_dkv_t *heap; gk_idx_t vtx, node; double key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_dpqSeeTopVal(gk_dpq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} double gk_dpqSeeTopKey(gk_dpq_t *queue){ return (queue-&gt;nnodes == 0 ? 1.7976931348623157e+308 : queue-&gt;heap[0].key);} double gk_dpqSeeKey(gk_dpq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_dkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_dpqCheckHeap(gk_dpq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_dkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_dpq,   <a class="typedef" href="gk_struct.h.html#53" title='gk_dpq_t' data-type='struct gk_dpq_t' data-ref="gk_dpq_t">gk_dpq_t</a>,   <a class="typedef" href="gk_struct.h.html#30" title='gk_dkv_t' data-type='struct gk_dkv_t' data-ref="gk_dkv_t">gk_dkv_t</a>,   <em>double</em>,   <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#85" title='gk_dkvmalloc' data-ref="gk_dkvmalloc">gk_dkvmalloc</a>,   <span class="macro" title="1.7976931348623157e+308" data-ref="_M/DBL_MAX">DBL_MAX</span>,    key_gt)</td></tr>
<tr><th id="24">24</th><td><a class="macro" href="gk_mkpqueue.h.html#15" title="gk_idxpq_t *gk_idxpqCreate(size_t maxnodes){ gk_idxpq_t *queue; queue = (gk_idxpq_t *)gk_malloc(sizeof(gk_idxpq_t), &quot;gk_pqCreate: queue&quot;); gk_idxpqInit(queue, maxnodes); return queue;} void gk_idxpqInit(gk_idxpq_t *queue, size_t maxnodes){ queue-&gt;nnodes = 0; queue-&gt;maxnodes = maxnodes; queue-&gt;heap = gk_idxkvmalloc(maxnodes, &quot;gk_PQInit: heap&quot;); queue-&gt;locator = gk_idxsmalloc(maxnodes, -1, &quot;gk_PQInit: locator&quot;);} void gk_idxpqReset(gk_idxpq_t *queue){ gk_idx_t i; gk_idx_t *locator=queue-&gt;locator; gk_idxkv_t *heap=queue-&gt;heap; for (i=queue-&gt;nnodes-1; i&gt;=0; i--) locator[heap[i].val] = -1; queue-&gt;nnodes = 0;} void gk_idxpqFree(gk_idxpq_t *queue){ if (queue == ((void*)0)) return; gk_free((void **)&amp;queue-&gt;heap, &amp;queue-&gt;locator, (void **) 0); queue-&gt;maxnodes = 0;} void gk_idxpqDestroy(gk_idxpq_t *queue){ if (queue == ((void*)0)) return; gk_idxpqFree(queue); gk_free((void **)&amp;queue, (void **) 0);} size_t gk_idxpqLength(gk_idxpq_t *queue){ return queue-&gt;nnodes;} int gk_idxpqInsert(gk_idxpq_t *queue, gk_idx_t node, gk_idx_t key){ gk_idx_t i, j; gk_idx_t *locator=queue-&gt;locator; gk_idxkv_t *heap=queue-&gt;heap; ;; ;; i = queue-&gt;nnodes++; while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((key) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } ;; heap[i].key = key; heap[i].val = node; locator[node] = i; ;; return 0;} int gk_idxpqDelete(gk_idxpq_t *queue, gk_idx_t node){ gk_idx_t i, j, nnodes; gk_idx_t newkey, oldkey; gk_idx_t *locator=queue-&gt;locator; gk_idxkv_t *heap=queue-&gt;heap; ;; ;; ;; i = locator[node]; locator[node] = -1; if (--queue-&gt;nnodes &gt; 0 &amp;&amp; heap[queue-&gt;nnodes].val != node) { node = heap[queue-&gt;nnodes].val; newkey = heap[queue-&gt;nnodes].key; oldkey = heap[i].key; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; } ;; return 0;} void gk_idxpqUpdate(gk_idxpq_t *queue, gk_idx_t node, gk_idx_t newkey){ gk_idx_t i, j, nnodes; gk_idx_t oldkey; gk_idx_t *locator=queue-&gt;locator; gk_idxkv_t *heap=queue-&gt;heap; oldkey = heap[locator[node]].key; ;; ;; ;; i = locator[node]; if (((newkey) &gt; (oldkey))) { while (i &gt; 0) { j = (i-1)&gt;&gt;1; if (((newkey) &gt; (heap[j].key))) { heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } else { nnodes = queue-&gt;nnodes; while ((j=(i&lt;&lt;1)+1) &lt; nnodes) { if (((heap[j].key) &gt; (newkey))) { if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; nnodes &amp;&amp; ((heap[j+1].key) &gt; (newkey))) { j++; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } } heap[i].key = newkey; heap[i].val = node; locator[node] = i; ;; return;} gk_idx_t gk_idxpqGetTop(gk_idxpq_t *queue){ gk_idx_t i, j; gk_idx_t *locator; gk_idxkv_t *heap; gk_idx_t vtx, node; gk_idx_t key; ;; if (queue-&gt;nnodes == 0) return -1; queue-&gt;nnodes--; heap = queue-&gt;heap; locator = queue-&gt;locator; vtx = heap[0].val; locator[vtx] = -1; if ((i = queue-&gt;nnodes) &gt; 0) { key = heap[i].key; node = heap[i].val; i = 0; while ((j=2*i+1) &lt; queue-&gt;nnodes) { if (((heap[j].key) &gt; (key))) { if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (heap[j].key))) j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else if (j+1 &lt; queue-&gt;nnodes &amp;&amp; ((heap[j+1].key) &gt; (key))) { j = j+1; heap[i] = heap[j]; locator[heap[i].val] = i; i = j; } else break; } heap[i].key = key; heap[i].val = node; locator[node] = i; } ;; return vtx;} gk_idx_t gk_idxpqSeeTopVal(gk_idxpq_t *queue){ return (queue-&gt;nnodes == 0 ? -1 : queue-&gt;heap[0].val);} gk_idx_t gk_idxpqSeeTopKey(gk_idxpq_t *queue){ return (queue-&gt;nnodes == 0 ? (((18446744073709551615UL)&gt;&gt;1)-2) : queue-&gt;heap[0].key);} gk_idx_t gk_idxpqSeeKey(gk_idxpq_t *queue, gk_idx_t node){ gk_idx_t *locator; gk_idxkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; return heap[locator[node]].key;} int gk_idxpqCheckHeap(gk_idxpq_t *queue){ gk_idx_t i, j; size_t nnodes; gk_idx_t *locator; gk_idxkv_t *heap; heap = queue-&gt;heap; locator = queue-&gt;locator; nnodes = queue-&gt;nnodes; if (nnodes == 0) return 1; ;; for (i=1; i&lt;nnodes; i++) { ;; ;; } for (i=1; i&lt;nnodes; i++) ;; for (j=i=0; i&lt;queue-&gt;maxnodes; i++) { if (locator[i] != -1) j++; } ;; return 1;}" data-ref="_M/GK_MKPQUEUE">GK_MKPQUEUE</a>(gk_idxpq, <a class="typedef" href="gk_struct.h.html#54" title='gk_idxpq_t' data-type='struct gk_idxpq_t' data-ref="gk_idxpq_t">gk_idxpq_t</a>, <a class="typedef" href="gk_struct.h.html#32" title='gk_idxkv_t' data-type='struct gk_idxkv_t' data-ref="gk_idxkv_t">gk_idxkv_t</a>, <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="ref fn" href="gk_proto.h.html#87" title='gk_idxkvmalloc' data-ref="gk_idxkvmalloc">gk_idxkvmalloc</a>, <a class="macro" href="gk_types.h.html#32" title="(((18446744073709551615UL)&gt;&gt;1)-2)" data-ref="_M/GK_IDX_MAX">GK_IDX_MAX</a>, key_gt)</td></tr>
<tr><th id="25">25</th><td><u>#undef <a class="macro" href="#18" data-ref="_M/key_gt">key_gt</a></u></td></tr>
<tr><th id="26">26</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2025-Nov-28</em> from project codebrowser revision <em>4.2.0-ros-3988-g645c5741e</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
