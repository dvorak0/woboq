<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>blas.c source code [codebrowser/gtsam/3rdparty/metis/GKlib/blas.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/gtsam/3rdparty/metis/GKlib/blas.c'; var root_path = '../../../../..'; var data_path = '../../../../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>codebrowser</a>/<a href='../../..'>gtsam</a>/<a href='../..'>3rdparty</a>/<a href='..'>metis</a>/<a href='./'>GKlib</a>/<a href='blas.c.html'>blas.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i class="doc">/*!</i></td></tr>
<tr><th id="2">2</th><td><i class="doc"><span class="command">\file</span> <span class="verb">blas.c</span></i></td></tr>
<tr><th id="3">3</th><td><i class="doc"><span class="command">\brief</span> This file contains GKlib's implementation of BLAS-like routines</i></td></tr>
<tr><th id="4">4</th><td><i class="doc"></i></td></tr>
<tr><th id="5">5</th><td><i class="doc">The BLAS routines that are currently implemented are mostly level-one.</i></td></tr>
<tr><th id="6">6</th><td><i class="doc">They follow a naming convention of the type gk_[type][name], where</i></td></tr>
<tr><th id="7">7</th><td><i class="doc">[type] is one of c, i, f, and d, based on C's four standard scalar</i></td></tr>
<tr><th id="8">8</th><td><i class="doc">datatypes of characters, integers, floats, and doubles.</i></td></tr>
<tr><th id="9">9</th><td><i class="doc"></i></td></tr>
<tr><th id="10">10</th><td><i class="doc">These routines are implemented using a generic macro template,</i></td></tr>
<tr><th id="11">11</th><td><i class="doc">which is used for code generation.</i></td></tr>
<tr><th id="12">12</th><td><i class="doc"></i></td></tr>
<tr><th id="13">13</th><td><i class="doc"><span class="command">\date</span>   Started 9/28/95</i></td></tr>
<tr><th id="14">14</th><td><i class="doc"><span class="command">\author</span> George</i></td></tr>
<tr><th id="15">15</th><td><i class="doc"><span class="command">\version</span><span class="command">\verbatim</span><span class="verb"> $Id: blas.c 11848 2012-04-20 13:47:37Z karypis $ \</span>endverbatim</i></td></tr>
<tr><th id="16">16</th><td><i class="doc">*/</i></td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><u>#include <a href="GKlib.h.html">&lt;GKlib.h&gt;</a></u></td></tr>
<tr><th id="19">19</th><td></td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="23">23</th><td><i class="doc">/*! Use the templates to generate BLAS routines for the scalar data types */</i></td></tr>
<tr><th id="24">24</th><td><i>/*************************************************************************/</i></td></tr>
<tr><th id="25">25</th><td><a class="macro" href="gk_mkblas.h.html#14" title="char *gk_cincset(size_t n, char baseval, char *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} char gk_cmax(size_t n, char *x){ size_t i, max=0; if (n &lt;= 0) return (char) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} char gk_cmin(size_t n, char *x){ size_t i, min=0; if (n &lt;= 0) return (char) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_cargmax(size_t n, char *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_cargmin(size_t n, char *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_cargmax_n(size_t n, char *x, size_t k){ size_t i, max_n; gk_ckv_t *cand; cand = gk_ckvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_ckvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} int gk_csum(size_t n, char *x, size_t incx){ size_t i; int sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} char *gk_cscale(size_t n, char alpha, char *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} int gk_cnorm2(size_t n, char *x, size_t incx){ size_t i; int partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (int)sqrt((double)partial) : (int)0);} int gk_cdot(size_t n, char *x, size_t incx, char *y, size_t incy){ size_t i; int partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} char *gk_caxpy(size_t n, char alpha, char *x, size_t incx, char *y, size_t incy){ size_t i; char *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_c,   <em>char</em>,     <em>int</em>)</td></tr>
<tr><th id="26">26</th><td><a class="macro" href="gk_mkblas.h.html#14" title="int *gk_iincset(size_t n, int baseval, int *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} int gk_imax(size_t n, int *x){ size_t i, max=0; if (n &lt;= 0) return (int) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} int gk_imin(size_t n, int *x){ size_t i, min=0; if (n &lt;= 0) return (int) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_iargmax(size_t n, int *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_iargmin(size_t n, int *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_iargmax_n(size_t n, int *x, size_t k){ size_t i, max_n; gk_ikv_t *cand; cand = gk_ikvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_ikvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} int gk_isum(size_t n, int *x, size_t incx){ size_t i; int sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} int *gk_iscale(size_t n, int alpha, int *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} int gk_inorm2(size_t n, int *x, size_t incx){ size_t i; int partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (int)sqrt((double)partial) : (int)0);} int gk_idot(size_t n, int *x, size_t incx, int *y, size_t incy){ size_t i; int partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} int *gk_iaxpy(size_t n, int alpha, int *x, size_t incx, int *y, size_t incy){ size_t i; int *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_i,   <em>int</em>,      <em>int</em>)</td></tr>
<tr><th id="27">27</th><td><a class="macro" href="gk_mkblas.h.html#14" title="int32_t *gk_i32incset(size_t n, int32_t baseval, int32_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} int32_t gk_i32max(size_t n, int32_t *x){ size_t i, max=0; if (n &lt;= 0) return (int32_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} int32_t gk_i32min(size_t n, int32_t *x){ size_t i, min=0; if (n &lt;= 0) return (int32_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_i32argmax(size_t n, int32_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_i32argmin(size_t n, int32_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_i32argmax_n(size_t n, int32_t *x, size_t k){ size_t i, max_n; gk_i32kv_t *cand; cand = gk_i32kvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_i32kvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} int32_t gk_i32sum(size_t n, int32_t *x, size_t incx){ size_t i; int32_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} int32_t *gk_i32scale(size_t n, int32_t alpha, int32_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} int32_t gk_i32norm2(size_t n, int32_t *x, size_t incx){ size_t i; int32_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (int32_t)sqrt((double)partial) : (int32_t)0);} int32_t gk_i32dot(size_t n, int32_t *x, size_t incx, int32_t *y, size_t incy){ size_t i; int32_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} int32_t *gk_i32axpy(size_t n, int32_t alpha, int32_t *x, size_t incx, int32_t *y, size_t incy){ size_t i; int32_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_i32, <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int32_t" title='int32_t' data-type='__int32_t' data-ref="int32_t">int32_t</a>,  <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int32_t" title='int32_t' data-type='__int32_t' data-ref="int32_t">int32_t</a>)</td></tr>
<tr><th id="28">28</th><td><a class="macro" href="gk_mkblas.h.html#14" title="int64_t *gk_i64incset(size_t n, int64_t baseval, int64_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} int64_t gk_i64max(size_t n, int64_t *x){ size_t i, max=0; if (n &lt;= 0) return (int64_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} int64_t gk_i64min(size_t n, int64_t *x){ size_t i, min=0; if (n &lt;= 0) return (int64_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_i64argmax(size_t n, int64_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_i64argmin(size_t n, int64_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_i64argmax_n(size_t n, int64_t *x, size_t k){ size_t i, max_n; gk_i64kv_t *cand; cand = gk_i64kvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_i64kvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} int64_t gk_i64sum(size_t n, int64_t *x, size_t incx){ size_t i; int64_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} int64_t *gk_i64scale(size_t n, int64_t alpha, int64_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} int64_t gk_i64norm2(size_t n, int64_t *x, size_t incx){ size_t i; int64_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (int64_t)sqrt((double)partial) : (int64_t)0);} int64_t gk_i64dot(size_t n, int64_t *x, size_t incx, int64_t *y, size_t incy){ size_t i; int64_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} int64_t *gk_i64axpy(size_t n, int64_t alpha, int64_t *x, size_t incx, int64_t *y, size_t incy){ size_t i; int64_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_i64, <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int64_t" title='int64_t' data-type='__int64_t' data-ref="int64_t">int64_t</a>,  <a class="typedef" href="../../../../../include/x86_64-linux-gnu/bits/stdint-intn.h.html#int64_t" title='int64_t' data-type='__int64_t' data-ref="int64_t">int64_t</a>)</td></tr>
<tr><th id="29">29</th><td><a class="macro" href="gk_mkblas.h.html#14" title="ssize_t *gk_zincset(size_t n, ssize_t baseval, ssize_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} ssize_t gk_zmax(size_t n, ssize_t *x){ size_t i, max=0; if (n &lt;= 0) return (ssize_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} ssize_t gk_zmin(size_t n, ssize_t *x){ size_t i, min=0; if (n &lt;= 0) return (ssize_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_zargmax(size_t n, ssize_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_zargmin(size_t n, ssize_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_zargmax_n(size_t n, ssize_t *x, size_t k){ size_t i, max_n; gk_zkv_t *cand; cand = gk_zkvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_zkvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} ssize_t gk_zsum(size_t n, ssize_t *x, size_t incx){ size_t i; ssize_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} ssize_t *gk_zscale(size_t n, ssize_t alpha, ssize_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} ssize_t gk_znorm2(size_t n, ssize_t *x, size_t incx){ size_t i; ssize_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (ssize_t)sqrt((double)partial) : (ssize_t)0);} ssize_t gk_zdot(size_t n, ssize_t *x, size_t incx, ssize_t *y, size_t incy){ size_t i; ssize_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} ssize_t *gk_zaxpy(size_t n, ssize_t alpha, ssize_t *x, size_t incx, ssize_t *y, size_t incy){ size_t i; ssize_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_z,   <a class="typedef" href="../../../../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a>,  <a class="typedef" href="../../../../../include/x86_64-linux-gnu/sys/types.h.html#ssize_t" title='ssize_t' data-type='__ssize_t' data-ref="ssize_t">ssize_t</a>)</td></tr>
<tr><th id="30">30</th><td><a class="macro" href="gk_mkblas.h.html#14" title="float *gk_fincset(size_t n, float baseval, float *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} float gk_fmax(size_t n, float *x){ size_t i, max=0; if (n &lt;= 0) return (float) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} float gk_fmin(size_t n, float *x){ size_t i, min=0; if (n &lt;= 0) return (float) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_fargmax(size_t n, float *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_fargmin(size_t n, float *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_fargmax_n(size_t n, float *x, size_t k){ size_t i, max_n; gk_fkv_t *cand; cand = gk_fkvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_fkvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} float gk_fsum(size_t n, float *x, size_t incx){ size_t i; float sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} float *gk_fscale(size_t n, float alpha, float *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} float gk_fnorm2(size_t n, float *x, size_t incx){ size_t i; float partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (float)sqrt((double)partial) : (float)0);} float gk_fdot(size_t n, float *x, size_t incx, float *y, size_t incy){ size_t i; float partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} float *gk_faxpy(size_t n, float alpha, float *x, size_t incx, float *y, size_t incy){ size_t i; float *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_f,   <em>float</em>,    <em>float</em>)</td></tr>
<tr><th id="31">31</th><td><a class="macro" href="gk_mkblas.h.html#14" title="double *gk_dincset(size_t n, double baseval, double *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} double gk_dmax(size_t n, double *x){ size_t i, max=0; if (n &lt;= 0) return (double) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} double gk_dmin(size_t n, double *x){ size_t i, min=0; if (n &lt;= 0) return (double) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_dargmax(size_t n, double *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_dargmin(size_t n, double *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_dargmax_n(size_t n, double *x, size_t k){ size_t i, max_n; gk_dkv_t *cand; cand = gk_dkvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_dkvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} double gk_dsum(size_t n, double *x, size_t incx){ size_t i; double sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} double *gk_dscale(size_t n, double alpha, double *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} double gk_dnorm2(size_t n, double *x, size_t incx){ size_t i; double partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (double)sqrt((double)partial) : (double)0);} double gk_ddot(size_t n, double *x, size_t incx, double *y, size_t incy){ size_t i; double partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} double *gk_daxpy(size_t n, double alpha, double *x, size_t incx, double *y, size_t incy){ size_t i; double *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_d,   <em>double</em>,   <em>double</em>)</td></tr>
<tr><th id="32">32</th><td><a class="macro" href="gk_mkblas.h.html#14" title="gk_idx_t *gk_idxincset(size_t n, gk_idx_t baseval, gk_idx_t *x){ size_t i; for (i=0; i&lt;n; i++) x[i] = baseval+i; return x;} gk_idx_t gk_idxmax(size_t n, gk_idx_t *x){ size_t i, max=0; if (n &lt;= 0) return (gk_idx_t) 0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return x[max];} gk_idx_t gk_idxmin(size_t n, gk_idx_t *x){ size_t i, min=0; if (n &lt;= 0) return (gk_idx_t) 0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return x[min];} size_t gk_idxargmax(size_t n, gk_idx_t *x){ size_t i, max=0; for (i=1; i&lt;n; i++) max = (x[i] &gt; x[max] ? i : max); return max;} size_t gk_idxargmin(size_t n, gk_idx_t *x){ size_t i, min=0; for (i=1; i&lt;n; i++) min = (x[i] &lt; x[min] ? i : min); return min;} size_t gk_idxargmax_n(size_t n, gk_idx_t *x, size_t k){ size_t i, max_n; gk_idxkv_t *cand; cand = gk_idxkvmalloc(n, &quot;GK_ARGMAX_N: cand&quot;); for (i=0; i&lt;n; i++) { cand[i].val = i; cand[i].key = x[i]; } gk_idxkvsortd(n, cand); max_n = cand[k-1].val; gk_free((void *)&amp;cand, (void **) 0); return max_n;} gk_idx_t gk_idxsum(size_t n, gk_idx_t *x, size_t incx){ size_t i; gk_idx_t sum = 0; for (i=0; i&lt;n; i++, x+=incx) sum += (*x); return sum;} gk_idx_t *gk_idxscale(size_t n, gk_idx_t alpha, gk_idx_t *x, size_t incx){ size_t i; for (i=0; i&lt;n; i++, x+=incx) (*x) *= alpha; return x;} gk_idx_t gk_idxnorm2(size_t n, gk_idx_t *x, size_t incx){ size_t i; gk_idx_t partial = 0; for (i=0; i&lt;n; i++, x+=incx) partial += (*x) * (*x); return (partial &gt; 0 ? (gk_idx_t)sqrt((double)partial) : (gk_idx_t)0);} gk_idx_t gk_idxdot(size_t n, gk_idx_t *x, size_t incx, gk_idx_t *y, size_t incy){ size_t i; gk_idx_t partial = 0.0; for (i=0; i&lt;n; i++, x+=incx, y+=incy) partial += (*x) * (*y); return partial;} gk_idx_t *gk_idxaxpy(size_t n, gk_idx_t alpha, gk_idx_t *x, size_t incx, gk_idx_t *y, size_t incy){ size_t i; gk_idx_t *y_in = y; for (i=0; i&lt;n; i++, x+=incx, y+=incy) *y += alpha*(*x); return y_in;}" data-ref="_M/GK_MKBLAS">GK_MKBLAS</a>(gk_idx, <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>, <a class="typedef" href="gk_types.h.html#gk_idx_t" title='gk_idx_t' data-type='ssize_t' data-ref="gk_idx_t">gk_idx_t</a>)</td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td></td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2025-Nov-28</em> from project codebrowser revision <em>4.2.0-ros-3988-g645c5741e</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
