<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>return_type_traits.hpp source code [include/boost/lambda/detail/return_type_traits.hpp] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="boost::lambda::detail::get_result_type,boost::lambda::detail::get_sig,boost::lambda::detail::protect_conversion,boost::lambda::detail::return_type_deduction_failure,boost::lambda::return_type_1,boost::lambda::return_type_1_prot,boost::lambda::return_type_2_comma,boost::lambda::return_type_2_prot,boost::lambda::return_type_N,boost::lambda::return_type_N_prot "/>
<link rel="stylesheet" href="../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/boost/lambda/detail/return_type_traits.hpp'; var root_path = '../../../..'; var data_path = '../../../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>include</a>/<a href='../..'>boost</a>/<a href='..'>lambda</a>/<a href='./'>detail</a>/<a href='return_type_traits.hpp.html'>return_type_traits.hpp</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//  return_type_traits.hpp -- Boost Lambda Library ---------------------------</i></td></tr>
<tr><th id="2">2</th><td><i></i></td></tr>
<tr><th id="3">3</th><td><i>// Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)</i></td></tr>
<tr><th id="4">4</th><td><i>//</i></td></tr>
<tr><th id="5">5</th><td><i>// Distributed under the Boost Software License, Version 1.0. (See</i></td></tr>
<tr><th id="6">6</th><td><i>// accompanying file LICENSE_1_0.txt or copy at</i></td></tr>
<tr><th id="7">7</th><td><i>// <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></td></tr>
<tr><th id="8">8</th><td><i>//</i></td></tr>
<tr><th id="9">9</th><td><i>// For more information, see www.boost.org</i></td></tr>
<tr><th id="10">10</th><td></td></tr>
<tr><th id="11">11</th><td></td></tr>
<tr><th id="12">12</th><td><u>#<span data-ppcond="12">ifndef</span> <span class="macro" data-ref="_M/BOOST_LAMBDA_RETURN_TYPE_TRAITS_HPP">BOOST_LAMBDA_RETURN_TYPE_TRAITS_HPP</span></u></td></tr>
<tr><th id="13">13</th><td><u>#define <dfn class="macro" id="_M/BOOST_LAMBDA_RETURN_TYPE_TRAITS_HPP" data-ref="_M/BOOST_LAMBDA_RETURN_TYPE_TRAITS_HPP">BOOST_LAMBDA_RETURN_TYPE_TRAITS_HPP</dfn></u></td></tr>
<tr><th id="14">14</th><td></td></tr>
<tr><th id="15">15</th><td><u>#include <a href="../../mpl/has_xxx.hpp.html">"boost/mpl/has_xxx.hpp"</a></u></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><u>#include <a href="../../../c++/13/cstddef.html">&lt;cstddef&gt;</a> // needed for the ptrdiff_t</u></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><b>namespace</b> <span class="namespace">boost</span> { </td></tr>
<tr><th id="20">20</th><td><b>namespace</b> <span class="namespace">lambda</span> {</td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td><i>// Much of the type deduction code for standard arithmetic types </i></td></tr>
<tr><th id="23">23</th><td><i>// from Gary Powell</i></td></tr>
<tr><th id="24">24</th><td><i></i></td></tr>
<tr><th id="25">25</th><td><i>  // different arities:</i></td></tr>
<tr><th id="26">26</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A1&gt; <b>struct</b> <a class="type" href="#boost::lambda::return_type_1" title='boost::lambda::return_type_1' data-ref="boost::lambda::return_type_1">return_type_1</a>; <i>// 1-ary actions</i></td></tr>
<tr><th id="27">27</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A1, <b>class</b> A2&gt; <b>struct</b> <dfn class="type" id="boost::lambda::return_type_2" title='boost::lambda::return_type_2' data-ref="boost::lambda::return_type_2">return_type_2</dfn>; <i>// 2-ary</i></td></tr>
<tr><th id="28">28</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> Args&gt; <b>struct</b> <dfn class="type" id="boost::lambda::return_type_N" title='boost::lambda::return_type_N' data-ref="boost::lambda::return_type_N">return_type_N</dfn>; <i>// &gt;3- ary</i></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A1&gt; <b>struct</b> <a class="type" href="#boost::lambda::return_type_1_prot" title='boost::lambda::return_type_1_prot' data-ref="boost::lambda::return_type_1_prot">return_type_1_prot</a>;</td></tr>
<tr><th id="31">31</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A1, <b>class</b> A2&gt; <b>struct</b> <a class="type" href="#boost::lambda::return_type_2_prot" title='boost::lambda::return_type_2_prot' data-ref="boost::lambda::return_type_2_prot">return_type_2_prot</a>; <i>// 2-ary</i></td></tr>
<tr><th id="32">32</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A1&gt; <b>struct</b> <a class="type" href="#boost::lambda::return_type_N_prot" title='boost::lambda::return_type_N_prot' data-ref="boost::lambda::return_type_N_prot">return_type_N_prot</a>; <i>// &gt;3-ary</i></td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><b>namespace</b> <span class="namespace">detail</span> {</td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><b>template</b>&lt;<b>class</b>&gt; <b>class</b> <dfn class="type def" id="boost::lambda::detail::return_type_deduction_failure" title='boost::lambda::detail::return_type_deduction_failure' data-ref="boost::lambda::detail::return_type_deduction_failure">return_type_deduction_failure</dfn> {};</td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td>  <i>// In some cases return type deduction should fail (an invalid lambda </i></td></tr>
<tr><th id="40">40</th><td><i>  // expression). Sometimes the lambda expression can be ok, the return type</i></td></tr>
<tr><th id="41">41</th><td><i>  // just is not deducible (user defined operators). Then return type deduction</i></td></tr>
<tr><th id="42">42</th><td><i>  // should never be entered at all, and the use of ret&lt;&gt; does this.</i></td></tr>
<tr><th id="43">43</th><td><i>  // However, for nullary lambda functors, return type deduction is always</i></td></tr>
<tr><th id="44">44</th><td><i>  // entered, and there seems to be no way around this.</i></td></tr>
<tr><th id="45">45</th><td><i></i></td></tr>
<tr><th id="46">46</th><td><i>  // (the return type is part of the prototype of the non-template</i></td></tr>
<tr><th id="47">47</th><td><i>  // operator()(). The prototype is instantiated, even though the body </i></td></tr>
<tr><th id="48">48</th><td><i>  // is not.) </i></td></tr>
<tr><th id="49">49</th><td><i> </i></td></tr>
<tr><th id="50">50</th><td><i>  // So, in the case the return type deduction should fail, it should not</i></td></tr>
<tr><th id="51">51</th><td><i>  // fail directly, but rather result in a valid but wrong return type,</i></td></tr>
<tr><th id="52">52</th><td><i>  // causing a compile time error only if the function is really called.</i></td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td></td></tr>
<tr><th id="55">55</th><td></td></tr>
<tr><th id="56">56</th><td>} <i>// end detail</i></td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td><i>// return_type_X_prot classes --------------------------------------------</i></td></tr>
<tr><th id="61">61</th><td><i>// These classes are the first layer that gets instantiated from the </i></td></tr>
<tr><th id="62">62</th><td><i>// lambda_functor_base sig templates. It will check whether </i></td></tr>
<tr><th id="63">63</th><td><i>// the action is protectable and one of arguments is "protected" or its</i></td></tr>
<tr><th id="64">64</th><td><i>// evaluation will otherwise result in another lambda functor.</i></td></tr>
<tr><th id="65">65</th><td><i>// If this is a case, the result type will be another lambda functor.</i></td></tr>
<tr><th id="66">66</th><td><i></i></td></tr>
<tr><th id="67">67</th><td><i>// The arguments are always non-reference types, except for comma action</i></td></tr>
<tr><th id="68">68</th><td><i>// where the right argument can be a reference too. This is because it </i></td></tr>
<tr><th id="69">69</th><td><i>// matters (in the builtin case) whether the argument is an lvalue or </i></td></tr>
<tr><th id="70">70</th><td><i>// rvalue: int i; i, 1 -&gt; rvalue; 1, i -&gt; lvalue</i></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_1_prot" title='boost::lambda::return_type_1_prot' data-ref="boost::lambda::return_type_1_prot">return_type_1_prot</dfn> {</td></tr>
<tr><th id="73">73</th><td><b>public</b>:</td></tr>
<tr><th id="74">74</th><td>  <b>typedef</b> <b>typename</b> </td></tr>
<tr><th id="75">75</th><td>    <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF" title='boost::lambda::detail::IF' data-ref="boost::lambda::detail::IF">IF</a>&lt;</td></tr>
<tr><th id="76">76</th><td>      <a class="type" href="actions.hpp.html#boost::lambda::is_protectable" title='boost::lambda::is_protectable' data-ref="boost::lambda::is_protectable">is_protectable</a>&lt;Act&gt;::value &amp;&amp; <a class="type" href="lambda_traits.hpp.html#boost::lambda::is_lambda_functor" title='boost::lambda::is_lambda_functor' data-ref="boost::lambda::is_lambda_functor">is_lambda_functor</a>&lt;A&gt;::value,</td></tr>
<tr><th id="77">77</th><td>      <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor" title='boost::lambda::lambda_functor' data-ref="boost::lambda::lambda_functor">lambda_functor</a>&lt;</td></tr>
<tr><th id="78">78</th><td>        <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor_base" title='boost::lambda::lambda_functor_base' data-ref="boost::lambda::lambda_functor_base">lambda_functor_base</a>&lt; </td></tr>
<tr><th id="79">79</th><td>          Act, </td></tr>
<tr><th id="80">80</th><td>          <a class="type" href="../../fusion/support/tag_of.hpp.html#boost::tuples::tuple" title='boost::tuples::tuple' data-ref="boost::tuples::tuple">tuple</a>&lt;<b>typename</b> <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::remove_reference_and_cv" title='boost::lambda::detail::remove_reference_and_cv' data-ref="boost::lambda::detail::remove_reference_and_cv">remove_reference_and_cv</a>&lt;A&gt;::type&gt;</td></tr>
<tr><th id="81">81</th><td>        &gt;</td></tr>
<tr><th id="82">82</th><td>      &gt;,</td></tr>
<tr><th id="83">83</th><td>      <b>typename</b> <a class="type" href="#boost::lambda::return_type_1" title='boost::lambda::return_type_1' data-ref="boost::lambda::return_type_1">return_type_1</a>&lt;Act, A&gt;::type</td></tr>
<tr><th id="84">84</th><td>    &gt;::RET <dfn class="typedef" id="boost::lambda::return_type_1_prot::type" title='boost::lambda::return_type_1_prot::type' data-type='typename detail::IF&lt;is_protectable&lt;Act&gt;::value &amp;&amp; is_lambda_functor&lt;A&gt;::value, lambda_functor&lt;lambda_functor_base&lt;Act, tuple&lt;typename detail::remove_reference_and_cv&lt;A&gt;::type&gt;&gt;&gt;, typename return_type_1&lt;Act, A&gt;::type&gt;::RET' data-ref="boost::lambda::return_type_1_prot::type">type</dfn>;  </td></tr>
<tr><th id="85">85</th><td>};</td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td>  <i>// take care of the unavoidable instantiation for nullary case</i></td></tr>
<tr><th id="88">88</th><td><b>template</b>&lt;<b>class</b> Act&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_1_prot" title='boost::lambda::return_type_1_prot' data-ref="boost::lambda::return_type_1_prot">return_type_1_prot</dfn>&lt;Act, null_type&gt; {</td></tr>
<tr><th id="89">89</th><td>  <b>typedef</b> null_type <dfn class="typedef" id="boost::lambda::return_type_1_prot{type-parameter-0-0,boost::tuples::null_type}::type" title='boost::lambda::return_type_1_prot&lt;type-parameter-0-0, boost::tuples::null_type&gt;::type' data-type='null_type' data-ref="boost::lambda::return_type_1_prot{type-parameter-0-0,boost::tuples::null_type}::type">type</dfn>;</td></tr>
<tr><th id="90">90</th><td>};</td></tr>
<tr><th id="91">91</th><td> </td></tr>
<tr><th id="92">92</th><td><i>// Unary actions (result from unary operators)</i></td></tr>
<tr><th id="93">93</th><td><i>// do not have a default return type.</i></td></tr>
<tr><th id="94">94</th><td><b>template</b>&lt;<b>class</b> Act, <b>class</b> A&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_1" title='boost::lambda::return_type_1' data-ref="boost::lambda::return_type_1">return_type_1</dfn> { </td></tr>
<tr><th id="95">95</th><td>   <b>typedef</b> <b>typename</b> </td></tr>
<tr><th id="96">96</th><td>     <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::return_type_deduction_failure" title='boost::lambda::detail::return_type_deduction_failure' data-ref="boost::lambda::detail::return_type_deduction_failure">return_type_deduction_failure</a>&lt;return_type_1&gt; <dfn class="typedef" id="boost::lambda::return_type_1::type" title='boost::lambda::return_type_1::type' data-type='typename detail::return_type_deduction_failure&lt;return_type_1&lt;Act, A1&gt;&gt;' data-ref="boost::lambda::return_type_1::type">type</dfn>;</td></tr>
<tr><th id="97">97</th><td>};</td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td></td></tr>
<tr><th id="100">100</th><td><b>namespace</b> <span class="namespace">detail</span> {</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td>  <b>template</b> &lt;<b>class</b> T&gt;</td></tr>
<tr><th id="103">103</th><td>  <b>class</b> <dfn class="type def" id="boost::lambda::detail::protect_conversion" title='boost::lambda::detail::protect_conversion' data-ref="boost::lambda::detail::protect_conversion">protect_conversion</dfn> {</td></tr>
<tr><th id="104">104</th><td>      <b>typedef</b> <b>typename</b> <span class="namespace">boost::</span><a class="type" href="../../type_traits/remove_reference.hpp.html#boost::remove_reference" title='boost::remove_reference' data-ref="boost::remove_reference">remove_reference</a>&lt;T&gt;::type <dfn class="typedef" id="boost::lambda::detail::protect_conversion::non_ref_T" title='boost::lambda::detail::protect_conversion::non_ref_T' data-type='typename boost::remove_reference&lt;T&gt;::type' data-ref="boost::lambda::detail::protect_conversion::non_ref_T">non_ref_T</dfn>;</td></tr>
<tr><th id="105">105</th><td>    <b>public</b>:</td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td>  <i>// add const to rvalues, so that all rvalues are stored as const in </i></td></tr>
<tr><th id="108">108</th><td><i>  // the args tuple</i></td></tr>
<tr><th id="109">109</th><td>    <b>typedef</b> <b>typename</b> <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF_type" title='boost::lambda::detail::IF_type' data-ref="boost::lambda::detail::IF_type">IF_type</a>&lt;</td></tr>
<tr><th id="110">110</th><td>      <span class="namespace">boost::</span><a class="type" href="../../type_traits/is_reference.hpp.html#boost::is_reference" title='boost::is_reference' data-ref="boost::is_reference">is_reference</a>&lt;T&gt;::value &amp;&amp; !<span class="namespace">boost::</span><a class="type" href="../../type_traits/is_const.hpp.html#boost::is_const" title='boost::is_const' data-ref="boost::is_const">is_const</a>&lt;<a class="typedef" href="#boost::lambda::detail::protect_conversion::non_ref_T" title='boost::lambda::detail::protect_conversion::non_ref_T' data-type='typename boost::remove_reference&lt;T&gt;::type' data-ref="boost::lambda::detail::protect_conversion::non_ref_T">non_ref_T</a>&gt;::value,</td></tr>
<tr><th id="111">111</th><td>      <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::identity_mapping" title='boost::lambda::detail::identity_mapping' data-ref="boost::lambda::detail::identity_mapping">identity_mapping</a>&lt;T&gt;,</td></tr>
<tr><th id="112">112</th><td>      <a class="type" href="lambda_traits.hpp.html#boost::lambda::const_copy_argument" title='boost::lambda::const_copy_argument' data-ref="boost::lambda::const_copy_argument">const_copy_argument</a>&lt;<a class="typedef" href="#boost::lambda::detail::protect_conversion::non_ref_T" title='boost::lambda::detail::protect_conversion::non_ref_T' data-type='typename boost::remove_reference&lt;T&gt;::type' data-ref="boost::lambda::detail::protect_conversion::non_ref_T">non_ref_T</a>&gt; <i>// handles funtion and array </i></td></tr>
<tr><th id="113">113</th><td>    &gt;::type <dfn class="typedef" id="boost::lambda::detail::protect_conversion::type" title='boost::lambda::detail::protect_conversion::type' data-type='typename detail::IF_type&lt;boost::is_reference&lt;T&gt;::value &amp;&amp; !boost::is_const&lt;non_ref_T&gt;::value, detail::identity_mapping&lt;T&gt;, const_copy_argument&lt;non_ref_T&gt;&gt;::type' data-ref="boost::lambda::detail::protect_conversion::type">type</dfn>;                      <i>// types correctly</i></td></tr>
<tr><th id="114">114</th><td>  };</td></tr>
<tr><th id="115">115</th><td></td></tr>
<tr><th id="116">116</th><td>} <i>// end detail</i></td></tr>
<tr><th id="117">117</th><td></td></tr>
<tr><th id="118">118</th><td><b>template</b> &lt;<b>class</b> Act, <b>class</b> A, <b>class</b> B&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_2_prot" title='boost::lambda::return_type_2_prot' data-ref="boost::lambda::return_type_2_prot">return_type_2_prot</dfn> {</td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td><i>// experimental feature</i></td></tr>
<tr><th id="121">121</th><td><i>  // We may have a lambda functor as a result type of a subexpression </i></td></tr>
<tr><th id="122">122</th><td><i>  // (if protect) has  been used.</i></td></tr>
<tr><th id="123">123</th><td><i>  // Thus, if one of the parameter types is a lambda functor, the result</i></td></tr>
<tr><th id="124">124</th><td><i>  // is a lambda functor as well. </i></td></tr>
<tr><th id="125">125</th><td><i>  // We need to make a conservative choise here.</i></td></tr>
<tr><th id="126">126</th><td><i>  // The resulting lambda functor stores all const reference arguments as</i></td></tr>
<tr><th id="127">127</th><td><i>  // const copies. References to non-const are stored as such.</i></td></tr>
<tr><th id="128">128</th><td><i>  // So if the source of the argument is a const open argument, a bound</i></td></tr>
<tr><th id="129">129</th><td><i>  // argument stored as a const reference, or a function returning a </i></td></tr>
<tr><th id="130">130</th><td><i>  // const reference, that information is lost. There is no way of </i></td></tr>
<tr><th id="131">131</th><td><i>  // telling apart 'real const references' from just 'LL internal</i></td></tr>
<tr><th id="132">132</th><td><i>  // const references' (or it would be really hard)</i></td></tr>
<tr><th id="133">133</th><td><i></i></td></tr>
<tr><th id="134">134</th><td><i>  // The return type is a subclass of lambda_functor, which has a converting </i></td></tr>
<tr><th id="135">135</th><td><i>  // copy constructor. It can copy any lambda functor, that has the same </i></td></tr>
<tr><th id="136">136</th><td><i>  // action type and code, and a copy compatible argument tuple.</i></td></tr>
<tr><th id="137">137</th><td></td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">boost::</span><a class="type" href="../../type_traits/remove_reference.hpp.html#boost::remove_reference" title='boost::remove_reference' data-ref="boost::remove_reference">remove_reference</a>&lt;A&gt;::type <dfn class="typedef" id="boost::lambda::return_type_2_prot::non_ref_A" title='boost::lambda::return_type_2_prot::non_ref_A' data-type='typename boost::remove_reference&lt;A&gt;::type' data-ref="boost::lambda::return_type_2_prot::non_ref_A">non_ref_A</dfn>;</td></tr>
<tr><th id="140">140</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">boost::</span><a class="type" href="../../type_traits/remove_reference.hpp.html#boost::remove_reference" title='boost::remove_reference' data-ref="boost::remove_reference">remove_reference</a>&lt;B&gt;::type <dfn class="typedef" id="boost::lambda::return_type_2_prot::non_ref_B" title='boost::lambda::return_type_2_prot::non_ref_B' data-type='typename boost::remove_reference&lt;B&gt;::type' data-ref="boost::lambda::return_type_2_prot::non_ref_B">non_ref_B</dfn>;</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td><b>typedef</b> <b>typename</b> </td></tr>
<tr><th id="143">143</th><td>  <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF" title='boost::lambda::detail::IF' data-ref="boost::lambda::detail::IF">IF</a>&lt;</td></tr>
<tr><th id="144">144</th><td>    <a class="type" href="actions.hpp.html#boost::lambda::is_protectable" title='boost::lambda::is_protectable' data-ref="boost::lambda::is_protectable">is_protectable</a>&lt;Act&gt;::value &amp;&amp;</td></tr>
<tr><th id="145">145</th><td>      (<a class="type" href="lambda_traits.hpp.html#boost::lambda::is_lambda_functor" title='boost::lambda::is_lambda_functor' data-ref="boost::lambda::is_lambda_functor">is_lambda_functor</a>&lt;A&gt;::value || <a class="type" href="lambda_traits.hpp.html#boost::lambda::is_lambda_functor" title='boost::lambda::is_lambda_functor' data-ref="boost::lambda::is_lambda_functor">is_lambda_functor</a>&lt;B&gt;::value),</td></tr>
<tr><th id="146">146</th><td>    <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor" title='boost::lambda::lambda_functor' data-ref="boost::lambda::lambda_functor">lambda_functor</a>&lt;</td></tr>
<tr><th id="147">147</th><td>      <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor_base" title='boost::lambda::lambda_functor_base' data-ref="boost::lambda::lambda_functor_base">lambda_functor_base</a>&lt; </td></tr>
<tr><th id="148">148</th><td>        Act, </td></tr>
<tr><th id="149">149</th><td>        <a class="type" href="../../fusion/support/tag_of.hpp.html#boost::tuples::tuple" title='boost::tuples::tuple' data-ref="boost::tuples::tuple">tuple</a>&lt;<b>typename</b> <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::protect_conversion" title='boost::lambda::detail::protect_conversion' data-ref="boost::lambda::detail::protect_conversion">protect_conversion</a>&lt;A&gt;::type, </td></tr>
<tr><th id="150">150</th><td>              <b>typename</b> <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::protect_conversion" title='boost::lambda::detail::protect_conversion' data-ref="boost::lambda::detail::protect_conversion">protect_conversion</a>&lt;B&gt;::type&gt;</td></tr>
<tr><th id="151">151</th><td>      &gt;</td></tr>
<tr><th id="152">152</th><td>    &gt;,</td></tr>
<tr><th id="153">153</th><td>    <b>typename</b> <a class="type" href="#boost::lambda::return_type_2" title='boost::lambda::return_type_2' data-ref="boost::lambda::return_type_2">return_type_2</a>&lt;Act, <a class="typedef" href="#boost::lambda::return_type_2_prot::non_ref_A" title='boost::lambda::return_type_2_prot::non_ref_A' data-type='typename boost::remove_reference&lt;A&gt;::type' data-ref="boost::lambda::return_type_2_prot::non_ref_A">non_ref_A</a>, <a class="typedef" href="#boost::lambda::return_type_2_prot::non_ref_B" title='boost::lambda::return_type_2_prot::non_ref_B' data-type='typename boost::remove_reference&lt;B&gt;::type' data-ref="boost::lambda::return_type_2_prot::non_ref_B">non_ref_B</a>&gt;::type</td></tr>
<tr><th id="154">154</th><td>  &gt;::RET <dfn class="typedef" id="boost::lambda::return_type_2_prot::type" title='boost::lambda::return_type_2_prot::type' data-type='typename detail::IF&lt;is_protectable&lt;Act&gt;::value &amp;&amp; (is_lambda_functor&lt;A&gt;::value || is_lambda_functor&lt;B&gt;::value), lambda_functor&lt;lambda_functor_base&lt;Act, tuple&lt;typename detail::protect_conversion&lt;A&gt;::type, typename detail::protect_conversion&lt;B&gt;::type&gt;&gt;&gt;, typename return_type_2&lt;Act, non_ref_A, non_ref_B&gt;::type&gt;::RET' data-ref="boost::lambda::return_type_2_prot::type">type</dfn>;</td></tr>
<tr><th id="155">155</th><td>};</td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td>  <i>// take care of the unavoidable instantiation for nullary case</i></td></tr>
<tr><th id="158">158</th><td><b>template</b>&lt;<b>class</b> Act&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_2_prot" title='boost::lambda::return_type_2_prot' data-ref="boost::lambda::return_type_2_prot">return_type_2_prot</dfn>&lt;Act, null_type, null_type&gt; {</td></tr>
<tr><th id="159">159</th><td>  <b>typedef</b> null_type <dfn class="typedef" id="boost::lambda::return_type_2_prot{type-parameter-0-0,boost::tuples::null_type,boost::tuples::null_type}::type" title='boost::lambda::return_type_2_prot&lt;type-parameter-0-0, boost::tuples::null_type, boost::tuples::null_type&gt;::type' data-type='null_type' data-ref="boost::lambda::return_type_2_prot{type-parameter-0-0,boost::tuples::null_type,boost::tuples::null_type}::type">type</dfn>;</td></tr>
<tr><th id="160">160</th><td>};</td></tr>
<tr><th id="161">161</th><td>  <i>// take care of the unavoidable instantiation for nullary case</i></td></tr>
<tr><th id="162">162</th><td><b>template</b>&lt;<b>class</b> Act, <b>class</b> Other&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_2_prot" title='boost::lambda::return_type_2_prot' data-ref="boost::lambda::return_type_2_prot">return_type_2_prot</dfn>&lt;Act, Other, null_type&gt; {</td></tr>
<tr><th id="163">163</th><td>  <b>typedef</b> null_type <dfn class="typedef" id="boost::lambda::return_type_2_prot{type-parameter-0-0,type-parameter-0-1,boost::tuples::null_type}::type" title='boost::lambda::return_type_2_prot&lt;type-parameter-0-0, type-parameter-0-1, boost::tuples::null_type&gt;::type' data-type='null_type' data-ref="boost::lambda::return_type_2_prot{type-parameter-0-0,type-parameter-0-1,boost::tuples::null_type}::type">type</dfn>;</td></tr>
<tr><th id="164">164</th><td>};</td></tr>
<tr><th id="165">165</th><td>  <i>// take care of the unavoidable instantiation for nullary case</i></td></tr>
<tr><th id="166">166</th><td><b>template</b>&lt;<b>class</b> Act, <b>class</b> Other&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_2_prot" title='boost::lambda::return_type_2_prot' data-ref="boost::lambda::return_type_2_prot">return_type_2_prot</dfn>&lt;Act, null_type, Other&gt; {</td></tr>
<tr><th id="167">167</th><td>  <b>typedef</b> null_type <dfn class="typedef" id="boost::lambda::return_type_2_prot{type-parameter-0-0,boost::tuples::null_type,type-parameter-0-1}::type" title='boost::lambda::return_type_2_prot&lt;type-parameter-0-0, boost::tuples::null_type, type-parameter-0-1&gt;::type' data-type='null_type' data-ref="boost::lambda::return_type_2_prot{type-parameter-0-0,boost::tuples::null_type,type-parameter-0-1}::type">type</dfn>;</td></tr>
<tr><th id="168">168</th><td>};</td></tr>
<tr><th id="169">169</th><td></td></tr>
<tr><th id="170">170</th><td>  <i>// comma is a special case, as the user defined operator can return</i></td></tr>
<tr><th id="171">171</th><td><i>  // an lvalue (reference) too, hence it must be handled at this level.</i></td></tr>
<tr><th id="172">172</th><td><b>template</b>&lt;<b>class</b> A, <b>class</b> B&gt; </td></tr>
<tr><th id="173">173</th><td><b>struct</b> <dfn class="type def" id="boost::lambda::return_type_2_comma" title='boost::lambda::return_type_2_comma' data-ref="boost::lambda::return_type_2_comma">return_type_2_comma</dfn></td></tr>
<tr><th id="174">174</th><td>{</td></tr>
<tr><th id="175">175</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">boost::</span><a class="type" href="../../type_traits/remove_reference.hpp.html#boost::remove_reference" title='boost::remove_reference' data-ref="boost::remove_reference">remove_reference</a>&lt;A&gt;::type <dfn class="typedef" id="boost::lambda::return_type_2_comma::non_ref_A" title='boost::lambda::return_type_2_comma::non_ref_A' data-type='typename boost::remove_reference&lt;A&gt;::type' data-ref="boost::lambda::return_type_2_comma::non_ref_A">non_ref_A</dfn>;</td></tr>
<tr><th id="176">176</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">boost::</span><a class="type" href="../../type_traits/remove_reference.hpp.html#boost::remove_reference" title='boost::remove_reference' data-ref="boost::remove_reference">remove_reference</a>&lt;B&gt;::type <dfn class="typedef" id="boost::lambda::return_type_2_comma::non_ref_B" title='boost::lambda::return_type_2_comma::non_ref_B' data-type='typename boost::remove_reference&lt;B&gt;::type' data-ref="boost::lambda::return_type_2_comma::non_ref_B">non_ref_B</dfn>;</td></tr>
<tr><th id="177">177</th><td></td></tr>
<tr><th id="178">178</th><td><b>typedef</b> <b>typename</b> </td></tr>
<tr><th id="179">179</th><td>  <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF" title='boost::lambda::detail::IF' data-ref="boost::lambda::detail::IF">IF</a>&lt;</td></tr>
<tr><th id="180">180</th><td>    <a class="type" href="actions.hpp.html#boost::lambda::is_protectable" title='boost::lambda::is_protectable' data-ref="boost::lambda::is_protectable">is_protectable</a>&lt;<a class="type" href="actions.hpp.html#boost::lambda::other_action" title='boost::lambda::other_action' data-ref="boost::lambda::other_action">other_action</a>&lt;<a class="type" href="actions.hpp.html#boost::lambda::comma_action" title='boost::lambda::comma_action' data-ref="boost::lambda::comma_action">comma_action</a>&gt; &gt;::<a class="ref" href="actions.hpp.html#52" title='boost::lambda::is_protectable&lt;boost::lambda::other_action&lt;boost::lambda::comma_action&gt;&gt;::value' data-ref="boost::lambda::is_protectable{boost::lambda::other_action{boost::lambda::comma_action}}::value">value</a> &amp;&amp; <i>// it is protectable</i></td></tr>
<tr><th id="181">181</th><td>    (<a class="type" href="lambda_traits.hpp.html#boost::lambda::is_lambda_functor" title='boost::lambda::is_lambda_functor' data-ref="boost::lambda::is_lambda_functor">is_lambda_functor</a>&lt;A&gt;::value || <a class="type" href="lambda_traits.hpp.html#boost::lambda::is_lambda_functor" title='boost::lambda::is_lambda_functor' data-ref="boost::lambda::is_lambda_functor">is_lambda_functor</a>&lt;B&gt;::value),</td></tr>
<tr><th id="182">182</th><td>    <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor" title='boost::lambda::lambda_functor' data-ref="boost::lambda::lambda_functor">lambda_functor</a>&lt;</td></tr>
<tr><th id="183">183</th><td>      <a class="type" href="lambda_fwd.hpp.html#boost::lambda::lambda_functor_base" title='boost::lambda::lambda_functor_base' data-ref="boost::lambda::lambda_functor_base">lambda_functor_base</a>&lt; </td></tr>
<tr><th id="184">184</th><td>        <a class="type" href="actions.hpp.html#boost::lambda::other_action" title='boost::lambda::other_action' data-ref="boost::lambda::other_action">other_action</a>&lt;<a class="type" href="actions.hpp.html#boost::lambda::comma_action" title='boost::lambda::comma_action' data-ref="boost::lambda::comma_action">comma_action</a>&gt;, </td></tr>
<tr><th id="185">185</th><td>        <a class="type" href="../../fusion/support/tag_of.hpp.html#boost::tuples::tuple" title='boost::tuples::tuple' data-ref="boost::tuples::tuple">tuple</a>&lt;<b>typename</b> <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::protect_conversion" title='boost::lambda::detail::protect_conversion' data-ref="boost::lambda::detail::protect_conversion">protect_conversion</a>&lt;A&gt;::type, </td></tr>
<tr><th id="186">186</th><td>              <b>typename</b> <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::protect_conversion" title='boost::lambda::detail::protect_conversion' data-ref="boost::lambda::detail::protect_conversion">protect_conversion</a>&lt;B&gt;::type&gt;</td></tr>
<tr><th id="187">187</th><td>      &gt;</td></tr>
<tr><th id="188">188</th><td>    &gt;,</td></tr>
<tr><th id="189">189</th><td>    <b>typename</b> </td></tr>
<tr><th id="190">190</th><td>      <a class="type" href="#boost::lambda::return_type_2" title='boost::lambda::return_type_2' data-ref="boost::lambda::return_type_2">return_type_2</a>&lt;<a class="type" href="actions.hpp.html#boost::lambda::other_action" title='boost::lambda::other_action' data-ref="boost::lambda::other_action">other_action</a>&lt;<a class="type" href="actions.hpp.html#boost::lambda::comma_action" title='boost::lambda::comma_action' data-ref="boost::lambda::comma_action">comma_action</a>&gt;, <a class="typedef" href="#boost::lambda::return_type_2_comma::non_ref_A" title='boost::lambda::return_type_2_comma::non_ref_A' data-type='typename boost::remove_reference&lt;A&gt;::type' data-ref="boost::lambda::return_type_2_comma::non_ref_A">non_ref_A</a>, <a class="typedef" href="#boost::lambda::return_type_2_comma::non_ref_B" title='boost::lambda::return_type_2_comma::non_ref_B' data-type='typename boost::remove_reference&lt;B&gt;::type' data-ref="boost::lambda::return_type_2_comma::non_ref_B">non_ref_B</a>&gt;::type</td></tr>
<tr><th id="191">191</th><td>  &gt;::RET <dfn class="typedef" id="boost::lambda::return_type_2_comma::type1" title='boost::lambda::return_type_2_comma::type1' data-type='typename detail::IF&lt;is_protectable&lt;other_action&lt;comma_action&gt;&gt;::value &amp;&amp; (is_lambda_functor&lt;A&gt;::value || is_lambda_functor&lt;B&gt;::value), lambda_functor&lt;lambda_functor_base&lt;other_action&lt;comma_action&gt;, tuple&lt;typename detail::protect_conversion&lt;A&gt;::type, typename detail::protect_conversion&lt;B&gt;::type&gt;&gt;&gt;, typename return_type_2&lt;other_action&lt;comma_action&gt;, non_ref_A, non_ref_B&gt;::type&gt;::RET' data-ref="boost::lambda::return_type_2_comma::type1">type1</dfn>;</td></tr>
<tr><th id="192">192</th><td></td></tr>
<tr><th id="193">193</th><td>   <i>// if no user defined return_type_2 (or plain_return_type_2) specialization</i></td></tr>
<tr><th id="194">194</th><td><i>  // matches, then return the righthand argument</i></td></tr>
<tr><th id="195">195</th><td>  <b>typedef</b> <b>typename</b> </td></tr>
<tr><th id="196">196</th><td>    <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF" title='boost::lambda::detail::IF' data-ref="boost::lambda::detail::IF">IF</a>&lt;</td></tr>
<tr><th id="197">197</th><td>      <span class="namespace">boost::</span><a class="type" href="../../type_traits/is_same.hpp.html#boost::is_same" title='boost::is_same' data-ref="boost::is_same">is_same</a>&lt;<a class="typedef" href="#boost::lambda::return_type_2_comma::type1" title='boost::lambda::return_type_2_comma::type1' data-type='typename detail::IF&lt;is_protectable&lt;other_action&lt;comma_action&gt;&gt;::value &amp;&amp; (is_lambda_functor&lt;A&gt;::value || is_lambda_functor&lt;B&gt;::value), lambda_functor&lt;lambda_functor_base&lt;other_action&lt;comma_action&gt;, tuple&lt;typename detail::protect_conversion&lt;A&gt;::type, typename detail::protect_conversion&lt;B&gt;::type&gt;&gt;&gt;, typename return_type_2&lt;other_action&lt;comma_action&gt;, non_ref_A, non_ref_B&gt;::type&gt;::RET' data-ref="boost::lambda::return_type_2_comma::type1">type1</a>, <span class="namespace">detail::</span><a class="type" href="actions.hpp.html#boost::lambda::detail::unspecified" title='boost::lambda::detail::unspecified' data-ref="boost::lambda::detail::unspecified">unspecified</a>&gt;::value, </td></tr>
<tr><th id="198">198</th><td>      B,</td></tr>
<tr><th id="199">199</th><td>      <a class="typedef" href="#boost::lambda::return_type_2_comma::type1" title='boost::lambda::return_type_2_comma::type1' data-type='typename detail::IF&lt;is_protectable&lt;other_action&lt;comma_action&gt;&gt;::value &amp;&amp; (is_lambda_functor&lt;A&gt;::value || is_lambda_functor&lt;B&gt;::value), lambda_functor&lt;lambda_functor_base&lt;other_action&lt;comma_action&gt;, tuple&lt;typename detail::protect_conversion&lt;A&gt;::type, typename detail::protect_conversion&lt;B&gt;::type&gt;&gt;&gt;, typename return_type_2&lt;other_action&lt;comma_action&gt;, non_ref_A, non_ref_B&gt;::type&gt;::RET' data-ref="boost::lambda::return_type_2_comma::type1">type1</a></td></tr>
<tr><th id="200">200</th><td>    &gt;::RET <dfn class="typedef" id="boost::lambda::return_type_2_comma::type" title='boost::lambda::return_type_2_comma::type' data-type='typename detail::IF&lt;boost::is_same&lt;type1, detail::unspecified&gt;::value, B, type1&gt;::RET' data-ref="boost::lambda::return_type_2_comma::type">type</dfn>;</td></tr>
<tr><th id="201">201</th><td></td></tr>
<tr><th id="202">202</th><td>};</td></tr>
<tr><th id="203">203</th><td></td></tr>
<tr><th id="204">204</th><td></td></tr>
<tr><th id="205">205</th><td>  <i>// currently there are no protectable actions with &gt; 2 args</i></td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><b>template</b>&lt;<b>class</b> Act, <b>class</b> Args&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_N_prot" title='boost::lambda::return_type_N_prot' data-ref="boost::lambda::return_type_N_prot">return_type_N_prot</dfn> {</td></tr>
<tr><th id="208">208</th><td>  <b>typedef</b> <b>typename</b> <a class="type" href="#boost::lambda::return_type_N" title='boost::lambda::return_type_N' data-ref="boost::lambda::return_type_N">return_type_N</a>&lt;Act, Args&gt;::type <dfn class="typedef" id="boost::lambda::return_type_N_prot::type" title='boost::lambda::return_type_N_prot::type' data-type='typename return_type_N&lt;Act, Args&gt;::type' data-ref="boost::lambda::return_type_N_prot::type">type</dfn>;</td></tr>
<tr><th id="209">209</th><td>};</td></tr>
<tr><th id="210">210</th><td></td></tr>
<tr><th id="211">211</th><td>  <i>// take care of the unavoidable instantiation for nullary case</i></td></tr>
<tr><th id="212">212</th><td><b>template</b>&lt;<b>class</b> Act&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::return_type_N_prot" title='boost::lambda::return_type_N_prot' data-ref="boost::lambda::return_type_N_prot">return_type_N_prot</dfn>&lt;Act, null_type&gt; {</td></tr>
<tr><th id="213">213</th><td>  <b>typedef</b> null_type <dfn class="typedef" id="boost::lambda::return_type_N_prot{type-parameter-0-0,boost::tuples::null_type}::type" title='boost::lambda::return_type_N_prot&lt;type-parameter-0-0, boost::tuples::null_type&gt;::type' data-type='null_type' data-ref="boost::lambda::return_type_N_prot{type-parameter-0-0,boost::tuples::null_type}::type">type</dfn>;</td></tr>
<tr><th id="214">214</th><td>};</td></tr>
<tr><th id="215">215</th><td></td></tr>
<tr><th id="216">216</th><td><i>// handle different kind of actions ------------------------</i></td></tr>
<tr><th id="217">217</th><td><i></i></td></tr>
<tr><th id="218">218</th><td><i>  // use the return type given in the bind invocation as bind&lt;Ret&gt;(...)</i></td></tr>
<tr><th id="219">219</th><td><b>template</b>&lt;<em>int</em> I, <b>class</b> Args, <b>class</b> Ret&gt; </td></tr>
<tr><th id="220">220</th><td><b>struct</b> <dfn class="type def" id="boost::lambda::return_type_N" title='boost::lambda::return_type_N' data-ref="boost::lambda::return_type_N">return_type_N</dfn>&lt;<a class="type" href="actions.hpp.html#boost::lambda::function_action" title='boost::lambda::function_action' data-ref="boost::lambda::function_action">function_action</a>&lt;<a class="tu ref" href="#boost::lambda::return_type_N{function_action{I,type-parameter-0-2},type-parameter-0-1}::I" title='boost::lambda::return_type_N&lt;function_action&lt;I, type-parameter-0-2&gt;, type-parameter-0-1&gt;::I' data-ref="boost::lambda::return_type_N{function_action{I,type-parameter-0-2},type-parameter-0-1}::I">I</a>, Ret&gt;, Args&gt; { </td></tr>
<tr><th id="221">221</th><td>  <b>typedef</b> Ret <dfn class="typedef" id="boost::lambda::return_type_N{function_action{I,type-parameter-0-2},type-parameter-0-1}::type" title='boost::lambda::return_type_N&lt;function_action&lt;I, type-parameter-0-2&gt;, type-parameter-0-1&gt;::type' data-type='Ret' data-ref="boost::lambda::return_type_N{function_action{I,type-parameter-0-2},type-parameter-0-1}::type">type</dfn>;</td></tr>
<tr><th id="222">222</th><td>};</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><i>// ::result_type support</i></td></tr>
<tr><th id="225">225</th><td></td></tr>
<tr><th id="226">226</th><td><b>namespace</b> <span class="namespace">detail</span></td></tr>
<tr><th id="227">227</th><td>{</td></tr>
<tr><th id="228">228</th><td></td></tr>
<tr><th id="229">229</th><td><a class="macro" href="../../mpl/has_xxx.hpp.html#278" title="template&lt; typename T, typename fallback_ = boost::mpl::bool_&lt;false&gt; &gt; struct has_result_type { struct gcc_3_2_wknd { template&lt; typename U &gt; static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper&lt;U&gt; const volatile* , boost::mpl::aux::type_wrapper&lt;typename U::result_type&gt;* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper&lt;T&gt; t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast&lt;t_*&gt;(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_&lt;value&gt; type; };" data-ref="_M/BOOST_MPL_HAS_XXX_TRAIT_DEF">BOOST_MPL_HAS_XXX_TRAIT_DEF</a>(result_type)</td></tr>
<tr><th id="230">230</th><td></td></tr>
<tr><th id="231">231</th><td><b>template</b>&lt;<b>class</b> F&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::detail::get_result_type" title='boost::lambda::detail::get_result_type' data-ref="boost::lambda::detail::get_result_type">get_result_type</dfn></td></tr>
<tr><th id="232">232</th><td>{</td></tr>
<tr><th id="233">233</th><td>  <b>typedef</b> <b>typename</b> F::result_type <dfn class="typedef" id="boost::lambda::detail::get_result_type::type" title='boost::lambda::detail::get_result_type::type' data-type='typename F::result_type' data-ref="boost::lambda::detail::get_result_type::type">type</dfn>;</td></tr>
<tr><th id="234">234</th><td>};</td></tr>
<tr><th id="235">235</th><td></td></tr>
<tr><th id="236">236</th><td><b>template</b>&lt;<b>class</b> F, <b>class</b> A&gt; <b>struct</b> <dfn class="type def" id="boost::lambda::detail::get_sig" title='boost::lambda::detail::get_sig' data-ref="boost::lambda::detail::get_sig">get_sig</dfn></td></tr>
<tr><th id="237">237</th><td>{</td></tr>
<tr><th id="238">238</th><td>  <b>typedef</b> <b>typename</b> <a class="type" href="lambda_fwd.hpp.html#boost::lambda::function_adaptor" title='boost::lambda::function_adaptor' data-ref="boost::lambda::function_adaptor">function_adaptor</a>&lt;F&gt;::<b>template</b> sig&lt;A&gt;::type <dfn class="typedef" id="boost::lambda::detail::get_sig::type" title='boost::lambda::detail::get_sig::type' data-type='typename function_adaptor&lt;F&gt;::template sig&lt;A&gt;::type' data-ref="boost::lambda::detail::get_sig::type">type</dfn>;</td></tr>
<tr><th id="239">239</th><td>};</td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td>} <i>// namespace detail</i></td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td>  <i>// Ret is detail::unspecified, so try to deduce return type</i></td></tr>
<tr><th id="244">244</th><td><b>template</b>&lt;<em>int</em> I, <b>class</b> Args&gt; </td></tr>
<tr><th id="245">245</th><td><b>struct</b> <dfn class="type def" id="boost::lambda::return_type_N" title='boost::lambda::return_type_N' data-ref="boost::lambda::return_type_N">return_type_N</dfn>&lt;<a class="type" href="actions.hpp.html#boost::lambda::function_action" title='boost::lambda::function_action' data-ref="boost::lambda::function_action">function_action</a>&lt;<a class="tu ref" href="#boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::I" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::I' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::I">I</a>, <span class="namespace">detail::</span><a class="type" href="actions.hpp.html#boost::lambda::detail::unspecified" title='boost::lambda::detail::unspecified' data-ref="boost::lambda::detail::unspecified">unspecified</a>&gt;, Args &gt; { </td></tr>
<tr><th id="246">246</th><td></td></tr>
<tr><th id="247">247</th><td>  <i>// in the case of function action, the first element in Args is </i></td></tr>
<tr><th id="248">248</th><td><i>  // some type of function</i></td></tr>
<tr><th id="249">249</th><td>  <b>typedef</b> <b>typename</b> Args::head_type <dfn class="typedef" id="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::Func' data-type='typename Args::head_type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::Func">Func</dfn>;</td></tr>
<tr><th id="250">250</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::remove_reference_and_cv" title='boost::lambda::detail::remove_reference_and_cv' data-ref="boost::lambda::detail::remove_reference_and_cv">remove_reference_and_cv</a>&lt;<a class="typedef" href="#boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::Func' data-type='typename Args::head_type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::Func">Func</a>&gt;::type <dfn class="typedef" id="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::plain_Func' data-type='typename detail::remove_reference_and_cv&lt;Func&gt;::type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func">plain_Func</dfn>;</td></tr>
<tr><th id="251">251</th><td></td></tr>
<tr><th id="252">252</th><td><b>public</b>: </td></tr>
<tr><th id="253">253</th><td>  <i>// pass the function to function_adaptor, and get the return type from </i></td></tr>
<tr><th id="254">254</th><td><i>  // that</i></td></tr>
<tr><th id="255">255</th><td>  <b>typedef</b> <b>typename</b> <span class="namespace">detail::</span><a class="type" href="lambda_traits.hpp.html#boost::lambda::detail::IF" title='boost::lambda::detail::IF' data-ref="boost::lambda::detail::IF">IF</a>&lt;</td></tr>
<tr><th id="256">256</th><td>    <span class="namespace">detail::</span><a class="type" href="#229" title='boost::lambda::detail::has_result_type' data-ref="boost::lambda::detail::has_result_type">has_result_type</a>&lt;<a class="typedef" href="#boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::plain_Func' data-type='typename detail::remove_reference_and_cv&lt;Func&gt;::type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func">plain_Func</a>&gt;::value,</td></tr>
<tr><th id="257">257</th><td>    <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::get_result_type" title='boost::lambda::detail::get_result_type' data-ref="boost::lambda::detail::get_result_type">get_result_type</a>&lt;<a class="typedef" href="#boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::plain_Func' data-type='typename detail::remove_reference_and_cv&lt;Func&gt;::type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func">plain_Func</a>&gt;,</td></tr>
<tr><th id="258">258</th><td>    <span class="namespace">detail::</span><a class="type" href="#boost::lambda::detail::get_sig" title='boost::lambda::detail::get_sig' data-ref="boost::lambda::detail::get_sig">get_sig</a>&lt;<a class="typedef" href="#boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::plain_Func' data-type='typename detail::remove_reference_and_cv&lt;Func&gt;::type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::plain_Func">plain_Func</a>, Args&gt;</td></tr>
<tr><th id="259">259</th><td>  &gt;::RET::type <dfn class="typedef" id="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::type" title='boost::lambda::return_type_N&lt;function_action&lt;I, boost::lambda::detail::unspecified&gt;, type-parameter-0-1&gt;::type' data-type='typename detail::IF&lt;detail::has_result_type&lt;plain_Func&gt;::value, detail::get_result_type&lt;plain_Func&gt;, detail::get_sig&lt;plain_Func, Args&gt;&gt;::RET::type' data-ref="boost::lambda::return_type_N{function_action{I,boost::lambda::detail::unspecified},type-parameter-0-1}::type">type</dfn>;</td></tr>
<tr><th id="260">260</th><td>};</td></tr>
<tr><th id="261">261</th><td></td></tr>
<tr><th id="262">262</th><td></td></tr>
<tr><th id="263">263</th><td>} <i>// namespace lambda</i></td></tr>
<tr><th id="264">264</th><td>} <i>// namespace boost</i></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><u>#<span data-ppcond="12">endif</span></u></td></tr>
<tr><th id="267">267</th><td></td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td></td></tr>
<tr><th id="270">270</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../codebrowser/gtsam_unstable/linear/QPSParser.cpp.html'>codebrowser/gtsam_unstable/linear/QPSParser.cpp</a><br/>Generated on <em>2025-Nov-28</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
