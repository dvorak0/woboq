<dec f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.h' l='142' type='std::shared_ptr&lt;HessianFactor&gt; gtsam::NonlinearFactorGraph::linearizeToHessianFactor(const Values &amp; values, const Dampen &amp; dampen = nullptr) const'/>
<doc f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.h' l='135'>/**
     * Instead of producing a GaussianFactorGraph, pre-allocate and linearize directly
     * into a HessianFactor. Avoids the many mallocs and pointer indirection in constructing
     * a new graph, and hence useful in case a dense solve is appropriate for your problem.
     * An optional lambda function can be used to apply damping on the filled Hessian.
     * No parallelism is exploited, because all the factors write in the same memory.
     */</doc>
<def f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='344' ll='350' type='HessianFactor::shared_ptr gtsam::NonlinearFactorGraph::linearizeToHessianFactor(const Values &amp; values, const Dampen &amp; dampen = nullptr) const'/>
<use f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='356' u='c' c='_ZNK5gtsam20NonlinearFactorGraph14updateCholeskyERKNS_6ValuesERKSt8functionIFvRKSt10shared_ptrINS_13HessianFactorEEEE'/>
<doc f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='343'>/* ************************************************************************* */</doc>
