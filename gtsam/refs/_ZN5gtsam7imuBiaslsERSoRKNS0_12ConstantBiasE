<dec f='codebrowser/gtsam/navigation/ImuBias.h' l='97' type='std::ostream &amp; gtsam::imuBias::operator&lt;&lt;(std::ostream &amp; os, const ConstantBias &amp; bias)'/>
<doc f='codebrowser/gtsam/navigation/ImuBias.h' l='93'>/// @name Testable
  /// @{

  /// ostream operator</doc>
<use f='codebrowser/examples/IMUKittiExampleGPS.cpp' l='375' u='c' c='main'/>
<def f='codebrowser/gtsam/navigation/ImuBias.cpp' l='68' ll='72' type='std::ostream &amp; gtsam::imuBias::operator&lt;&lt;(std::ostream &amp; os, const ConstantBias &amp; bias)'/>
<use f='codebrowser/gtsam/navigation/ImuBias.cpp' l='76' u='c' c='_ZNK5gtsam7imuBias12ConstantBias5printERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<doc f='codebrowser/gtsam/navigation/ImuBias.cpp' l='28'>/*
 * NOTES:
 * - Earth-rate correction:
 *     + Currently the user should supply R_ECEF_to_G, which is the rotation from ECEF to Local-Level system (NED or ENU as defined by the user).
 *     + R_ECEF_to_G can be calculated by approximated values of latitude and longitude of the system.
 *     + A relatively small distance is traveled w.r.t. to initial pose is assumed, since R_ECEF_to_G is constant.
 *        Otherwise, R_ECEF_to_G should be updated each time using the current lat-lon.
 *
 *  - Currently, an empty constructed is not enabled so that the user is forced to specify R_ECEF_to_G.
 */
//    // H1: Jacobian w.r.t. IMUBias
//    // H2: Jacobian w.r.t. pose
//    Vector CorrectGyroWithEarthRotRate(Vector measurement, const Pose3&amp; pose, const Vector&amp; w_earth_rate_G,
//        Matrix* H1=nullptr, Matrix* H2=nullptr) const {
//
//      Matrix R_G_to_I( pose.rotation().matrix().transpose() );
//      Vector w_earth_rate_I = R_G_to_I * w_earth_rate_G;
//
//      if (H1){
//        Matrix zeros3_3(zeros(3,3));
//        Matrix m_eye3(-eye(3));
//
//        *H1 = collect(2, &amp;zeros3_3, &amp;m_eye3);
//      }
//
//      if (H2){
//        Matrix zeros3_3(zeros(3,3));
//        Matrix H = -skewSymmetric(w_earth_rate_I);
//
//        *H2 = collect(2, &amp;H, &amp;zeros3_3);
//      }
//
//      //TODO: Make sure H2 is correct.
//
//      return measurement - biasGyro_ - w_earth_rate_I;
//
////      Vector bias_gyro_temp((Vector(3) &lt;&lt; -bias_gyro_(0), bias_gyro_(1), bias_gyro_(2)));
////      return measurement - bias_gyro_temp - R_G_to_I * w_earth_rate_G;
//    }
/// ostream operator</doc>
