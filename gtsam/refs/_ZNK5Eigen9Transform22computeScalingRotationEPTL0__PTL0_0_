<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='607' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1126' ll='1143' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1115'>/** decomposes the linear part of the transformation as a product scaling x rotation, the scaling being
  * not necessarily positive.
  *
  * If either pointer is zero, the corresponding computation is skipped.
  *
  *
  *
  * \svd_module
  *
  * \sa computeRotationScaling(), rotation(), class SVD
  */</doc>
