<dec f='codebrowser/gtsam_unstable/linear/ActiveSetSolver.h' l='116' type='std::tuple&lt;double, int&gt; gtsam::ActiveSetSolver::computeStepSize(const InequalityFactorGraph &amp; workingSet, const VectorValues &amp; xk, const VectorValues &amp; p, const double &amp; maxAlpha) const'/>
<def f='codebrowser/gtsam_unstable/linear/ActiveSetSolver-inl.h' l='48' ll='78' macro='1' type='std::tuple&lt;double, int&gt; gtsam::ActiveSetSolver::computeStepSize(const InequalityFactorGraph &amp; workingSet, const VectorValues &amp; xk, const VectorValues &amp; p, const double &amp; maxAlpha) const'/>
<use f='codebrowser/gtsam_unstable/linear/ActiveSetSolver-inl.h' l='224' u='c' c='_ZNK5gtsam15ActiveSetSolver7iterateERKNS0_5StateE'/>
<doc f='codebrowser/gtsam_unstable/linear/ActiveSetSolver.h' l='101'>/**
   * Compute minimum step size alpha to move from the current point @p xk to the
   * next feasible point along a direction @p p:  x&apos; = xk + alpha*p,
   * where alpha \f$\in\f$ [0,maxAlpha].
   *
   * For QP, maxAlpha = 1. For LP: maxAlpha = Inf.
   *
   * @return a tuple of (minAlpha, closestFactorIndex) where closestFactorIndex
   * is the closest inactive inequality constraint that blocks xk to move
   * further and that has the minimum alpha, or (-1, maxAlpha) if there is no
   * such inactive blocking constraint.
   *
   * If there is a blocking constraint, the closest one will be added to the
   * working set and become active in the next iteration.
   */</doc>
