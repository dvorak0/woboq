<inh f='codebrowser/gtsam/nonlinear/NonlinearFactor.h' l='434' c='gtsam::NoiseModelFactorN'/>
<def f='codebrowser/gtsam/slam/RotateFactor.h' l='23' ll='63'/>
<use f='codebrowser/gtsam/slam/RotateFactor.h' l='28'/>
<use f='codebrowser/gtsam/slam/tests/testRotateFactor.cpp' l='61' c='_ZN20RotateFactortestTest3runER10TestResult'/>
<use f='codebrowser/gtsam/slam/tests/testRotateFactor.cpp' l='93' c='_ZN28RotateFactorminimizationTest3runER10TestResult'/>
<use f='codebrowser/gtsam/slam/tests/testRotateFactor.cpp' l='94' c='_ZN28RotateFactorminimizationTest3runER10TestResult'/>
<use f='codebrowser/gtsam/slam/tests/testRotateFactor.cpp' l='95' c='_ZN28RotateFactorminimizationTest3runER10TestResult'/>
<size>96</size>
<doc f='codebrowser/gtsam/slam/RotateFactor.h' l='15'>/**
 * Factor on unknown rotation iRC that relates two incremental rotations
 *   c1Rc2 = iRc&apos; * i1Ri2 * iRc
 * Which we can write (see doc/math.lyx)
 *   e^[z] = iRc&apos; * e^[p] * iRc = e^([iRc&apos;*p])
 * with z and p measured and predicted angular velocities, and hence
 *   p = iRc * z
 */</doc>
<mbr r='gtsam::RotateFactor::p_' o='384' t='Point3'/>
<mbr r='gtsam::RotateFactor::z_' o='576' t='Point3'/>
<fun r='_ZN5gtsam12RotateFactorC1EmRKNS_4Rot3ES3_RKSt10shared_ptrINS_10noiseModel4BaseEE'/>
<fun r='_ZNK5gtsam12RotateFactor5cloneEv'/>
<fun r='_ZNK5gtsam12RotateFactor5printERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt8functionIFS6_mEE'/>
<fun r='_ZNK5gtsam12RotateFactor13evaluateErrorERKNS_4Rot3EPN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEE'/>
