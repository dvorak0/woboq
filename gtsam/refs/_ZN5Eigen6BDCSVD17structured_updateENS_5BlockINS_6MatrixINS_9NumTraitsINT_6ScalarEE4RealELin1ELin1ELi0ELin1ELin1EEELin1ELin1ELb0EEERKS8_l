<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='191' type='void Eigen::BDCSVD::structured_update(Block&lt;MatrixXr, Dynamic, Dynamic&gt; A, const MatrixXr &amp; B, Index n1)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='359' ll='398' type='void Eigen::BDCSVD::structured_update(Block&lt;MatrixXr, Dynamic, Dynamic&gt; A, const MatrixXr &amp; B, Index n1)'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='566' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='574' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='351'>/** \internal
  * Performs A = A * B exploiting the special structure of the matrix A. Splitting A as:
  *  A = [A1]
  *      [A2]
  * such that A1.rows()==n1, then we assume that at least half of the columns of A1 and A2 are zeros.
  * We can thus pack them prior to the the matrix product. However, this is only worth the effort if the matrix is large
  * enough.
  */</doc>
