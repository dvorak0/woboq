<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/MatrixBase.h' l='252' type='const SparseView&lt;Derived&gt; Eigen::MatrixBase::sparseView(const Scalar &amp; m_reference = Scalar(0), const typename NumTraits&lt;Scalar&gt;::Real &amp; m_epsilon = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SparseCore/SparseView.h' l='225' ll='230' type='const SparseView&lt;Derived&gt; Eigen::MatrixBase::sparseView(const Scalar &amp; reference = Scalar(0), const typename NumTraits&lt;Scalar&gt;::Real &amp; epsilon = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SparseCore/SparseView.h' l='208'>/** \ingroup SparseCore_Module
  *
  * \returns a sparse expression of the dense expression \c *this with values smaller than
  * \a reference * \a epsilon removed.
  *
  * This method is typically used when prototyping to convert a quickly assembled dense Matrix \c D to a SparseMatrix \c S:
  * \code
  * MatrixXd D(n,m);
  * SparseMatrix&lt;double&gt; S;
  * S = D.sparseView();             // suppress numerical zeros (exact)
  * S = D.sparseView(reference);
  * S = D.sparseView(reference,epsilon);
  * \endcode
  * where \a reference is a meaningful non zero reference value,
  * and \a epsilon is a tolerance factor defaulting to NumTraits&lt;Scalar&gt;::dummy_precision().
  *
  * \sa SparseMatrixBase::pruned(), class SparseView */</doc>
<use f='codebrowser/gtsam/sfm/ShonanAveraging.cpp' l='550' u='c' c='_ZN5gtsamL22PowerMinimumEigenValueERKN5Eigen12SparseMatrixIdLi0EiEERKNS0_6MatrixIdLin1ELin1ELi0ELin1ELin1EEERdPNS5_IdLin1ELi1ELi0ELin1ELi1EEEPmmd'/>
