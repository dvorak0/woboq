<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/MatrixBase.h' l='371' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='55' c='_ZN5Eigen8internal22qr_preconditioner_implIT_XT0_EXT1_ELb0EE8allocateERKNS_9JacobiSVDIS2_XT0_EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='56' c='_ZN5Eigen8internal22qr_preconditioner_implIT_XT0_EXT1_ELb0EE3runERNS_9JacobiSVDIS2_XT0_EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='76' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li3EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='86' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li3EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='122' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li3EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='133' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li3EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='159' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li2EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='170' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li2EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='212' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li2EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='224' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li2EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='257' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li1EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='268' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li1EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='309' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li1EEE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='321' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li1EEERKS2_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='356'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='364'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='427'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='488' ll='612'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='489'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='615' c='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='666' c='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='665' c='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='804' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='807' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='259' c='_ZN5Eigen6BDCSVD7computeERKT_j'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='430' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Quaternion.h' l='657' c='_ZN5Eigen14QuaternionBase17setFromTwoVectorsERKNS_10MatrixBaseITL0__EERKNS1_ITL0_0_EE'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1101' c='_ZNK5Eigen9Transform22computeRotationScalingEPTL0__PTL0_0_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1131' c='_ZNK5Eigen9Transform22computeScalingRotationEPTL0__PTL0_0_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Hyperplane.h' l='109' c='_ZN5Eigen10Hyperplane7ThroughERKNS_6MatrixIT_LNS0_Ut_E0ELi1EXorLNS_14StorageOptionsE0EquaaeqLS3_0ELi1EneLi1ELi1ELS4_1EquaaeqLi1ELi1EneLS3_0ELi1ELS4_0E11015933'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Umeyama.h' l='131' c='_ZN5Eigen7umeyamaERKNS_10MatrixBaseIT_EERKNS0_IT0_EEb'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='435'>/** \ingroup SVD_Module
  *
  *
  * \class JacobiSVD
  *
  * \brief Two-sided Jacobi SVD decomposition of a rectangular matrix
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the SVD decomposition
  * \tparam QRPreconditioner this optional parameter allows to specify the type of QR decomposition that will be used internally
  *                        for the R-SVD step for non-square matrices. See discussion of possible values below.
  *
  * SVD decomposition consists in decomposing any n-by-p matrix \a A as a product
  *   \f[ A = U S V^* \f]
  * where \a U is a n-by-n unitary, \a V is a p-by-p unitary, and \a S is a n-by-p real positive matrix which is zero outside of its main diagonal;
  * the diagonal entries of S are known as the \em singular \em values of \a A and the columns of \a U and \a V are known as the left
  * and right \em singular \em vectors of \a A respectively.
  *
  * Singular values are always sorted in decreasing order.
  *
  * This JacobiSVD decomposition computes only the singular values by default. If you want \a U or \a V, you need to ask for them explicitly.
  *
  * You can ask for only \em thin \a U or \a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \a m be the
  * smaller value among \a n and \a p, there are only \a m singular vectors; the remaining columns of \a U and \a V do not correspond to actual
  * singular vectors. Asking for \em thin \a U or \a V means asking for only their \a m first columns to be formed. So \a U is then a n-by-m matrix,
  * and \a V is then a p-by-m matrix. Notice that thin \a U and \a V are all you need for (least squares) solving.
  *
  * Here&apos;s an example demonstrating basic usage:
  * \include JacobiSVD_basic.cpp
  * Output: \verbinclude JacobiSVD_basic.out
  *
  * This JacobiSVD class is a two-sided Jacobi R-SVD decomposition, ensuring optimal reliability and accuracy. The downside is that it&apos;s slower than
  * bidiagonalizing SVD algorithms for large square matrices; however its complexity is still \f$ O(n^2p) \f$ where \a n is the smaller dimension and
  * \a p is the greater dimension, meaning that it is still of the same order of complexity as the faster bidiagonalizing R-SVD algorithms.
  * In particular, like any R-SVD, it takes advantage of non-squareness in that its complexity is only linear in the greater dimension.
  *
  * If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to
  * terminate in finite (and reasonable) time.
  *
  * The possible values for QRPreconditioner are:
  * \li ColPivHouseholderQRPreconditioner is the default. In practice it&apos;s very safe. It uses column-pivoting QR.
  * \li FullPivHouseholderQRPreconditioner, is the safest and slowest. It uses full-pivoting QR.
  *     Contrary to other QRs, it doesn&apos;t allow computing thin unitaries.
  * \li HouseholderQRPreconditioner is the fastest, and less safe and accurate than the pivoting variants. It uses non-pivoting QR.
  *     This is very similar in safety and accuracy to the bidiagonalization process used by bidiagonalizing SVD algorithms (since bidiagonalization
  *     is inherently non-pivoting). However the resulting SVD is still more reliable than bidiagonalizing SVDs because the Jacobi-based iterarive
  *     process is more reliable than the optimized bidiagonal SVD iterations.
  * \li NoQRPreconditioner allows not to use a QR preconditioner at all. This is useful if you know that you will only be computing
  *     JacobiSVD decompositions of square matrices. Non-square matrices require a QR preconditioner. Using this option will result in
  *     faster compilation and smaller executable code. It won&apos;t significantly speed up computation, since JacobiSVD is always checking
  *     if QR preconditioning is needed before applying it anyway.
  *
  * \sa MatrixBase::jacobiSvd()
  */</doc>
<fun r='_ZN5Eigen9JacobiSVDC1Ev'/>
<fun r='_ZN5Eigen9JacobiSVDC1Ellj'/>
<fun r='_ZN5Eigen9JacobiSVDC1ERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<mbr r='Eigen::JacobiSVD::m_workMatrix' t='WorkMatrixType'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morecols' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows&gt;'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morerows' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols&gt;'/>
<mbr r='Eigen::JacobiSVD::m_scaledMatrix' t='MatrixType'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='codebrowser/gtsam/slam/SmartFactorBase.h' l='344' c='_ZNK5gtsam15SmartFactorBase19computeJacobiansSVDERSt6vectorIN5Eigen6MatrixIdL_ZNS0_4ZDimEEL_ZNS0_3DimEEXorLNS2_14StorageOptionsE0EquaaeqL_ZNS0_4ZDimEE6183281'/>
<use f='codebrowser/gtsam/base/Matrix.cpp' l='549' c='_ZN5gtsam3svdERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEERS2_RNS1_IdLin1ELi1ELi0ELin1ELi1EEES5_'/>
<use f='codebrowser/gtsam/base/Matrix.cpp' l='562' c='_ZN5gtsam3DLTERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEEd'/>
<use f='codebrowser/gtsam/basis/Chebyshev2.cpp' l='232' c='_ZN5gtsam10Chebyshev217IntegrationMatrixEm'/>
<use f='codebrowser/gtsam/geometry/FundamentalMatrix.cpp' l='38' c='_ZN5gtsam17FundamentalMatrixC1ERKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEE'/>
<use f='codebrowser/gtsam/geometry/Rot2.cpp' l='149' c='_ZN5gtsam4Rot29ClosestToERKN5Eigen6MatrixIdLi2ELi2ELi0ELi2ELi2EEE'/>
<use f='codebrowser/gtsam/geometry/SO3.cpp' l='234' c='_ZN5gtsam2SO9ClosestToERKN5Eigen6MatrixIdXT_EXT_EXorLNS1_14StorageOptionsE0EquaaeqT_Li1EneT_Li1ELS3_1EquaaeqT_Li1EneT_Li1ELS3_0ELS3_0EEXT_EXT_EEE'/>
<use f='codebrowser/gtsam/sfm/ShonanAveraging.cpp' l='241' c='_ZN5gtsamL14RoundSolutionSERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEE'/>
