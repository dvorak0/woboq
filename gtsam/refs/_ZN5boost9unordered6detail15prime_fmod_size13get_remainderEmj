<def f='include/boost/unordered/detail/prime_fmod.hpp' l='86' ll='105' type='static boost::uint64_t boost::unordered::detail::prime_fmod_size::get_remainder(boost::uint64_t fractional, boost::uint32_t d)'/>
<use f='include/boost/unordered/detail/prime_fmod.hpp' l='111' u='c' c='_ZN5boost9unordered6detail15prime_fmod_size11fast_moduloEjmj'/>
<doc f='include/boost/unordered/detail/prime_fmod.hpp' l='77'>// We emulate the techniques taken from:
        // Faster Remainder by Direct Computation: Applications to Compilers and
        // Software Libraries
        // https://arxiv.org/abs/1902.01961
        //
        // In essence, use fancy math to directly calculate the remainder (aka
        // modulo) exploiting how compilers transform division
        //</doc>
