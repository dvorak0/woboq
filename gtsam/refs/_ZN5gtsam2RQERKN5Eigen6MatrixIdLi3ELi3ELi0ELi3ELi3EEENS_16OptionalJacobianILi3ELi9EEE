<dec f='codebrowser/gtsam/geometry/Rot3.h' l='592' type='std::pair&lt;Matrix3, Vector3&gt; gtsam::RQ(const Matrix3 &amp; A, OptionalJacobian&lt;3, 9&gt; H = {})'/>
<doc f='codebrowser/gtsam/geometry/Rot3.h' l='582'>/**
   * [RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R
   * and 3 rotation angles corresponding to the rotation matrix Q=Qz&apos;*Qy&apos;*Qx&apos;
   * such that A = R*Q = R*Qz&apos;*Qy&apos;*Qx&apos;. When A is a rotation matrix, R will
   * be the identity and Q is a yaw-pitch-roll decomposition of A.
   * The implementation uses Givens rotations and is based on Hartley-Zisserman.
   * @param A 3 by 3 matrix A=RQ
   * @return an upper triangular matrix R
   * @return a vector [thetax, thetay, thetaz] in radians.
   */</doc>
<use f='codebrowser/gtsam/geometry/Rot3.cpp' l='175' u='c' c='_ZNK5gtsam4Rot33xyzENS_16OptionalJacobianILi3ELi3EEE'/>
<use f='codebrowser/gtsam/geometry/Rot3.cpp' l='181' u='c' c='_ZNK5gtsam4Rot33xyzENS_16OptionalJacobianILi3ELi3EEE'/>
<def f='codebrowser/gtsam/geometry/Rot3.cpp' l='249' ll='306' type='pair&lt;Matrix3, Vector3&gt; gtsam::RQ(const Matrix3 &amp; A, OptionalJacobian&lt;3, 9&gt; H = {})'/>
<doc f='codebrowser/gtsam/geometry/Rot3.cpp' l='248'>/* ************************************************************************* */</doc>
<use f='codebrowser/gtsam/geometry/tests/testRot3.cpp' l='535' u='c' c='_ZN10Rot3RQTest3runER10TestResult'/>
<use f='codebrowser/gtsam/geometry/tests/testRot3.cpp' l='556' u='c' c='_ZN10Rot3RQTest3runER10TestResult'/>
<use f='codebrowser/gtsam/geometry/tests/testRot3.cpp' l='853' u='c' c='_Z8RQ_proxyRKN5Eigen6MatrixIdLi3ELi3ELi0ELi3ELi3EEE'/>
<use f='codebrowser/gtsam/geometry/tests/testRot3.cpp' l='882' u='c' c='_ZN21Rot3RQ_derivativeTest3runER10TestResult'/>
