<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/MatrixBase.h' l='203' type='void Eigen::MatrixBase::adjointInPlace()'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/Transpose.h' l='374' ll='378' type='void Eigen::MatrixBase::adjointInPlace()'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/Transpose.h' l='355'>/** This is the &quot;in place&quot; version of adjoint(): it replaces \c *this by its own transpose.
  * Thus, doing
  * \code
  * m.adjointInPlace();
  * \endcode
  * has the same effect on m as doing
  * \code
  * m = m.adjoint().eval();
  * \endcode
  * and is faster and also safer because in the latter line of code, forgetting the eval() results
  * in a bug caused by aliasing.
  *
  * Notice however that this method is only useful if you want to replace a matrix by its own adjoint.
  * If you just need the adjoint of a matrix, use adjoint().
  *
  * \note if the matrix is not square, then \c *this must be a resizable matrix.
  * This excludes (non-square) fixed-size matrices, block-expressions and maps.
  *
  * \sa transpose(), adjoint(), transposeInPlace() */</doc>
