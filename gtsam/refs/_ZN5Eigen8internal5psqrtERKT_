<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/GenericPacketMath.h' l='815' type='Packet Eigen::internal::psqrt(const Packet &amp; a)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='86' ll='100' type='Packet4f Eigen::internal::psqrt(const Packet4f &amp; _x)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='109' ll='110' type='Packet2d Eigen::internal::psqrt(const Packet2d &amp; x)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='112' ll='113' type='Packet16b Eigen::internal::psqrt(const Packet16b &amp; x)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/Complex.h' l='340' ll='342' type='Packet1cd Eigen::internal::psqrt(const Packet1cd &amp; a)'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/Complex.h' l='344' ll='346' type='Packet2cf Eigen::internal::psqrt(const Packet2cf &amp; a)'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='78'>// Functions for sqrt.
// The EIGEN_FAST_MATH version uses the _mm_rsqrt_ps approximation and one step
// of Newton&apos;s method, at a cost of 1-2 bits of precision as opposed to the
// exact solution. It does not handle +inf, or denormalized numbers correctly.
// The main advantage of this approach is not just speed, but also the fact that
// it can be inlined and pipelined with other computations, further reducing its
// effective latency. This is similar to Quake3&apos;s fast inverse square root.
// For detail see here: http://www.beyond3d.com/content/articles/8/</doc>
