<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Quaternion.h' l='154' type='Quaternion&lt;Scalar&gt; Eigen::QuaternionBase::inverse() const'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Quaternion.h' l='719' ll='731' type='Quaternion&lt;typename internal::traits&lt;Derived&gt;::Scalar&gt; Eigen::QuaternionBase::inverse() const'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Quaternion.h' l='153'>/** \returns the quaternion describing the inverse rotation */</doc>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Quaternion.h' l='713'>/** \returns the multiplicative inverse of \c *this
  * Note that in most cases, i.e., if you simply want the opposite rotation,
  * and/or the quaternion is normalized, then it is enough to use the conjugate.
  *
  * \sa QuaternionBase::conjugate()
  */</doc>
<use f='codebrowser/examples/CombinedImuFactorsExample.cpp' l='281' u='c' c='main'/>
<use f='codebrowser/examples/ImuFactorsExample.cpp' l='309' u='c' c='main'/>
<use f='codebrowser/gtsam/geometry/tests/testQuaternion.cpp' l='92' u='c' c='_ZN21QuaternionBetweenTest3runER10TestResult'/>
