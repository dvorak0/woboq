<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='182' type='void Eigen::BDCSVD::computeSVDofM(Index firstCol, Index n, MatrixXr &amp; U, VectorType &amp; singVals, MatrixXr &amp; V)'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='558' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='594' ll='720' type='void Eigen::BDCSVD::computeSVDofM(Eigen::Index firstCol, Eigen::Index n, MatrixXr &amp; U, VectorType &amp; singVals, MatrixXr &amp; V)'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='586'>// Compute SVD of m_computed.block(firstCol, firstCol, n + 1, n); this block only has non-zeros in
// the first column and on the diagonal and has undergone deflation, so diagonal is in increasing
// order except for possibly the (0,0) entry. The computed SVD is stored U, singVals and V, except
// that if m_compV is false, then V is not computed. Singular values are sorted in decreasing order.
//
// TODO Opportunities for optimization: better root finding algo, better stopping criterion, better
// handling of round-off errors, be consistent in ordering
// For instance, to solve the secular equation using FMM, see http://www.stat.uchicago.edu/~lekheng/courses/302/classics/greengard-rokhlin.pdf</doc>
