<dec f='codebrowser/gtsam/base/Matrix.h' l='408' type='void gtsam::svd(const Matrix &amp; A, Matrix &amp; U, Vector &amp; S, Matrix &amp; V)'/>
<doc f='codebrowser/gtsam/base/Matrix.h' l='396'>/**
 * SVD computes economy SVD A=U*S*V&apos;
 * @param A an m*n matrix
 * @param U output argument: rotation matrix
 * @param S output argument: sorted vector of singular values
 * @param V output argument: rotation matrix
 * if m &gt; n then U*S*V&apos; = (m*n)*(n*n)*(n*n)
 * if m &lt; n then U*S*V&apos; = (m*m)*(m*m)*(m*n)
 * Careful! The dimensions above reflect V&apos;, not V, which is n*m if m&lt;n.
 * U is a basis in R^m, V is a basis in R^n
 * You can just pass empty matrices U,V, and vector S, they will be re-allocated.
 */</doc>
<def f='codebrowser/gtsam/base/Matrix.cpp' l='548' ll='553' type='void gtsam::svd(const Matrix &amp; A, Matrix &amp; U, Vector &amp; S, Matrix &amp; V)'/>
<doc f='codebrowser/gtsam/base/Matrix.cpp' l='547'>/* ************************************************************************* */</doc>
<use f='codebrowser/gtsam/base/tests/testCholesky.cpp' l='92' u='c' c='_ZN25choleskyBadScalingSVDTest3runER10TestResult'/>
<use f='codebrowser/gtsam/base/tests/testMatrix.cpp' l='969' u='c' c='_ZN14Matrixsvd1Test3runER10TestResult'/>
<use f='codebrowser/gtsam/base/tests/testMatrix.cpp' l='990' u='c' c='_ZN14Matrixsvd2Test3runER10TestResult'/>
<use f='codebrowser/gtsam/base/tests/testMatrix.cpp' l='1013' u='c' c='_ZN14Matrixsvd3Test3runER10TestResult'/>
<use f='codebrowser/gtsam/base/tests/testMatrix.cpp' l='1053' u='c' c='_ZN14Matrixsvd4Test3runER10TestResult'/>
<use f='codebrowser/gtsam/geometry/tests/testEssentialMatrix.cpp' l='222' u='c' c='_ZN27EssentialMatrixepipolesTest3runER10TestResult'/>
