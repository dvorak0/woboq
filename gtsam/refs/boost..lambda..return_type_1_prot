<def f='include/boost/lambda/detail/return_type_traits.hpp' l='72' ll='85'/>
<def f='include/boost/lambda/detail/return_type_traits.hpp' l='88' ll='90'/>
<use f='include/boost/lambda/detail/operator_lambda_func_base.hpp' l='76'/>
<doc f='include/boost/lambda/detail/return_type_traits.hpp' l='60'>// return_type_X_prot classes --------------------------------------------
// These classes are the first layer that gets instantiated from the 
// lambda_functor_base sig templates. It will check whether 
// the action is protectable and one of arguments is &quot;protected&quot; or its
// evaluation will otherwise result in another lambda functor.
// If this is a case, the result type will be another lambda functor.

// The arguments are always non-reference types, except for comma action
// where the right argument can be a reference too. This is because it 
// matters (in the builtin case) whether the argument is an lvalue or 
// rvalue: int i; i, 1 -&gt; rvalue; 1, i -&gt; lvalue</doc>
<doc f='include/boost/lambda/detail/return_type_traits.hpp' l='87'>// take care of the unavoidable instantiation for nullary case</doc>
