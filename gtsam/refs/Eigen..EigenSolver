<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='64' ll='321'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='324' c='_ZNK5Eigen11EigenSolver22pseudoEigenvalueMatrixEv'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='345' c='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='345' c='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='379' c='_ZN5Eigen11EigenSolver7computeERKNS_9EigenBaseITL0__EEb'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='378' c='_ZN5Eigen11EigenSolver7computeERKNS_9EigenBaseITL0__EEb'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='458' c='_ZN5Eigen11EigenSolver21doComputeEigenvectorsEv'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h' l='39' c='_ZN5Eigen8internal20eigenvalues_selectorIT_Lb0EE3runERKNS_10MatrixBaseIS2_EE'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Eigenvalues/EigenSolver.h' l='18'>/** \eigenvalues_module \ingroup Eigenvalues_Module
  *
  *
  * \class EigenSolver
  *
  * \brief Computes eigenvalues and eigenvectors of general matrices
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the
  * eigendecomposition; this is expected to be an instantiation of the Matrix
  * class template. Currently, only real matrices are supported.
  *
  * The eigenvalues and eigenvectors of a matrix \f$ A \f$ are scalars
  * \f$ \lambda \f$ and vectors \f$ v \f$ such that \f$ Av = \lambda v \f$.  If
  * \f$ D \f$ is a diagonal matrix with the eigenvalues on the diagonal, and
  * \f$ V \f$ is a matrix with the eigenvectors as its columns, then \f$ A V =
  * V D \f$. The matrix \f$ V \f$ is almost always invertible, in which case we
  * have \f$ A = V D V^{-1} \f$. This is called the eigendecomposition.
  *
  * The eigenvalues and eigenvectors of a matrix may be complex, even when the
  * matrix is real. However, we can choose real matrices \f$ V \f$ and \f$ D
  * \f$ satisfying \f$ A V = V D \f$, just like the eigendecomposition, if the
  * matrix \f$ D \f$ is not required to be diagonal, but if it is allowed to
  * have blocks of the form
  * \f[ \begin{bmatrix} u &amp; v \\ -v &amp; u \end{bmatrix} \f]
  * (where \f$ u \f$ and \f$ v \f$ are real numbers) on the diagonal.  These
  * blocks correspond to complex eigenvalue pairs \f$ u \pm iv \f$. We call
  * this variant of the eigendecomposition the pseudo-eigendecomposition.
  *
  * Call the function compute() to compute the eigenvalues and eigenvectors of
  * a given matrix. Alternatively, you can use the 
  * EigenSolver(const MatrixType&amp;, bool) constructor which computes the
  * eigenvalues and eigenvectors at construction time. Once the eigenvalue and
  * eigenvectors are computed, they can be retrieved with the eigenvalues() and
  * eigenvectors() functions. The pseudoEigenvalueMatrix() and
  * pseudoEigenvectors() methods allow the construction of the
  * pseudo-eigendecomposition.
  *
  * The documentation for EigenSolver(const MatrixType&amp;, bool) contains an
  * example of the typical use of this class.
  *
  * \note The implementation is adapted from
  * &lt;a href=&quot;http://math.nist.gov/javanumerics/jama/&quot;&gt;JAMA&lt;/a&gt; (public domain).
  * Their code is based on EISPACK.
  *
  * \sa MatrixBase::eigenvalues(), class ComplexEigenSolver, class SelfAdjointEigenSolver
  */</doc>
<fun r='_ZN5Eigen11EigenSolverC1Ev'/>
<fun r='_ZN5Eigen11EigenSolverC1El'/>
<fun r='_ZN5Eigen11EigenSolverC1ERKNS_9EigenBaseITL0__EEb'/>
<fun r='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<fun r='_ZNK5Eigen11EigenSolver18pseudoEigenvectorsEv'/>
<fun r='_ZNK5Eigen11EigenSolver22pseudoEigenvalueMatrixEv'/>
<fun r='_ZNK5Eigen11EigenSolver11eigenvaluesEv'/>
<fun r='_ZN5Eigen11EigenSolver7computeERKNS_9EigenBaseITL0__EEb'/>
<fun r='_ZNK5Eigen11EigenSolver4infoEv'/>
<fun r='_ZN5Eigen11EigenSolver16setMaxIterationsEl'/>
<fun r='_ZN5Eigen11EigenSolver16getMaxIterationsEv'/>
<fun r='_ZN5Eigen11EigenSolver21doComputeEigenvectorsEv'/>
<fun r='_ZN5Eigen11EigenSolver25check_template_parametersEv'/>
<mbr r='Eigen::EigenSolver::m_eivec' t='MatrixType'/>
<mbr r='Eigen::EigenSolver::m_eivalues' t='EigenvalueType'/>
<mbr r='Eigen::EigenSolver::m_isInitialized' t='bool'/>
<mbr r='Eigen::EigenSolver::m_eigenvectorsOk' t='bool'/>
<mbr r='Eigen::EigenSolver::m_info' t='ComputationInfo'/>
<mbr r='Eigen::EigenSolver::m_realSchur' t='RealSchur&lt;MatrixType&gt;'/>
<mbr r='Eigen::EigenSolver::m_matT' t='MatrixType'/>
<mbr r='Eigen::EigenSolver::m_tmp' t='ColumnVectorType'/>
<fun r='_ZNK5Eigen11EigenSolver22pseudoEigenvalueMatrixEv'/>
<fun r='_ZNK5Eigen11EigenSolver12eigenvectorsEv'/>
<fun r='_ZN5Eigen11EigenSolver7computeERKNS_9EigenBaseITL0__EEb'/>
<fun r='_ZN5Eigen11EigenSolver21doComputeEigenvectorsEv'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h' l='26' c='_ZN5Eigen8internal47matrix_sqrt_quasi_triangular_2x2_diagonal_blockERKT_lRT0_'/>
<use f='codebrowser/gtsam/geometry/SO4.cpp' l='96' c='_ZN5gtsam2SO6ExpmapERKN5Eigen6MatrixIdL_ZNS0_9dimensionEELi1EXorLNS1_14StorageOptionsE0EquaaeqL_ZNS0_9dimensionEELi1EneLi1ELi1ELS3_1EquaaeqLi1ELi1EneL13743585'/>
<use f='codebrowser/gtsam/linear/tests/testAcceleratedPowerMethod.cpp' l='72' c='_ZN46AcceleratedPowerMethoduseFactorGraphSparseTest3runER10TestResult'/>
<use f='codebrowser/gtsam/linear/tests/testAcceleratedPowerMethod.cpp' l='107' c='_ZN45AcceleratedPowerMethoduseFactorGraphDenseTest3runER10TestResult'/>
<use f='codebrowser/gtsam/linear/tests/testPowerMethod.cpp' l='70' c='_ZN35PowerMethoduseFactorGraphSparseTest3runER10TestResult'/>
<use f='codebrowser/gtsam/linear/tests/testPowerMethod.cpp' l='98' c='_ZN34PowerMethoduseFactorGraphDenseTest3runER10TestResult'/>
<use f='codebrowser/gtsam/sfm/tests/testShonanAveraging.cpp' l='185' c='_ZN34ShonanAveraging3CheckWithEigenTest3runER10TestResult'/>
