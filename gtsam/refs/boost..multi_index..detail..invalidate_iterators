<def f='include/boost/multi_index/detail/invalidate_iterators.hpp' l='30' ll='36'/>
<use f='include/boost/multi_index/detail/invalidate_iterators.hpp' l='34' c='_ZN5boost11multi_index6detail20invalidate_iterators3getEv'/>
<use f='include/boost/multi_index/detail/invalidate_iterators.hpp' l='35' c='_ZN5boost11multi_index6detail20invalidate_iterators4nextEv'/>
<use f='include/boost/multi_index/hashed_index.hpp' l='1094' c='_ZN5boost11multi_index6detail12hashed_index7modify_EPNS1_17hashed_index_nodeINT2_4type15index_node_typeEEE'/>
<use f='include/boost/multi_index/hashed_index.hpp' l='1103' c='_ZN5boost11multi_index6detail12hashed_index7modify_EPNS1_17hashed_index_nodeINT2_4type15index_node_typeEEE'/>
<use f='include/boost/multi_index/hashed_index.hpp' l='1113' c='_ZN5boost11multi_index6detail12hashed_index7modify_EPNS1_17hashed_index_nodeINT2_4type15index_node_typeEEE'/>
<use f='include/boost/multi_index_container.hpp' l='940' c='_ZN5boost11multi_index21multi_index_container8extract_EPNS0_6detail21multi_index_base_typeIT_T0_T1_E4type15final_node_typeE'/>
<use f='include/boost/multi_index_container.hpp' l='954' c='_ZN5boost11multi_index21multi_index_container6erase_EPNS0_6detail21multi_index_base_typeIT_T0_T1_E4type15final_node_typeE'/>
<size>1</size>
<doc f='include/boost/multi_index/detail/invalidate_iterators.hpp' l='22'>/* invalidate_iterators mimics the interface of index_access_sequence (see
 * index_access_sequence.hpp) but returns dummy indices whose iterator type
 * won&apos;t ever match those of the source: the net effect is that safe iterator
 * transfer resolves to iterator invalidation, so backbone function invocation
 * extract_(x,invalidate_iterators()) is used in extraction scenarios other
 * than merging.
 */</doc>
<fun r='_ZN5boost11multi_index6detail20invalidate_iterators3getEv'/>
<fun r='_ZN5boost11multi_index6detail20invalidate_iterators4nextEv'/>
