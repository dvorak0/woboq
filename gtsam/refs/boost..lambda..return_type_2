<use f='include/boost/lambda/detail/return_type_traits.hpp' l='153'/>
<use f='include/boost/lambda/detail/return_type_traits.hpp' l='190'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='414' ll='432'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='513' ll='541'/>
<use f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='527'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='585' ll='601'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='604' ll='620'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='630' ll='639'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='650' ll='658'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='668' ll='685'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='687' ll='704'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='706' ll='722'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='734' ll='744'/>
<def f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='786' ll='807'/>
<def f='include/boost/lambda/detail/member_ptr.hpp' l='642' ll='653'/>
<use f='include/boost/lambda/detail/member_ptr.hpp' l='663'/>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='413'>// drop any qualifiers from the argument types within arithmetic_action</doc>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='509'>// --  bitwise actions -------------------------------------------
// note: for integral types deuduction is similar to arithmetic actions. 

// drop any qualifiers from the argument types within arithmetic action</doc>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='584'>// ostream</doc>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='603'>// istream</doc>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='660'>// Assingment actions -----------------------------------------------
// return type is the type of the first argument as reference

// note that cv-qualifiers are preserved.
// Yes, assignment operator can be const!

// NOTE: this may not be true for some weird user-defined types,</doc>
<doc f='include/boost/lambda/detail/operator_return_type_traits.hpp' l='724'>// -- other actions ----------------------------------------

// comma action ----------------------------------
// Note: this may not be true for some weird user-defined types,

// NOTE! This only tries the plain_return_type_2 layer and gives
// detail::unspecified as default. If no such specialization is found, the 
// type rule in the spcecialization of the return_type_2_prot is used
// to give the type of the right argument (which can be a reference too)
// (The built in operator, can return a l- or rvalue).</doc>
<doc f='include/boost/lambda/detail/member_ptr.hpp' l='626'>// return type deduction --

  // If the right argument is a pointer to data member, 
  // and the left argument is of compatible pointer to class type
  // return type is a reference to the data member type

  // if right argument is a pointer to a member function, and the left 
  // argument is of a compatible type, the return type is a 
  // member_pointer_caller (see above)

  // Otherwise, return type deduction fails. There is either an error, 
  // or the user is trying to call an overloaded -&gt;*
  // In such a case either ret&lt;&gt; must be used, or a return_type_2 user 
  // defined specialization must be provided</doc>
