<def f='codebrowser/gtsam/3rdparty/Spectra/LinAlg/UpperHessenbergQR.h' l='132' ll='171' type='static void Spectra::UpperHessenbergQR::compute_rotation(const Scalar &amp; x, const Scalar &amp; y, Scalar &amp; r, Scalar &amp; c, Scalar &amp; s)'/>
<use f='codebrowser/gtsam/3rdparty/Spectra/LinAlg/UpperHessenbergQR.h' l='251' u='c' c='_ZN7Spectra17UpperHessenbergQR7computeERKN5Eigen3RefIKNS1_6MatrixIT_Lin1ELin1ELi0ELin1ELin1EEELi0ENS1_8internal11conditionalIXsr6MatrixE21IsVectorAtCo1637506'/>
<doc f='codebrowser/gtsam/3rdparty/Spectra/LinAlg/UpperHessenbergQR.h' l='127'>// Given x and y, compute 1) r = sqrt(x^2 + y^2), 2) c = x / r, 3) s = -y / r
    // If both x and y are zero, set c = 1 and s = 0
    // We must implement it in a numerically stable way
    // The implementation below is shown to be more accurate than directly computing
    //     r = std::hypot(x, y); c = x / r; s = -y / r;</doc>
