<dec f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.h' l='153' type='std::shared_ptr&lt;HessianFactor&gt; gtsam::NonlinearFactorGraph::linearizeToHessianFactor(const Values &amp; values, const Ordering &amp; ordering, const Dampen &amp; dampen = nullptr) const'/>
<doc f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.h' l='145'>/**
     * Instead of producing a GaussianFactorGraph, pre-allocate and linearize directly
     * into a HessianFactor. Avoids the many mallocs and pointer indirection in constructing
     * a new graph, and hence useful in case a dense solve is appropriate for your problem.
     * An ordering is given that still decides how the Hessian is laid out.
     * An optional lambda function can be used to apply damping on the filled Hessian.
     * No parallelism is exploited, because all the factors write in the same memory.
     */</doc>
<def f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='335' ll='341' type='HessianFactor::shared_ptr gtsam::NonlinearFactorGraph::linearizeToHessianFactor(const Values &amp; values, const Ordering &amp; order, const Dampen &amp; dampen = nullptr) const'/>
<use f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='366' u='c' c='_ZNK5gtsam20NonlinearFactorGraph14updateCholeskyERKNS_6ValuesERKNS_8OrderingERKSt8functionIFvRKSt10shared_ptrINS_13HessianFactorEEEE'/>
<doc f='codebrowser/gtsam/nonlinear/NonlinearFactorGraph.cpp' l='334'>/* ************************************************************************* */</doc>
<use f='codebrowser/gtsam_unstable/nonlinear/NonlinearClusterTree.h' l='54' u='c' c='_ZNK5gtsam20NonlinearClusterTree16NonlinearCluster24linearizeToHessianFactorERKNS_6ValuesERKSt8functionIFvRKSt10shared_ptrINS_13HessianFactorEEEE'/>
<use f='codebrowser/gtsam_unstable/nonlinear/NonlinearClusterTree.h' l='62' u='c' c='_ZNK5gtsam20NonlinearClusterTree16NonlinearCluster24linearizeToHessianFactorERKNS_6ValuesERKNS_8OrderingERKSt8functionIFvRKSt10shared_ptrINS_13HessianFactorEEEE'/>
