<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/MatrixBase.h' l='202' type='const AdjointReturnType Eigen::MatrixBase::adjoint() const'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/Transpose.h' l='219' ll='224' type='const typename MatrixBase&lt;Derived&gt;::AdjointReturnType Eigen::MatrixBase::adjoint() const'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/Transpose.h' l='377' u='c' c='_ZN5Eigen10MatrixBase14adjointInPlaceEv'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Core/Transpose.h' l='200'>/** \returns an expression of the adjoint (i.e. conjugate transpose) of *this.
  *
  * Example: \include MatrixBase_adjoint.cpp
  * Output: \verbinclude MatrixBase_adjoint.out
  *
  * \warning If you want to replace a matrix by its own adjoint, do \b NOT do this:
  * \code
  * m = m.adjoint(); // bug!!! caused by aliasing effect
  * \endcode
  * Instead, use the adjointInPlace() method:
  * \code
  * m.adjointInPlace();
  * \endcode
  * which gives Eigen good opportunities for optimization, or alternatively you can also do:
  * \code
  * m = m.adjoint().eval();
  * \endcode
  *
  * \sa adjointInPlace(), transpose(), conjugate(), class Transpose, class internal::scalar_conjugate_op */</doc>
<use f='codebrowser/examples/TriangulationLOSTExample.cpp' l='41' u='c' c='_Z20PrintCovarianceStatsRKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
