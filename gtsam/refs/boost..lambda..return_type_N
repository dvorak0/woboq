<use f='include/boost/lambda/detail/return_type_traits.hpp' l='208'/>
<def f='include/boost/lambda/detail/return_type_traits.hpp' l='219' ll='222'/>
<def f='include/boost/lambda/detail/return_type_traits.hpp' l='244' ll='260'/>
<use f='include/boost/lambda/detail/lambda_functor_base.hpp' l='359'/>
<def f='include/boost/lambda/detail/ret.hpp' l='258' ll='260'/>
<def f='include/boost/lambda/detail/member_ptr.hpp' l='658' ll='667'/>
<doc f='include/boost/lambda/detail/return_type_traits.hpp' l='216'>// handle different kind of actions ------------------------

  // use the return type given in the bind invocation as bind&lt;Ret&gt;(...)</doc>
<doc f='include/boost/lambda/detail/return_type_traits.hpp' l='243'>// Ret is detail::unspecified, so try to deduce return type</doc>
<doc f='include/boost/lambda/detail/member_ptr.hpp' l='655'>// this is the way the generic lambda_functor_base functions instantiate
  // return type deduction. We turn it into return_type_2, so that the 
  // user can provide specializations on that level.</doc>
