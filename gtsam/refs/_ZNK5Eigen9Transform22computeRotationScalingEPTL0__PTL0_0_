<dec f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='604' type='void Eigen::Transform::computeRotationScaling(RotationMatrixType * rotation, ScalingMatrixType * scaling) const'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1096' ll='1113' type='void Eigen::Transform::computeRotationScaling(RotationMatrixType * rotation, ScalingMatrixType * scaling) const'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/Geometry/Transform.h' l='1085'>/** decomposes the linear part of the transformation as a product rotation x scaling, the scaling being
  * not necessarily positive.
  *
  * If either pointer is zero, the corresponding computation is skipped.
  *
  *
  *
  * \svd_module
  *
  * \sa computeScalingRotation(), rotation(), class SVD
  */</doc>
