<use f='include/boost/proto/proto_fwd.hpp' l='351'/>
<use f='include/boost/proto/proto_fwd.hpp' l='406'/>
<use f='include/boost/proto/proto_fwd.hpp' l='406'/>
<use f='include/boost/proto/proto_fwd.hpp' l='409'/>
<use f='include/boost/proto/traits.hpp' l='101'/>
<use f='include/boost/proto/transform/detail/pack.hpp' l='67'/>
<use f='include/boost/proto/transform/when.hpp' l='157'/>
<use f='include/boost/proto/transform/when.hpp' l='247'/>
<use f='include/boost/proto/matches.hpp' l='96'/>
<use f='include/boost/proto/matches.hpp' l='111'/>
<use f='include/boost/proto/matches.hpp' l='276'/>
<use f='include/boost/proto/matches.hpp' l='297'/>
<use f='include/boost/proto/matches.hpp' l='307'/>
<use f='include/boost/proto/matches.hpp' l='317'/>
<use f='include/boost/proto/matches.hpp' l='322'/>
<use f='include/boost/proto/matches.hpp' l='336'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='32'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='62'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='92'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='122'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='152'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='182'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='212'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='242'/>
<use f='include/boost/proto/detail/preprocessed/matches_.hpp' l='272'/>
<use f='include/boost/proto/matches.hpp' l='381'/>
<inh f='include/boost/proto/transform/impl.hpp' l='253' c='boost::proto::transform'/>
<def f='include/boost/proto/matches.hpp' l='563' ll='584'/>
<use f='include/boost/proto/matches.hpp' l='563'/>
<use f='include/boost/proto/matches.hpp' l='565'/>
<use f='include/boost/phoenix/core/domain.hpp' l='32'/>
<use f='include/boost/phoenix/core/domain.hpp' l='42'/>
<use f='include/boost/phoenix/core/domain.hpp' l='51'/>
<use f='include/boost/phoenix/core/domain.hpp' l='57'/>
<use f='include/boost/proto/transform/default.hpp' l='38'/>
<use f='include/boost/proto/transform/default.hpp' l='43'/>
<use f='include/boost/phoenix/core/meta_grammar.hpp' l='28'/>
<use f='include/boost/proto/transform/fold.hpp' l='212'/>
<use f='include/boost/proto/transform/fold.hpp' l='212'/>
<use f='include/boost/proto/transform/fold.hpp' l='226'/>
<use f='include/boost/proto/transform/fold.hpp' l='226'/>
<use f='include/boost/phoenix/core/is_nullary.hpp' l='34'/>
<use f='include/boost/phoenix/core/is_nullary.hpp' l='38'/>
<use f='include/boost/phoenix/core/terminal.hpp' l='93'/>
<use f='include/boost/phoenix/core/reference.hpp' l='62'/>
<use f='include/boost/proto/transform/fold_tree.hpp' l='47'/>
<use f='include/boost/proto/transform/fold_tree.hpp' l='52'/>
<use f='include/boost/spirit/home/support/meta_compiler.hpp' l='70'/>
<use f='include/boost/spirit/home/support/meta_compiler.hpp' l='110'/>
<use f='include/boost/spirit/home/support/meta_compiler.hpp' l='119'/>
<use f='include/boost/proto/operators.hpp' l='50'/>
<use f='include/boost/proto/operators.hpp' l='80'/>
<size>1</size>
<doc f='include/boost/proto/matches.hpp' l='522'>/// \brief A wildcard grammar element that matches any expression,
    /// and a transform that returns the current expression unchanged.
    ///
    /// The wildcard type, \c _, is a grammar element such that
    /// &lt;tt&gt;matches\&lt;E,_\&gt;::value&lt;/tt&gt; is \c true for any expression
    /// type \c E.
    ///
    /// The wildcard can also be used as a stand-in for a template
    /// argument when matching terminals. For instance, the following
    /// is a grammar that will match any &lt;tt&gt;std::complex\&lt;\&gt;&lt;/tt&gt;
    /// terminal:
    ///
    /// \code
    /// BOOST_MPL_ASSERT((
    ///     matches&lt;
    ///         terminal&lt;std::complex&lt;double&gt; &gt;::type
    ///       , terminal&lt;std::complex&lt; _ &gt; &gt;
    ///     &gt;
    /// ));
    /// \endcode
    ///
    /// When used as a transform, \c _ returns the current expression
    /// unchanged. For instance, in the following, \c _ is used with
    /// the \c fold\&lt;\&gt; transform to fold the children of a node:
    ///
    /// \code
    /// struct CountChildren
    ///   : or_&lt;
    ///         // Terminals have no children
    ///         when&lt;terminal&lt;_&gt;, mpl::int_&lt;0&gt;()&gt;
    ///         // Use fold&lt;&gt; to count the children of non-terminals
    ///       , otherwise&lt;
    ///             fold&lt;
    ///                 _ // &lt;-- fold the current expression
    ///               , mpl::int_&lt;0&gt;()
    ///               , mpl::plus&lt;_state, mpl::int_&lt;1&gt; &gt;()
    ///             &gt;
    ///         &gt;
    ///     &gt;
    /// {};
    /// \endcode</doc>
