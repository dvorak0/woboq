<dec f='codebrowser/gtsam/discrete/DecisionTree.h' l='157' type='static NodePtr gtsam::DecisionTree::build(It begin, It end, ValueIt beginY, ValueIt endY)'/>
<def f='codebrowser/gtsam/discrete/DecisionTree-inl.h' l='689' ll='726' type='static typename DecisionTree&lt;L, Y&gt;::NodePtr gtsam::DecisionTree::build(It begin, It end, ValueIt beginY, ValueIt endY)'/>
<doc f='codebrowser/gtsam/discrete/DecisionTree-inl.h' l='668'>/****************************************************************************/
  // &quot;build&quot; is a bit of a complicated thing, but very useful.
  // It takes a range of labels and a corresponding range of values,
  // and builds a decision tree, as follows:
  // - if there is only one label, creates a choice node with values in leaves
  // - otherwise, it evenly splits up the range of values and creates a tree for
  //   each sub-range, and assigns that tree to first label&apos;s choices
  // Example:
  // build([B A],[1 2 3 4]) would call
  //   build([A],[1 2])
  //   build([A],[3 4])
  // and produce
  // B=0
  //  A=0: 1
  //  A=1: 2
  // B=1
  //  A=0: 3
  //  A=1: 4
  // Note, through the magic of &quot;compose&quot;, create([A B],[1 3 2 4]) will produce
  // exactly the same tree as above: the highest label is always the root.
  // However, it will be *way* faster if labels are given highest to lowest.</doc>
