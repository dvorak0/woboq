<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='22'/>
<def f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='62' ll='303'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='63'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='308' c='_ZNK5Eigen7SVDBase11_solve_implERKTL0__RTL0_0_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='322' c='_ZNK5Eigen7SVDBase22_solve_impl_transposedERKTL0_0_RTL0_1_'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='337' c='_ZN5Eigen7SVDBase8allocateEllj'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='489'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/JacobiSVD.h' l='491'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='73'/>
<use f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/BDCSVD.h' l='75'/>
<doc f='codebrowser/gtsam/3rdparty/Eigen/Eigen/src/SVD/SVDBase.h' l='32'>/** \ingroup SVD_Module
 *
 *
 * \class SVDBase
 *
 * \brief Base class of SVD algorithms
 *
 * \tparam Derived the type of the actual SVD decomposition
 *
 * SVD decomposition consists in decomposing any n-by-p matrix \a A as a product
 *   \f[ A = U S V^* \f]
 * where \a U is a n-by-n unitary, \a V is a p-by-p unitary, and \a S is a n-by-p real positive matrix which is zero outside of its main diagonal;
 * the diagonal entries of S are known as the \em singular \em values of \a A and the columns of \a U and \a V are known as the left
 * and right \em singular \em vectors of \a A respectively.
 *
 * Singular values are always sorted in decreasing order.
 *
 * 
 * You can ask for only \em thin \a U or \a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \a m be the
 * smaller value among \a n and \a p, there are only \a m singular vectors; the remaining columns of \a U and \a V do not correspond to actual
 * singular vectors. Asking for \em thin \a U or \a V means asking for only their \a m first columns to be formed. So \a U is then a n-by-m matrix,
 * and \a V is then a p-by-m matrix. Notice that thin \a U and \a V are all you need for (least squares) solving.
 * 
 * The status of the computation can be retrived using the \a info() method. Unless \a info() returns \a Success, the results should be not
 * considered well defined.
 *  
 * If the input matrix has inf or nan coefficients, the result of the computation is undefined, and \a info() will return \a InvalidInput, but the computation is guaranteed to
 * terminate in finite (and reasonable) time.
 * \sa class BDCSVD, class JacobiSVD
 */</doc>
<fun r='_ZN5Eigen7SVDBase7derivedEv'/>
<fun r='_ZNK5Eigen7SVDBase7derivedEv'/>
<fun r='_ZNK5Eigen7SVDBase7matrixUEv'/>
<fun r='_ZNK5Eigen7SVDBase7matrixVEv'/>
<fun r='_ZNK5Eigen7SVDBase14singularValuesEv'/>
<fun r='_ZNK5Eigen7SVDBase21nonzeroSingularValuesEv'/>
<fun r='_ZNK5Eigen7SVDBase4rankEv'/>
<fun r='_ZN5Eigen7SVDBase12setThresholdERKNS_9NumTraitsINS_8internal6traitsIT_E10MatrixType6ScalarEE4RealE'/>
<fun r='_ZN5Eigen7SVDBase12setThresholdENS_9Default_tE'/>
<fun r='_ZNK5Eigen7SVDBase9thresholdEv'/>
<fun r='_ZNK5Eigen7SVDBase8computeUEv'/>
<fun r='_ZNK5Eigen7SVDBase8computeVEv'/>
<fun r='_ZNK5Eigen7SVDBase4rowsEv'/>
<fun r='_ZNK5Eigen7SVDBase4colsEv'/>
<fun r='_ZNK5Eigen7SVDBase4infoEv'/>
<fun r='_ZNK5Eigen7SVDBase11_solve_implERKTL0__RTL0_0_'/>
<fun r='_ZNK5Eigen7SVDBase22_solve_impl_transposedERKTL0_0_RTL0_1_'/>
<fun r='_ZN5Eigen7SVDBase25check_template_parametersEv'/>
<fun r='_ZNK5Eigen7SVDBase25_check_compute_assertionsEv'/>
<fun r='_ZNK5Eigen7SVDBase22_check_solve_assertionERKTL0_0_'/>
<fun r='_ZN5Eigen7SVDBase8allocateEllj'/>
<mbr r='Eigen::SVDBase::m_matrixU' t='MatrixUType'/>
<mbr r='Eigen::SVDBase::m_matrixV' t='MatrixVType'/>
<mbr r='Eigen::SVDBase::m_singularValues' t='SingularValuesType'/>
<mbr r='Eigen::SVDBase::m_info' t='ComputationInfo'/>
<mbr r='Eigen::SVDBase::m_isInitialized' t='bool'/>
<mbr r='Eigen::SVDBase::m_isAllocated' t='bool'/>
<mbr r='Eigen::SVDBase::m_usePrescribedThreshold' t='bool'/>
<mbr r='Eigen::SVDBase::m_computeFullU' t='bool'/>
<mbr r='Eigen::SVDBase::m_computeThinU' t='bool'/>
<mbr r='Eigen::SVDBase::m_computeFullV' t='bool'/>
<mbr r='Eigen::SVDBase::m_computeThinV' t='bool'/>
<mbr r='Eigen::SVDBase::m_computationOptions' t='unsigned int'/>
<mbr r='Eigen::SVDBase::m_nonzeroSingularValues' t='Index'/>
<mbr r='Eigen::SVDBase::m_rows' t='Index'/>
<mbr r='Eigen::SVDBase::m_cols' t='Index'/>
<mbr r='Eigen::SVDBase::m_diagSize' t='Index'/>
<mbr r='Eigen::SVDBase::m_prescribedThreshold' t='RealScalar'/>
<fun r='_ZN5Eigen7SVDBaseC1Ev'/>
<fun r='_ZNK5Eigen7SVDBase11_solve_implERKTL0__RTL0_0_'/>
<fun r='_ZNK5Eigen7SVDBase22_solve_impl_transposedERKTL0_0_RTL0_1_'/>
<fun r='_ZN5Eigen7SVDBase8allocateEllj'/>
