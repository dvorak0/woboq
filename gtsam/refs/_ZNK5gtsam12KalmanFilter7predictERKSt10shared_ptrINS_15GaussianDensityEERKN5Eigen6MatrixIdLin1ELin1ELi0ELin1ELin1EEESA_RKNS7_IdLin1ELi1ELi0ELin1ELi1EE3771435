<dec f='codebrowser/gtsam/linear/KalmanFilter.h' l='148' type='State gtsam::KalmanFilter::predict(const State &amp; p, const Matrix &amp; F, const Matrix &amp; B, const Vector &amp; u, const SharedDiagonal &amp; modelQ) const'/>
<def f='codebrowser/gtsam/linear/KalmanFilter.cpp' l='113' ll='122' type='KalmanFilter::State gtsam::KalmanFilter::predict(const State &amp; p, const Matrix &amp; F, const Matrix &amp; B, const Vector &amp; u, const SharedDiagonal &amp; model) const'/>
<doc f='codebrowser/gtsam/linear/KalmanFilter.cpp' l='112'>/* ************************************************************************* */</doc>
<doc f='codebrowser/gtsam/linear/KalmanFilter.h' l='128'>/**
   * Predict the next state \f$ P(x_{k+1}|Z^k) \f$.
   *
   * In Kalman Filter notation:
   * - \f$ x_{k+1|k} \f$: Predicted state.
   * - \f$ P_{k+1|k} \f$: Predicted covariance.
   *
   * Motion model:
   * \f[
   * x_{k+1} = F \cdot x_k + B \cdot u_k + w
   * \f]
   * where \f$ w \f$ is zero-mean Gaussian noise with covariance \f$ Q \f$.
   *
   * @param p Previous state (\f$ x_k \f$).
   * @param F State transition matrix (\f$ F \f$).
   * @param B Control input matrix (\f$ B \f$).
   * @param u Control vector (\f$ u_k \f$).
   * @param modelQ Noise model (\f$ Q \f$, diagonal Gaussian).
   * @return Predicted state (\f$ x_{k+1|k} \f$).
   */</doc>
<use f='codebrowser/gtsam/linear/tests/testKalmanFilter.cpp' l='109' u='c' c='_ZN23KalmanFilterlinear1Test3runER10TestResult'/>
<use f='codebrowser/gtsam/linear/tests/testKalmanFilter.cpp' l='125' u='c' c='_ZN23KalmanFilterlinear1Test3runER10TestResult'/>
<use f='codebrowser/gtsam_unstable/nonlinear/tests/testParticleFactor.cpp' l='169' u='c' c='_ZN25ParticleFilterlinear1Test3runER10TestResult'/>
<use f='codebrowser/gtsam_unstable/nonlinear/tests/testParticleFactor.cpp' l='185' u='c' c='_ZN25ParticleFilterlinear1Test3runER10TestResult'/>
