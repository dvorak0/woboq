<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Macros.h source code [include/eigen3/Eigen/src/Core/util/Macros.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/eigen3/Eigen/src/Core/util/Macros.h'; var root_path = '../../../../../..'; var data_path = '../../../../../../../data';</script>
<script src='../../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>include</a>/<a href='../../../..'>eigen3</a>/<a href='../../..'>Eigen</a>/<a href='../..'>src</a>/<a href='..'>Core</a>/<a href='./'>util</a>/<a href='Macros.h.html'>Macros.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>// This file is part of Eigen, a lightweight C++ template library</i></td></tr>
<tr><th id="2">2</th><td><i>// for linear algebra.</i></td></tr>
<tr><th id="3">3</th><td><i>//</i></td></tr>
<tr><th id="4">4</th><td><i>// Copyright (C) 2008-2010 Gael Guennebaud &lt;gael.guennebaud@inria.fr&gt;</i></td></tr>
<tr><th id="5">5</th><td><i>// Copyright (C) 2006-2008 Benoit Jacob &lt;jacob.benoit.1@gmail.com&gt;</i></td></tr>
<tr><th id="6">6</th><td><i>//</i></td></tr>
<tr><th id="7">7</th><td><i>// This Source Code Form is subject to the terms of the Mozilla</i></td></tr>
<tr><th id="8">8</th><td><i>// Public License v. 2.0. If a copy of the MPL was not distributed</i></td></tr>
<tr><th id="9">9</th><td><i>// with this file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>.</i></td></tr>
<tr><th id="10">10</th><td></td></tr>
<tr><th id="11">11</th><td><u>#<span data-ppcond="11">ifndef</span> <span class="macro" data-ref="_M/EIGEN_MACROS_H">EIGEN_MACROS_H</span></u></td></tr>
<tr><th id="12">12</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MACROS_H" data-ref="_M/EIGEN_MACROS_H">EIGEN_MACROS_H</dfn></u></td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td><u>#define <dfn class="macro" id="_M/EIGEN_WORLD_VERSION" data-ref="_M/EIGEN_WORLD_VERSION">EIGEN_WORLD_VERSION</dfn> 3</u></td></tr>
<tr><th id="15">15</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MAJOR_VERSION" data-ref="_M/EIGEN_MAJOR_VERSION">EIGEN_MAJOR_VERSION</dfn> 2</u></td></tr>
<tr><th id="16">16</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MINOR_VERSION" data-ref="_M/EIGEN_MINOR_VERSION">EIGEN_MINOR_VERSION</dfn> 0</u></td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><u>#define <dfn class="macro" id="_M/EIGEN_VERSION_AT_LEAST" data-ref="_M/EIGEN_VERSION_AT_LEAST">EIGEN_VERSION_AT_LEAST</dfn>(x,y,z) (EIGEN_WORLD_VERSION&gt;x || (EIGEN_WORLD_VERSION&gt;=x &amp;&amp; \</u></td></tr>
<tr><th id="19">19</th><td><u>                                      (EIGEN_MAJOR_VERSION&gt;y || (EIGEN_MAJOR_VERSION&gt;=y &amp;&amp; \</u></td></tr>
<tr><th id="20">20</th><td><u>                                                                 EIGEN_MINOR_VERSION&gt;=z))))</u></td></tr>
<tr><th id="21">21</th><td><u>#<span data-ppcond="21">ifdef</span> <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span></u></td></tr>
<tr><th id="22">22</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_GNUC_AT_LEAST" data-ref="_M/EIGEN_GNUC_AT_LEAST">EIGEN_GNUC_AT_LEAST</dfn>(x,y) ((__GNUC__==x &amp;&amp; __GNUC_MINOR__&gt;=y) || __GNUC__&gt;x)</u></td></tr>
<tr><th id="23">23</th><td><u>#<span data-ppcond="21">else</span></u></td></tr>
<tr><th id="24">24</th><td>  <u>#define EIGEN_GNUC_AT_LEAST(x,y) 0</u></td></tr>
<tr><th id="25">25</th><td><u>#<span data-ppcond="21">endif</span></u></td></tr>
<tr><th id="26">26</th><td> </td></tr>
<tr><th id="27">27</th><td><u>#<span data-ppcond="27">ifdef</span> <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span></u></td></tr>
<tr><th id="28">28</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_GNUC_AT_MOST" data-ref="_M/EIGEN_GNUC_AT_MOST">EIGEN_GNUC_AT_MOST</dfn>(x,y) ((__GNUC__==x &amp;&amp; __GNUC_MINOR__&lt;=y) || __GNUC__&lt;x)</u></td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="27">else</span></u></td></tr>
<tr><th id="30">30</th><td>  <u>#define EIGEN_GNUC_AT_MOST(x,y) 0</u></td></tr>
<tr><th id="31">31</th><td><u>#<span data-ppcond="27">endif</span></u></td></tr>
<tr><th id="32">32</th><td></td></tr>
<tr><th id="33">33</th><td><u>#<span data-ppcond="33">if</span> <a class="macro" href="#28" title="((4==4 &amp;&amp; 2&lt;=3) || 4&lt;4)" data-ref="_M/EIGEN_GNUC_AT_MOST">EIGEN_GNUC_AT_MOST</a>(4,3) &amp;&amp; !defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>)</u></td></tr>
<tr><th id="34">34</th><td>  <i>// see bug 89</i></td></tr>
<tr><th id="35">35</th><td>  <u>#define EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO 0</u></td></tr>
<tr><th id="36">36</th><td><u>#<span data-ppcond="33">else</span></u></td></tr>
<tr><th id="37">37</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO" data-ref="_M/EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO">EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO</dfn> 1</u></td></tr>
<tr><th id="38">38</th><td><u>#<span data-ppcond="33">endif</span></u></td></tr>
<tr><th id="39">39</th><td></td></tr>
<tr><th id="40">40</th><td><u>#<span data-ppcond="40">if</span> defined(<span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>) &amp;&amp; (<span class="macro" title="4" data-ref="_M/__GNUC__">__GNUC__</span> &lt;= 3)</u></td></tr>
<tr><th id="41">41</th><td><u>#define EIGEN_GCC3_OR_OLDER 1</u></td></tr>
<tr><th id="42">42</th><td><u>#<span data-ppcond="40">else</span></u></td></tr>
<tr><th id="43">43</th><td><u>#define <dfn class="macro" id="_M/EIGEN_GCC3_OR_OLDER" data-ref="_M/EIGEN_GCC3_OR_OLDER">EIGEN_GCC3_OR_OLDER</dfn> 0</u></td></tr>
<tr><th id="44">44</th><td><u>#<span data-ppcond="40">endif</span></u></td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><i>// 16 byte alignment is only useful for vectorization. Since it affects the ABI, we need to enable</i></td></tr>
<tr><th id="47">47</th><td><i>// 16 byte alignment on all platforms where vectorization might be enabled. In theory we could always</i></td></tr>
<tr><th id="48">48</th><td><i>// enable alignment, but it can be a cause of problems on some platforms, so we just disable it in</i></td></tr>
<tr><th id="49">49</th><td><i>// certain common platform (compiler+architecture combinations) to avoid these problems.</i></td></tr>
<tr><th id="50">50</th><td><i>// Only static alignment is really problematic (relies on nonstandard compiler extensions that don't</i></td></tr>
<tr><th id="51">51</th><td><i>// work everywhere, for example don't work on GCC/ARM), try to keep heap alignment even</i></td></tr>
<tr><th id="52">52</th><td><i>// when we have to disable static alignment.</i></td></tr>
<tr><th id="53">53</th><td><u>#<span data-ppcond="53">if</span> defined(<span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>) &amp;&amp; !(defined(<span class="macro" data-ref="_M/__i386__">__i386__</span>) || defined(<span class="macro" data-ref="_M/__x86_64__">__x86_64__</span>) || defined(<span class="macro" data-ref="_M/__powerpc__">__powerpc__</span>) || defined(<span class="macro" data-ref="_M/__ppc__">__ppc__</span>) || defined(<span class="macro" data-ref="_M/__ia64__">__ia64__</span>))</u></td></tr>
<tr><th id="54">54</th><td><u>#define EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT 1</u></td></tr>
<tr><th id="55">55</th><td><u>#<span data-ppcond="53">else</span></u></td></tr>
<tr><th id="56">56</th><td><u>#define <dfn class="macro" id="_M/EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT" data-ref="_M/EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT">EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT</dfn> 0</u></td></tr>
<tr><th id="57">57</th><td><u>#<span data-ppcond="53">endif</span></u></td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><i>// static alignment is completely disabled with GCC 3, Sun Studio, and QCC/QNX</i></td></tr>
<tr><th id="60">60</th><td><u>#<span data-ppcond="60">if</span> !<a class="macro" href="#56" title="0" data-ref="_M/EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT">EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT</a> \</u></td></tr>
<tr><th id="61">61</th><td><u> &amp;&amp; !<a class="macro" href="#43" title="0" data-ref="_M/EIGEN_GCC3_OR_OLDER">EIGEN_GCC3_OR_OLDER</a> \</u></td></tr>
<tr><th id="62">62</th><td><u> &amp;&amp; !defined(<span class="macro" data-ref="_M/__SUNPRO_CC">__SUNPRO_CC</span>) \</u></td></tr>
<tr><th id="63">63</th><td><u> &amp;&amp; !defined(<span class="macro" data-ref="_M/__QNXNTO__">__QNXNTO__</span>)</u></td></tr>
<tr><th id="64">64</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_ARCH_WANTS_STACK_ALIGNMENT" data-ref="_M/EIGEN_ARCH_WANTS_STACK_ALIGNMENT">EIGEN_ARCH_WANTS_STACK_ALIGNMENT</dfn> 1</u></td></tr>
<tr><th id="65">65</th><td><u>#<span data-ppcond="60">else</span></u></td></tr>
<tr><th id="66">66</th><td>  <u>#define EIGEN_ARCH_WANTS_STACK_ALIGNMENT 0</u></td></tr>
<tr><th id="67">67</th><td><u>#<span data-ppcond="60">endif</span></u></td></tr>
<tr><th id="68">68</th><td></td></tr>
<tr><th id="69">69</th><td><u>#<span data-ppcond="69">ifdef</span> <span class="macro" data-ref="_M/EIGEN_DONT_ALIGN">EIGEN_DONT_ALIGN</span></u></td></tr>
<tr><th id="70">70</th><td>  <u>#ifndef EIGEN_DONT_ALIGN_STATICALLY</u></td></tr>
<tr><th id="71">71</th><td>    <u>#define EIGEN_DONT_ALIGN_STATICALLY</u></td></tr>
<tr><th id="72">72</th><td>  <u>#endif</u></td></tr>
<tr><th id="73">73</th><td>  <u>#define EIGEN_ALIGN 0</u></td></tr>
<tr><th id="74">74</th><td><u>#<span data-ppcond="69">else</span></u></td></tr>
<tr><th id="75">75</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_ALIGN" data-ref="_M/EIGEN_ALIGN">EIGEN_ALIGN</dfn> 1</u></td></tr>
<tr><th id="76">76</th><td><u>#<span data-ppcond="69">endif</span></u></td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td><i>// EIGEN_ALIGN_STATICALLY is the true test whether we want to align arrays on the stack or not. It takes into account both the user choice to explicitly disable</i></td></tr>
<tr><th id="79">79</th><td><i>// alignment (EIGEN_DONT_ALIGN_STATICALLY) and the architecture config (EIGEN_ARCH_WANTS_STACK_ALIGNMENT). Henceforth, only EIGEN_ALIGN_STATICALLY should be used.</i></td></tr>
<tr><th id="80">80</th><td><u>#<span data-ppcond="80">if</span> <a class="macro" href="#64" title="1" data-ref="_M/EIGEN_ARCH_WANTS_STACK_ALIGNMENT">EIGEN_ARCH_WANTS_STACK_ALIGNMENT</a> &amp;&amp; !defined(<span class="macro" data-ref="_M/EIGEN_DONT_ALIGN_STATICALLY">EIGEN_DONT_ALIGN_STATICALLY</span>)</u></td></tr>
<tr><th id="81">81</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_ALIGN_STATICALLY" data-ref="_M/EIGEN_ALIGN_STATICALLY">EIGEN_ALIGN_STATICALLY</dfn> 1</u></td></tr>
<tr><th id="82">82</th><td><u>#<span data-ppcond="80">else</span></u></td></tr>
<tr><th id="83">83</th><td>  <u>#define EIGEN_ALIGN_STATICALLY 0</u></td></tr>
<tr><th id="84">84</th><td>  <u>#ifndef EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT</u></td></tr>
<tr><th id="85">85</th><td>    <u>#define EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT</u></td></tr>
<tr><th id="86">86</th><td>  <u>#endif</u></td></tr>
<tr><th id="87">87</th><td><u>#<span data-ppcond="80">endif</span></u></td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td><u>#<span data-ppcond="89">ifdef</span> <span class="macro" data-ref="_M/EIGEN_DEFAULT_TO_ROW_MAJOR">EIGEN_DEFAULT_TO_ROW_MAJOR</span></u></td></tr>
<tr><th id="90">90</th><td><u>#define EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION RowMajor</u></td></tr>
<tr><th id="91">91</th><td><u>#<span data-ppcond="89">else</span></u></td></tr>
<tr><th id="92">92</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION" data-ref="_M/EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION">EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION</dfn> ColMajor</u></td></tr>
<tr><th id="93">93</th><td><u>#<span data-ppcond="89">endif</span></u></td></tr>
<tr><th id="94">94</th><td></td></tr>
<tr><th id="95">95</th><td><u>#<span data-ppcond="95">ifndef</span> <span class="macro" data-ref="_M/EIGEN_DEFAULT_DENSE_INDEX_TYPE">EIGEN_DEFAULT_DENSE_INDEX_TYPE</span></u></td></tr>
<tr><th id="96">96</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DEFAULT_DENSE_INDEX_TYPE" data-ref="_M/EIGEN_DEFAULT_DENSE_INDEX_TYPE">EIGEN_DEFAULT_DENSE_INDEX_TYPE</dfn> std::ptrdiff_t</u></td></tr>
<tr><th id="97">97</th><td><u>#<span data-ppcond="95">endif</span></u></td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td><i class="doc">/** Allows to disable some optimizations which might affect the accuracy of the result.</i></td></tr>
<tr><th id="100">100</th><td><i class="doc">  * Such optimization are enabled by default, and set EIGEN_FAST_MATH to 0 to disable them.</i></td></tr>
<tr><th id="101">101</th><td><i class="doc">  * They currently include:</i></td></tr>
<tr><th id="102">102</th><td><i class="doc">  *   - single precision Cwise::sin() and Cwise::cos() when SSE vectorization is enabled.</i></td></tr>
<tr><th id="103">103</th><td><i class="doc">  */</i></td></tr>
<tr><th id="104">104</th><td><u>#<span data-ppcond="104">ifndef</span> <span class="macro" data-ref="_M/EIGEN_FAST_MATH">EIGEN_FAST_MATH</span></u></td></tr>
<tr><th id="105">105</th><td><u>#define <dfn class="macro" id="_M/EIGEN_FAST_MATH" data-ref="_M/EIGEN_FAST_MATH">EIGEN_FAST_MATH</dfn> 1</u></td></tr>
<tr><th id="106">106</th><td><u>#<span data-ppcond="104">endif</span></u></td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DEBUG_VAR" data-ref="_M/EIGEN_DEBUG_VAR">EIGEN_DEBUG_VAR</dfn>(x) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endl;</u></td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><i>// concatenate two tokens</i></td></tr>
<tr><th id="111">111</th><td><u>#define <dfn class="macro" id="_M/EIGEN_CAT2" data-ref="_M/EIGEN_CAT2">EIGEN_CAT2</dfn>(a,b) a ## b</u></td></tr>
<tr><th id="112">112</th><td><u>#define <dfn class="macro" id="_M/EIGEN_CAT" data-ref="_M/EIGEN_CAT">EIGEN_CAT</dfn>(a,b) EIGEN_CAT2(a,b)</u></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i>// convert a token to a string</i></td></tr>
<tr><th id="115">115</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MAKESTRING2" data-ref="_M/EIGEN_MAKESTRING2">EIGEN_MAKESTRING2</dfn>(a) #a</u></td></tr>
<tr><th id="116">116</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MAKESTRING" data-ref="_M/EIGEN_MAKESTRING">EIGEN_MAKESTRING</dfn>(a) EIGEN_MAKESTRING2(a)</u></td></tr>
<tr><th id="117">117</th><td></td></tr>
<tr><th id="118">118</th><td><i>// EIGEN_STRONG_INLINE is a stronger version of the inline, using __forceinline on MSVC,</i></td></tr>
<tr><th id="119">119</th><td><i>// but it still doesn't use GCC's always_inline. This is useful in (common) situations where MSVC needs forceinline</i></td></tr>
<tr><th id="120">120</th><td><i>// but GCC is still doing fine with just inline.</i></td></tr>
<tr><th id="121">121</th><td><u>#<span data-ppcond="121">if</span> (defined <span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span>) || (defined <span class="macro" data-ref="_M/__INTEL_COMPILER">__INTEL_COMPILER</span>)</u></td></tr>
<tr><th id="122">122</th><td><u>#define EIGEN_STRONG_INLINE __forceinline</u></td></tr>
<tr><th id="123">123</th><td><u>#<span data-ppcond="121">else</span></u></td></tr>
<tr><th id="124">124</th><td><u>#define <dfn class="macro" id="_M/EIGEN_STRONG_INLINE" data-ref="_M/EIGEN_STRONG_INLINE">EIGEN_STRONG_INLINE</dfn> inline</u></td></tr>
<tr><th id="125">125</th><td><u>#<span data-ppcond="121">endif</span></u></td></tr>
<tr><th id="126">126</th><td></td></tr>
<tr><th id="127">127</th><td><i>// EIGEN_ALWAYS_INLINE is the stronget, it has the effect of making the function inline and adding every possible</i></td></tr>
<tr><th id="128">128</th><td><i>// attribute to maximize inlining. This should only be used when really necessary: in particular,</i></td></tr>
<tr><th id="129">129</th><td><i>// it uses __attribute__((always_inline)) on GCC, which most of the time is useless and can severely harm compile times.</i></td></tr>
<tr><th id="130">130</th><td><i>// FIXME with the always_inline attribute,</i></td></tr>
<tr><th id="131">131</th><td><i>// gcc 3.4.x reports the following compilation error:</i></td></tr>
<tr><th id="132">132</th><td><i>//   Eval.h:91: sorry, unimplemented: inlining failed in call to 'const Eigen::Eval&lt;Derived&gt; Eigen::MatrixBase&lt;Scalar, Derived&gt;::eval() const'</i></td></tr>
<tr><th id="133">133</th><td><i>//    : function body not available</i></td></tr>
<tr><th id="134">134</th><td><u>#<span data-ppcond="134">if</span> <a class="macro" href="#22" title="((4==4 &amp;&amp; 2&gt;=0) || 4&gt;4)" data-ref="_M/EIGEN_GNUC_AT_LEAST">EIGEN_GNUC_AT_LEAST</a>(4,0)</u></td></tr>
<tr><th id="135">135</th><td><u>#define <dfn class="macro" id="_M/EIGEN_ALWAYS_INLINE" data-ref="_M/EIGEN_ALWAYS_INLINE">EIGEN_ALWAYS_INLINE</dfn> __attribute__((always_inline)) inline</u></td></tr>
<tr><th id="136">136</th><td><u>#<span data-ppcond="134">else</span></u></td></tr>
<tr><th id="137">137</th><td><u>#define EIGEN_ALWAYS_INLINE EIGEN_STRONG_INLINE</u></td></tr>
<tr><th id="138">138</th><td><u>#<span data-ppcond="134">endif</span></u></td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td><u>#<span data-ppcond="140">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>)</u></td></tr>
<tr><th id="141">141</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DONT_INLINE" data-ref="_M/EIGEN_DONT_INLINE">EIGEN_DONT_INLINE</dfn> __attribute__((noinline))</u></td></tr>
<tr><th id="142">142</th><td><u>#<span data-ppcond="140">elif</span> (defined _MSC_VER)</u></td></tr>
<tr><th id="143">143</th><td><u>#define EIGEN_DONT_INLINE __declspec(noinline)</u></td></tr>
<tr><th id="144">144</th><td><u>#else</u></td></tr>
<tr><th id="145">145</th><td><u>#define EIGEN_DONT_INLINE</u></td></tr>
<tr><th id="146">146</th><td><u>#<span data-ppcond="140">endif</span></u></td></tr>
<tr><th id="147">147</th><td></td></tr>
<tr><th id="148">148</th><td><u>#<span data-ppcond="148">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>)</u></td></tr>
<tr><th id="149">149</th><td><u>#define <dfn class="macro" id="_M/EIGEN_PERMISSIVE_EXPR" data-ref="_M/EIGEN_PERMISSIVE_EXPR">EIGEN_PERMISSIVE_EXPR</dfn> __extension__</u></td></tr>
<tr><th id="150">150</th><td><u>#<span data-ppcond="148">else</span></u></td></tr>
<tr><th id="151">151</th><td><u>#define EIGEN_PERMISSIVE_EXPR</u></td></tr>
<tr><th id="152">152</th><td><u>#<span data-ppcond="148">endif</span></u></td></tr>
<tr><th id="153">153</th><td></td></tr>
<tr><th id="154">154</th><td><i>// this macro allows to get rid of linking errors about multiply defined functions.</i></td></tr>
<tr><th id="155">155</th><td><i>//  - static is not very good because it prevents definitions from different object files to be merged.</i></td></tr>
<tr><th id="156">156</th><td><i>//           So static causes the resulting linked executable to be bloated with multiple copies of the same function.</i></td></tr>
<tr><th id="157">157</th><td><i>//  - inline is not perfect either as it unwantedly hints the compiler toward inlining the function.</i></td></tr>
<tr><th id="158">158</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS" data-ref="_M/EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS">EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS</dfn></u></td></tr>
<tr><th id="159">159</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS" data-ref="_M/EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS">EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS</dfn> inline</u></td></tr>
<tr><th id="160">160</th><td></td></tr>
<tr><th id="161">161</th><td><u>#<span data-ppcond="161">ifdef</span> <span class="macro" data-ref="_M/NDEBUG">NDEBUG</span></u></td></tr>
<tr><th id="162">162</th><td><u># <span data-ppcond="162">ifndef</span> <span class="macro" data-ref="_M/EIGEN_NO_DEBUG">EIGEN_NO_DEBUG</span></u></td></tr>
<tr><th id="163">163</th><td><u>#  define <dfn class="macro" id="_M/EIGEN_NO_DEBUG" data-ref="_M/EIGEN_NO_DEBUG">EIGEN_NO_DEBUG</dfn></u></td></tr>
<tr><th id="164">164</th><td><u># <span data-ppcond="162">endif</span></u></td></tr>
<tr><th id="165">165</th><td><u>#<span data-ppcond="161">endif</span></u></td></tr>
<tr><th id="166">166</th><td></td></tr>
<tr><th id="167">167</th><td><i>// eigen_plain_assert is where we implement the workaround for the assert() bug in GCC &lt;= 4.3, see bug 89</i></td></tr>
<tr><th id="168">168</th><td><u>#<span data-ppcond="168">ifdef</span> <a class="macro" href="#163" data-ref="_M/EIGEN_NO_DEBUG">EIGEN_NO_DEBUG</a></u></td></tr>
<tr><th id="169">169</th><td>  <u>#define <dfn class="macro" id="_M/eigen_plain_assert" data-ref="_M/eigen_plain_assert">eigen_plain_assert</dfn>(x)</u></td></tr>
<tr><th id="170">170</th><td><u>#<span data-ppcond="168">else</span></u></td></tr>
<tr><th id="171">171</th><td>  <u>#if EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO</u></td></tr>
<tr><th id="172">172</th><td>    <b>namespace</b> Eigen {</td></tr>
<tr><th id="173">173</th><td>    <b>namespace</b> internal {</td></tr>
<tr><th id="174">174</th><td>    <b>inline</b> <em>bool</em> copy_bool(<em>bool</em> b) { <b>return</b> b; }</td></tr>
<tr><th id="175">175</th><td>    }</td></tr>
<tr><th id="176">176</th><td>    }</td></tr>
<tr><th id="177">177</th><td>    <u>#define eigen_plain_assert(x) assert(x)</u></td></tr>
<tr><th id="178">178</th><td>  <u>#else</u></td></tr>
<tr><th id="179">179</th><td>    <i>// work around bug 89</i></td></tr>
<tr><th id="180">180</th><td>    <u>#include &lt;cstdlib&gt;   // for abort</u></td></tr>
<tr><th id="181">181</th><td>    <u>#include &lt;iostream&gt;  // for std::cerr</u></td></tr>
<tr><th id="182">182</th><td></td></tr>
<tr><th id="183">183</th><td>    <b>namespace</b> Eigen {</td></tr>
<tr><th id="184">184</th><td>    <b>namespace</b> internal {</td></tr>
<tr><th id="185">185</th><td>    <i>// trivial function copying a bool. Must be EIGEN_DONT_INLINE, so we implement it after including Eigen headers.</i></td></tr>
<tr><th id="186">186</th><td><i>    // see bug 89.</i></td></tr>
<tr><th id="187">187</th><td>    <b>namespace</b> {</td></tr>
<tr><th id="188">188</th><td>    EIGEN_DONT_INLINE <em>bool</em> copy_bool(<em>bool</em> b) { <b>return</b> b; }</td></tr>
<tr><th id="189">189</th><td>    }</td></tr>
<tr><th id="190">190</th><td>    <b>inline</b> <em>void</em> assert_fail(<em>const</em> <em>char</em> *condition, <em>const</em> <em>char</em> *function, <em>const</em> <em>char</em> *file, <em>int</em> line)</td></tr>
<tr><th id="191">191</th><td>    {</td></tr>
<tr><th id="192">192</th><td>      std::cerr &lt;&lt; <q>"assertion failed: "</q> &lt;&lt; condition &lt;&lt; <q>" in function "</q> &lt;&lt; function &lt;&lt; <q>" at "</q> &lt;&lt; file &lt;&lt; <q>":"</q> &lt;&lt; line &lt;&lt; std::endl;</td></tr>
<tr><th id="193">193</th><td>      abort();</td></tr>
<tr><th id="194">194</th><td>    }</td></tr>
<tr><th id="195">195</th><td>    }</td></tr>
<tr><th id="196">196</th><td>    }</td></tr>
<tr><th id="197">197</th><td>    <u>#define eigen_plain_assert(x) \</u></td></tr>
<tr><th id="198">198</th><td><u>      do { \</u></td></tr>
<tr><th id="199">199</th><td><u>        if(!Eigen::internal::copy_bool(x)) \</u></td></tr>
<tr><th id="200">200</th><td><u>          Eigen::internal::assert_fail(EIGEN_MAKESTRING(x), __PRETTY_FUNCTION__, __FILE__, __LINE__); \</u></td></tr>
<tr><th id="201">201</th><td><u>      } while(false)</u></td></tr>
<tr><th id="202">202</th><td>  <u>#endif</u></td></tr>
<tr><th id="203">203</th><td><u>#<span data-ppcond="168">endif</span></u></td></tr>
<tr><th id="204">204</th><td></td></tr>
<tr><th id="205">205</th><td><i>// eigen_assert can be overridden</i></td></tr>
<tr><th id="206">206</th><td><u>#<span data-ppcond="206">ifndef</span> <span class="macro" data-ref="_M/eigen_assert">eigen_assert</span></u></td></tr>
<tr><th id="207">207</th><td><u>#define <dfn class="macro" id="_M/eigen_assert" data-ref="_M/eigen_assert">eigen_assert</dfn>(x) eigen_plain_assert(x)</u></td></tr>
<tr><th id="208">208</th><td><u>#<span data-ppcond="206">endif</span></u></td></tr>
<tr><th id="209">209</th><td></td></tr>
<tr><th id="210">210</th><td><u>#<span data-ppcond="210">ifdef</span> <span class="macro" data-ref="_M/EIGEN_INTERNAL_DEBUGGING">EIGEN_INTERNAL_DEBUGGING</span></u></td></tr>
<tr><th id="211">211</th><td><u>#define eigen_internal_assert(x) eigen_assert(x)</u></td></tr>
<tr><th id="212">212</th><td><u>#<span data-ppcond="210">else</span></u></td></tr>
<tr><th id="213">213</th><td><u>#define <dfn class="macro" id="_M/eigen_internal_assert" data-ref="_M/eigen_internal_assert">eigen_internal_assert</dfn>(x)</u></td></tr>
<tr><th id="214">214</th><td><u>#<span data-ppcond="210">endif</span></u></td></tr>
<tr><th id="215">215</th><td></td></tr>
<tr><th id="216">216</th><td><u>#<span data-ppcond="216">ifdef</span> <a class="macro" href="#163" data-ref="_M/EIGEN_NO_DEBUG">EIGEN_NO_DEBUG</a></u></td></tr>
<tr><th id="217">217</th><td><u>#define <dfn class="macro" id="_M/EIGEN_ONLY_USED_FOR_DEBUG" data-ref="_M/EIGEN_ONLY_USED_FOR_DEBUG">EIGEN_ONLY_USED_FOR_DEBUG</dfn>(x) (void)x</u></td></tr>
<tr><th id="218">218</th><td><u>#<span data-ppcond="216">else</span></u></td></tr>
<tr><th id="219">219</th><td><u>#define EIGEN_ONLY_USED_FOR_DEBUG(x)</u></td></tr>
<tr><th id="220">220</th><td><u>#<span data-ppcond="216">endif</span></u></td></tr>
<tr><th id="221">221</th><td></td></tr>
<tr><th id="222">222</th><td><u>#<span data-ppcond="222">ifndef</span> <span class="macro" data-ref="_M/EIGEN_NO_DEPRECATED_WARNING">EIGEN_NO_DEPRECATED_WARNING</span></u></td></tr>
<tr><th id="223">223</th><td>  <u>#<span data-ppcond="223">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>)</u></td></tr>
<tr><th id="224">224</th><td>    <u>#define <dfn class="macro" id="_M/EIGEN_DEPRECATED" data-ref="_M/EIGEN_DEPRECATED">EIGEN_DEPRECATED</dfn> __attribute__((deprecated))</u></td></tr>
<tr><th id="225">225</th><td>  <u>#<span data-ppcond="223">elif</span> (defined _MSC_VER)</u></td></tr>
<tr><th id="226">226</th><td>    <u>#define EIGEN_DEPRECATED __declspec(deprecated)</u></td></tr>
<tr><th id="227">227</th><td>  <u>#else</u></td></tr>
<tr><th id="228">228</th><td>    <u>#define EIGEN_DEPRECATED</u></td></tr>
<tr><th id="229">229</th><td>  <u>#<span data-ppcond="223">endif</span></u></td></tr>
<tr><th id="230">230</th><td><u>#<span data-ppcond="222">else</span></u></td></tr>
<tr><th id="231">231</th><td>  <u>#define EIGEN_DEPRECATED</u></td></tr>
<tr><th id="232">232</th><td><u>#<span data-ppcond="222">endif</span></u></td></tr>
<tr><th id="233">233</th><td></td></tr>
<tr><th id="234">234</th><td><u>#<span data-ppcond="234">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>)</u></td></tr>
<tr><th id="235">235</th><td><u>#define <dfn class="macro" id="_M/EIGEN_UNUSED" data-ref="_M/EIGEN_UNUSED">EIGEN_UNUSED</dfn> __attribute__((unused))</u></td></tr>
<tr><th id="236">236</th><td><u>#<span data-ppcond="234">else</span></u></td></tr>
<tr><th id="237">237</th><td><u>#define EIGEN_UNUSED</u></td></tr>
<tr><th id="238">238</th><td><u>#<span data-ppcond="234">endif</span></u></td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td><i>// Suppresses 'unused variable' warnings.</i></td></tr>
<tr><th id="241">241</th><td><u>#define <dfn class="macro" id="_M/EIGEN_UNUSED_VARIABLE" data-ref="_M/EIGEN_UNUSED_VARIABLE">EIGEN_UNUSED_VARIABLE</dfn>(var) (void)var;</u></td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td><u>#<span data-ppcond="243">if</span> !defined(<span class="macro" data-ref="_M/EIGEN_ASM_COMMENT">EIGEN_ASM_COMMENT</span>)</u></td></tr>
<tr><th id="244">244</th><td>  <u>#<span data-ppcond="244">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>) &amp;&amp; ( defined(<span class="macro" data-ref="_M/__i386__">__i386__</span>) || defined(<span class="macro" data-ref="_M/__x86_64__">__x86_64__</span>) )</u></td></tr>
<tr><th id="245">245</th><td>    <u>#define <dfn class="macro" id="_M/EIGEN_ASM_COMMENT" data-ref="_M/EIGEN_ASM_COMMENT">EIGEN_ASM_COMMENT</dfn>(X)  asm("#" X)</u></td></tr>
<tr><th id="246">246</th><td>  <u>#<span data-ppcond="244">else</span></u></td></tr>
<tr><th id="247">247</th><td>    <u>#define EIGEN_ASM_COMMENT(X)</u></td></tr>
<tr><th id="248">248</th><td>  <u>#<span data-ppcond="244">endif</span></u></td></tr>
<tr><th id="249">249</th><td><u>#<span data-ppcond="243">endif</span></u></td></tr>
<tr><th id="250">250</th><td></td></tr>
<tr><th id="251">251</th><td><i>/* EIGEN_ALIGN_TO_BOUNDARY(n) forces data to be n-byte aligned. This is used to satisfy SIMD requirements.</i></td></tr>
<tr><th id="252">252</th><td><i> * However, we do that EVEN if vectorization (EIGEN_VECTORIZE) is disabled,</i></td></tr>
<tr><th id="253">253</th><td><i> * so that vectorization doesn't affect binary compatibility.</i></td></tr>
<tr><th id="254">254</th><td><i> *</i></td></tr>
<tr><th id="255">255</th><td><i> * If we made alignment depend on whether or not EIGEN_VECTORIZE is defined, it would be impossible to link</i></td></tr>
<tr><th id="256">256</th><td><i> * vectorized and non-vectorized code.</i></td></tr>
<tr><th id="257">257</th><td><i> */</i></td></tr>
<tr><th id="258">258</th><td><u>#<span data-ppcond="258">if</span> (defined <span class="macro" data-ref="_M/__GNUC__">__GNUC__</span>) || (defined <span class="macro" data-ref="_M/__PGI">__PGI</span>) || (defined <span class="macro" data-ref="_M/__IBMCPP__">__IBMCPP__</span>) || (defined <span class="macro" data-ref="_M/__ARMCC_VERSION">__ARMCC_VERSION</span>)</u></td></tr>
<tr><th id="259">259</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_ALIGN_TO_BOUNDARY" data-ref="_M/EIGEN_ALIGN_TO_BOUNDARY">EIGEN_ALIGN_TO_BOUNDARY</dfn>(n) __attribute__((aligned(n)))</u></td></tr>
<tr><th id="260">260</th><td><u>#<span data-ppcond="258">elif</span> (defined _MSC_VER)</u></td></tr>
<tr><th id="261">261</th><td>  <u>#define EIGEN_ALIGN_TO_BOUNDARY(n) __declspec(align(n))</u></td></tr>
<tr><th id="262">262</th><td><u>#elif (defined __SUNPRO_CC)</u></td></tr>
<tr><th id="263">263</th><td>  <i>// FIXME not sure about this one:</i></td></tr>
<tr><th id="264">264</th><td>  <u>#define EIGEN_ALIGN_TO_BOUNDARY(n) __attribute__((aligned(n)))</u></td></tr>
<tr><th id="265">265</th><td><u>#else</u></td></tr>
<tr><th id="266">266</th><td>  <u>#error Please tell me what is the equivalent of __attribute__((aligned(n))) for your compiler</u></td></tr>
<tr><th id="267">267</th><td><u>#<span data-ppcond="258">endif</span></u></td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td><u>#define <dfn class="macro" id="_M/EIGEN_ALIGN16" data-ref="_M/EIGEN_ALIGN16">EIGEN_ALIGN16</dfn> EIGEN_ALIGN_TO_BOUNDARY(16)</u></td></tr>
<tr><th id="270">270</th><td></td></tr>
<tr><th id="271">271</th><td><u>#<span data-ppcond="271">if</span> <a class="macro" href="#81" title="1" data-ref="_M/EIGEN_ALIGN_STATICALLY">EIGEN_ALIGN_STATICALLY</a></u></td></tr>
<tr><th id="272">272</th><td><u>#define <dfn class="macro" id="_M/EIGEN_USER_ALIGN_TO_BOUNDARY" data-ref="_M/EIGEN_USER_ALIGN_TO_BOUNDARY">EIGEN_USER_ALIGN_TO_BOUNDARY</dfn>(n) EIGEN_ALIGN_TO_BOUNDARY(n)</u></td></tr>
<tr><th id="273">273</th><td><u>#define <dfn class="macro" id="_M/EIGEN_USER_ALIGN16" data-ref="_M/EIGEN_USER_ALIGN16">EIGEN_USER_ALIGN16</dfn> EIGEN_ALIGN16</u></td></tr>
<tr><th id="274">274</th><td><u>#<span data-ppcond="271">else</span></u></td></tr>
<tr><th id="275">275</th><td><u>#define EIGEN_USER_ALIGN_TO_BOUNDARY(n)</u></td></tr>
<tr><th id="276">276</th><td><u>#define EIGEN_USER_ALIGN16</u></td></tr>
<tr><th id="277">277</th><td><u>#<span data-ppcond="271">endif</span></u></td></tr>
<tr><th id="278">278</th><td></td></tr>
<tr><th id="279">279</th><td><u>#<span data-ppcond="279">ifdef</span> <span class="macro" data-ref="_M/EIGEN_DONT_USE_RESTRICT_KEYWORD">EIGEN_DONT_USE_RESTRICT_KEYWORD</span></u></td></tr>
<tr><th id="280">280</th><td>  <u>#define EIGEN_RESTRICT</u></td></tr>
<tr><th id="281">281</th><td><u>#<span data-ppcond="279">endif</span></u></td></tr>
<tr><th id="282">282</th><td><u>#<span data-ppcond="282">ifndef</span> <span class="macro" data-ref="_M/EIGEN_RESTRICT">EIGEN_RESTRICT</span></u></td></tr>
<tr><th id="283">283</th><td>  <u>#define <dfn class="macro" id="_M/EIGEN_RESTRICT" data-ref="_M/EIGEN_RESTRICT">EIGEN_RESTRICT</dfn> __restrict</u></td></tr>
<tr><th id="284">284</th><td><u>#<span data-ppcond="282">endif</span></u></td></tr>
<tr><th id="285">285</th><td></td></tr>
<tr><th id="286">286</th><td><u>#<span data-ppcond="286">ifndef</span> <span class="macro" data-ref="_M/EIGEN_STACK_ALLOCATION_LIMIT">EIGEN_STACK_ALLOCATION_LIMIT</span></u></td></tr>
<tr><th id="287">287</th><td><u>#define <dfn class="macro" id="_M/EIGEN_STACK_ALLOCATION_LIMIT" data-ref="_M/EIGEN_STACK_ALLOCATION_LIMIT">EIGEN_STACK_ALLOCATION_LIMIT</dfn> 20000</u></td></tr>
<tr><th id="288">288</th><td><u>#<span data-ppcond="286">endif</span></u></td></tr>
<tr><th id="289">289</th><td></td></tr>
<tr><th id="290">290</th><td><u>#<span data-ppcond="290">ifndef</span> <span class="macro" data-ref="_M/EIGEN_DEFAULT_IO_FORMAT">EIGEN_DEFAULT_IO_FORMAT</span></u></td></tr>
<tr><th id="291">291</th><td><u>#<span data-ppcond="291">ifdef</span> <span class="macro" data-ref="_M/EIGEN_MAKING_DOCS">EIGEN_MAKING_DOCS</span></u></td></tr>
<tr><th id="292">292</th><td><i>// format used in Eigen's documentation</i></td></tr>
<tr><th id="293">293</th><td><i>// needed to define it here as escaping characters in CMake add_definition's argument seems very problematic.</i></td></tr>
<tr><th id="294">294</th><td><u>#define EIGEN_DEFAULT_IO_FORMAT Eigen::IOFormat(3, 0, " ", "\n", "", "")</u></td></tr>
<tr><th id="295">295</th><td><u>#<span data-ppcond="291">else</span></u></td></tr>
<tr><th id="296">296</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DEFAULT_IO_FORMAT" data-ref="_M/EIGEN_DEFAULT_IO_FORMAT">EIGEN_DEFAULT_IO_FORMAT</dfn> Eigen::IOFormat()</u></td></tr>
<tr><th id="297">297</th><td><u>#<span data-ppcond="291">endif</span></u></td></tr>
<tr><th id="298">298</th><td><u>#<span data-ppcond="290">endif</span></u></td></tr>
<tr><th id="299">299</th><td></td></tr>
<tr><th id="300">300</th><td><i>// just an empty macro !</i></td></tr>
<tr><th id="301">301</th><td><u>#define <dfn class="macro" id="_M/EIGEN_EMPTY" data-ref="_M/EIGEN_EMPTY">EIGEN_EMPTY</dfn></u></td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><u>#<span data-ppcond="303">if</span> defined(<span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span>) &amp;&amp; (!defined(<span class="macro" data-ref="_M/__INTEL_COMPILER">__INTEL_COMPILER</span>))</u></td></tr>
<tr><th id="304">304</th><td><u>#define EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR(Derived) \</u></td></tr>
<tr><th id="305">305</th><td><u>  using Base::operator =;</u></td></tr>
<tr><th id="306">306</th><td><u>#<span data-ppcond="303">elif</span> defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>) // workaround clang bug (see http://forum.kde.org/viewtopic.php?f=74&amp;t=102653)</u></td></tr>
<tr><th id="307">307</th><td><u>#define <dfn class="macro" id="_M/EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR" data-ref="_M/EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR">EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR</dfn>(Derived) \</u></td></tr>
<tr><th id="308">308</th><td><u>  using Base::operator =; \</u></td></tr>
<tr><th id="309">309</th><td><u>  EIGEN_STRONG_INLINE Derived&amp; operator=(const Derived&amp; other) { Base::operator=(other); return *this; } \</u></td></tr>
<tr><th id="310">310</th><td><u>  template &lt;typename OtherDerived&gt; \</u></td></tr>
<tr><th id="311">311</th><td><u>  EIGEN_STRONG_INLINE Derived&amp; operator=(const DenseBase&lt;OtherDerived&gt;&amp; other) { Base::operator=(other.derived()); return *this; }</u></td></tr>
<tr><th id="312">312</th><td><u>#<span data-ppcond="303">else</span></u></td></tr>
<tr><th id="313">313</th><td><u>#define EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR(Derived) \</u></td></tr>
<tr><th id="314">314</th><td><u>  using Base::operator =; \</u></td></tr>
<tr><th id="315">315</th><td><u>  EIGEN_STRONG_INLINE Derived&amp; operator=(const Derived&amp; other) \</u></td></tr>
<tr><th id="316">316</th><td><u>  { \</u></td></tr>
<tr><th id="317">317</th><td><u>    Base::operator=(other); \</u></td></tr>
<tr><th id="318">318</th><td><u>    return *this; \</u></td></tr>
<tr><th id="319">319</th><td><u>  }</u></td></tr>
<tr><th id="320">320</th><td><u>#<span data-ppcond="303">endif</span></u></td></tr>
<tr><th id="321">321</th><td></td></tr>
<tr><th id="322">322</th><td><u>#define <dfn class="macro" id="_M/EIGEN_INHERIT_ASSIGNMENT_OPERATORS" data-ref="_M/EIGEN_INHERIT_ASSIGNMENT_OPERATORS">EIGEN_INHERIT_ASSIGNMENT_OPERATORS</dfn>(Derived) \</u></td></tr>
<tr><th id="323">323</th><td><u>  EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR(Derived)</u></td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><i class="doc">/**</i></td></tr>
<tr><th id="326">326</th><td><i class="doc">* Just a side note. Commenting within defines works only by documenting</i></td></tr>
<tr><th id="327">327</th><td><i class="doc">* behind the object (via '!&lt;'). Comments cannot be multi-line and thus</i></td></tr>
<tr><th id="328">328</th><td><i class="doc">* we have these extra long lines. What is confusing doxygen over here is</i></td></tr>
<tr><th id="329">329</th><td><i class="doc">* that we use '\' and basically have a bunch of typedefs with their</i></td></tr>
<tr><th id="330">330</th><td><i class="doc">* documentation in a single line.</i></td></tr>
<tr><th id="331">331</th><td><i class="doc">**/</i></td></tr>
<tr><th id="332">332</th><td></td></tr>
<tr><th id="333">333</th><td><u>#define <dfn class="macro" id="_M/EIGEN_GENERIC_PUBLIC_INTERFACE" data-ref="_M/EIGEN_GENERIC_PUBLIC_INTERFACE">EIGEN_GENERIC_PUBLIC_INTERFACE</dfn>(Derived) \</u></td></tr>
<tr><th id="334">334</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::Scalar Scalar; /*!&lt; \brief Numeric type, e.g. float, double, int or std::complex&lt;float&gt;. */ \</u></td></tr>
<tr><th id="335">335</th><td><u>  typedef typename Eigen::NumTraits&lt;Scalar&gt;::Real RealScalar; /*!&lt; \brief The underlying numeric type for composed scalar types. \details In cases where Scalar is e.g. std::complex&lt;T&gt;, T were corresponding to RealScalar. */ \</u></td></tr>
<tr><th id="336">336</th><td><u>  typedef typename Base::CoeffReturnType CoeffReturnType; /*!&lt; \brief The return type for coefficient access. \details Depending on whether the object allows direct coefficient access (e.g. for a MatrixXd), this type is either 'const Scalar&amp;' or simply 'Scalar' for objects that do not allow direct coefficient access. */ \</u></td></tr>
<tr><th id="337">337</th><td><u>  typedef typename Eigen::internal::nested&lt;Derived&gt;::type Nested; \</u></td></tr>
<tr><th id="338">338</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::StorageKind StorageKind; \</u></td></tr>
<tr><th id="339">339</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::Index Index; \</u></td></tr>
<tr><th id="340">340</th><td><u>  enum { RowsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::RowsAtCompileTime, \</u></td></tr>
<tr><th id="341">341</th><td><u>        ColsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::ColsAtCompileTime, \</u></td></tr>
<tr><th id="342">342</th><td><u>        Flags = Eigen::internal::traits&lt;Derived&gt;::Flags, \</u></td></tr>
<tr><th id="343">343</th><td><u>        CoeffReadCost = Eigen::internal::traits&lt;Derived&gt;::CoeffReadCost, \</u></td></tr>
<tr><th id="344">344</th><td><u>        SizeAtCompileTime = Base::SizeAtCompileTime, \</u></td></tr>
<tr><th id="345">345</th><td><u>        MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, \</u></td></tr>
<tr><th id="346">346</th><td><u>        IsVectorAtCompileTime = Base::IsVectorAtCompileTime };</u></td></tr>
<tr><th id="347">347</th><td></td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td><u>#define <dfn class="macro" id="_M/EIGEN_DENSE_PUBLIC_INTERFACE" data-ref="_M/EIGEN_DENSE_PUBLIC_INTERFACE">EIGEN_DENSE_PUBLIC_INTERFACE</dfn>(Derived) \</u></td></tr>
<tr><th id="350">350</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::Scalar Scalar; /*!&lt; \brief Numeric type, e.g. float, double, int or std::complex&lt;float&gt;. */ \</u></td></tr>
<tr><th id="351">351</th><td><u>  typedef typename Eigen::NumTraits&lt;Scalar&gt;::Real RealScalar; /*!&lt; \brief The underlying numeric type for composed scalar types. \details In cases where Scalar is e.g. std::complex&lt;T&gt;, T were corresponding to RealScalar. */ \</u></td></tr>
<tr><th id="352">352</th><td><u>  typedef typename Base::PacketScalar PacketScalar; \</u></td></tr>
<tr><th id="353">353</th><td><u>  typedef typename Base::CoeffReturnType CoeffReturnType; /*!&lt; \brief The return type for coefficient access. \details Depending on whether the object allows direct coefficient access (e.g. for a MatrixXd), this type is either 'const Scalar&amp;' or simply 'Scalar' for objects that do not allow direct coefficient access. */ \</u></td></tr>
<tr><th id="354">354</th><td><u>  typedef typename Eigen::internal::nested&lt;Derived&gt;::type Nested; \</u></td></tr>
<tr><th id="355">355</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::StorageKind StorageKind; \</u></td></tr>
<tr><th id="356">356</th><td><u>  typedef typename Eigen::internal::traits&lt;Derived&gt;::Index Index; \</u></td></tr>
<tr><th id="357">357</th><td><u>  enum { RowsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::RowsAtCompileTime, \</u></td></tr>
<tr><th id="358">358</th><td><u>        ColsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::ColsAtCompileTime, \</u></td></tr>
<tr><th id="359">359</th><td><u>        MaxRowsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::MaxRowsAtCompileTime, \</u></td></tr>
<tr><th id="360">360</th><td><u>        MaxColsAtCompileTime = Eigen::internal::traits&lt;Derived&gt;::MaxColsAtCompileTime, \</u></td></tr>
<tr><th id="361">361</th><td><u>        Flags = Eigen::internal::traits&lt;Derived&gt;::Flags, \</u></td></tr>
<tr><th id="362">362</th><td><u>        CoeffReadCost = Eigen::internal::traits&lt;Derived&gt;::CoeffReadCost, \</u></td></tr>
<tr><th id="363">363</th><td><u>        SizeAtCompileTime = Base::SizeAtCompileTime, \</u></td></tr>
<tr><th id="364">364</th><td><u>        MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, \</u></td></tr>
<tr><th id="365">365</th><td><u>        IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; \</u></td></tr>
<tr><th id="366">366</th><td><u>  using Base::derived; \</u></td></tr>
<tr><th id="367">367</th><td><u>  using Base::const_cast_derived;</u></td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td><u>#define <dfn class="macro" id="_M/EIGEN_PLAIN_ENUM_MIN" data-ref="_M/EIGEN_PLAIN_ENUM_MIN">EIGEN_PLAIN_ENUM_MIN</dfn>(a,b) (((int)a &lt;= (int)b) ? (int)a : (int)b)</u></td></tr>
<tr><th id="371">371</th><td><u>#define <dfn class="macro" id="_M/EIGEN_PLAIN_ENUM_MAX" data-ref="_M/EIGEN_PLAIN_ENUM_MAX">EIGEN_PLAIN_ENUM_MAX</dfn>(a,b) (((int)a &gt;= (int)b) ? (int)a : (int)b)</u></td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td><i>// EIGEN_SIZE_MIN_PREFER_DYNAMIC gives the min between compile-time sizes. 0 has absolute priority, followed by 1,</i></td></tr>
<tr><th id="374">374</th><td><i>// followed by Dynamic, followed by other finite values. The reason for giving Dynamic the priority over</i></td></tr>
<tr><th id="375">375</th><td><i>// finite values is that min(3, Dynamic) should be Dynamic, since that could be anything between 0 and 3.</i></td></tr>
<tr><th id="376">376</th><td><u>#define <dfn class="macro" id="_M/EIGEN_SIZE_MIN_PREFER_DYNAMIC" data-ref="_M/EIGEN_SIZE_MIN_PREFER_DYNAMIC">EIGEN_SIZE_MIN_PREFER_DYNAMIC</dfn>(a,b) (((int)a == 0 || (int)b == 0) ? 0 \</u></td></tr>
<tr><th id="377">377</th><td><u>                           : ((int)a == 1 || (int)b == 1) ? 1 \</u></td></tr>
<tr><th id="378">378</th><td><u>                           : ((int)a == Dynamic || (int)b == Dynamic) ? Dynamic \</u></td></tr>
<tr><th id="379">379</th><td><u>                           : ((int)a &lt;= (int)b) ? (int)a : (int)b)</u></td></tr>
<tr><th id="380">380</th><td></td></tr>
<tr><th id="381">381</th><td><i>// EIGEN_SIZE_MIN_PREFER_FIXED is a variant of EIGEN_SIZE_MIN_PREFER_DYNAMIC comparing MaxSizes. The difference is that finite values</i></td></tr>
<tr><th id="382">382</th><td><i>// now have priority over Dynamic, so that min(3, Dynamic) gives 3. Indeed, whatever the actual value is</i></td></tr>
<tr><th id="383">383</th><td><i>// (between 0 and 3), it is not more than 3.</i></td></tr>
<tr><th id="384">384</th><td><u>#define <dfn class="macro" id="_M/EIGEN_SIZE_MIN_PREFER_FIXED" data-ref="_M/EIGEN_SIZE_MIN_PREFER_FIXED">EIGEN_SIZE_MIN_PREFER_FIXED</dfn>(a,b)  (((int)a == 0 || (int)b == 0) ? 0 \</u></td></tr>
<tr><th id="385">385</th><td><u>                           : ((int)a == 1 || (int)b == 1) ? 1 \</u></td></tr>
<tr><th id="386">386</th><td><u>                           : ((int)a == Dynamic &amp;&amp; (int)b == Dynamic) ? Dynamic \</u></td></tr>
<tr><th id="387">387</th><td><u>                           : ((int)a == Dynamic) ? (int)b \</u></td></tr>
<tr><th id="388">388</th><td><u>                           : ((int)b == Dynamic) ? (int)a \</u></td></tr>
<tr><th id="389">389</th><td><u>                           : ((int)a &lt;= (int)b) ? (int)a : (int)b)</u></td></tr>
<tr><th id="390">390</th><td></td></tr>
<tr><th id="391">391</th><td><i>// see EIGEN_SIZE_MIN_PREFER_DYNAMIC. No need for a separate variant for MaxSizes here.</i></td></tr>
<tr><th id="392">392</th><td><u>#define <dfn class="macro" id="_M/EIGEN_SIZE_MAX" data-ref="_M/EIGEN_SIZE_MAX">EIGEN_SIZE_MAX</dfn>(a,b) (((int)a == Dynamic || (int)b == Dynamic) ? Dynamic \</u></td></tr>
<tr><th id="393">393</th><td><u>                           : ((int)a &gt;= (int)b) ? (int)a : (int)b)</u></td></tr>
<tr><th id="394">394</th><td></td></tr>
<tr><th id="395">395</th><td><u>#define <dfn class="macro" id="_M/EIGEN_LOGICAL_XOR" data-ref="_M/EIGEN_LOGICAL_XOR">EIGEN_LOGICAL_XOR</dfn>(a,b) (((a) || (b)) &amp;&amp; !((a) &amp;&amp; (b)))</u></td></tr>
<tr><th id="396">396</th><td></td></tr>
<tr><th id="397">397</th><td><u>#define <dfn class="macro" id="_M/EIGEN_IMPLIES" data-ref="_M/EIGEN_IMPLIES">EIGEN_IMPLIES</dfn>(a,b) (!(a) || (b))</u></td></tr>
<tr><th id="398">398</th><td></td></tr>
<tr><th id="399">399</th><td><u>#define <dfn class="macro" id="_M/EIGEN_MAKE_CWISE_BINARY_OP" data-ref="_M/EIGEN_MAKE_CWISE_BINARY_OP">EIGEN_MAKE_CWISE_BINARY_OP</dfn>(METHOD,FUNCTOR) \</u></td></tr>
<tr><th id="400">400</th><td><u>  template&lt;typename OtherDerived&gt; \</u></td></tr>
<tr><th id="401">401</th><td><u>  EIGEN_STRONG_INLINE const CwiseBinaryOp&lt;FUNCTOR&lt;Scalar&gt;, const Derived, const OtherDerived&gt; \</u></td></tr>
<tr><th id="402">402</th><td><u>  (METHOD)(const EIGEN_CURRENT_STORAGE_BASE_CLASS&lt;OtherDerived&gt; &amp;other) const \</u></td></tr>
<tr><th id="403">403</th><td><u>  { \</u></td></tr>
<tr><th id="404">404</th><td><u>    return CwiseBinaryOp&lt;FUNCTOR&lt;Scalar&gt;, const Derived, const OtherDerived&gt;(derived(), other.derived()); \</u></td></tr>
<tr><th id="405">405</th><td><u>  }</u></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td><i>// the expression type of a cwise product</i></td></tr>
<tr><th id="408">408</th><td><u>#define <dfn class="macro" id="_M/EIGEN_CWISE_PRODUCT_RETURN_TYPE" data-ref="_M/EIGEN_CWISE_PRODUCT_RETURN_TYPE">EIGEN_CWISE_PRODUCT_RETURN_TYPE</dfn>(LHS,RHS) \</u></td></tr>
<tr><th id="409">409</th><td><u>    CwiseBinaryOp&lt; \</u></td></tr>
<tr><th id="410">410</th><td><u>      internal::scalar_product_op&lt; \</u></td></tr>
<tr><th id="411">411</th><td><u>          typename internal::traits&lt;LHS&gt;::Scalar, \</u></td></tr>
<tr><th id="412">412</th><td><u>          typename internal::traits&lt;RHS&gt;::Scalar \</u></td></tr>
<tr><th id="413">413</th><td><u>      &gt;, \</u></td></tr>
<tr><th id="414">414</th><td><u>      const LHS, \</u></td></tr>
<tr><th id="415">415</th><td><u>      const RHS \</u></td></tr>
<tr><th id="416">416</th><td><u>    &gt;</u></td></tr>
<tr><th id="417">417</th><td></td></tr>
<tr><th id="418">418</th><td><u>#<span data-ppcond="11">endif</span> // EIGEN_MACROS_H</u></td></tr>
<tr><th id="419">419</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../../../ceres-solver/examples/bal_problem.cc.html'>ceres-solver/examples/bal_problem.cc</a><br/>Generated on <em>2017-May-11</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
