<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>types.h source code [ceres-solver/include/ceres/types.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="ceres::CallbackReturnType,ceres::CovarianceAlgorithmType,ceres::DenseLinearAlgebraLibraryType,ceres::DimensionType,ceres::DoglegType,ceres::DumpFormatType,ceres::LineSearchDirectionType,ceres::LineSearchInterpolationType,ceres::LineSearchType,ceres::LinearSolverType,ceres::LoggingType,ceres::MinimizerType,ceres::NonlinearConjugateGradientType,ceres::NumericDiffMethodType,ceres::Ownership,ceres::PreconditionerType,ceres::SparseLinearAlgebraLibraryType,ceres::TerminationType,ceres::TrustRegionStrategyType,ceres::VisibilityClusteringType "/>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'ceres-solver/include/ceres/types.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>ceres-solver</a>/<a href='..'>include</a>/<a href='./'>ceres</a>/<a href='types.h.html'>types.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>// Ceres Solver - A fast non-linear least squares minimizer</i></td></tr>
<tr><th id="2">2</th><td><i>// Copyright 2015 Google Inc. All rights reserved.</i></td></tr>
<tr><th id="3">3</th><td><i>// <a href="http://ceres-solver.org/">http://ceres-solver.org/</a></i></td></tr>
<tr><th id="4">4</th><td><i>//</i></td></tr>
<tr><th id="5">5</th><td><i>// Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="6">6</th><td><i>// modification, are permitted provided that the following conditions are met:</i></td></tr>
<tr><th id="7">7</th><td><i>//</i></td></tr>
<tr><th id="8">8</th><td><i>// * Redistributions of source code must retain the above copyright notice,</i></td></tr>
<tr><th id="9">9</th><td><i>//   this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="10">10</th><td><i>// * Redistributions in binary form must reproduce the above copyright notice,</i></td></tr>
<tr><th id="11">11</th><td><i>//   this list of conditions and the following disclaimer in the documentation</i></td></tr>
<tr><th id="12">12</th><td><i>//   and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="13">13</th><td><i>// * Neither the name of Google Inc. nor the names of its contributors may be</i></td></tr>
<tr><th id="14">14</th><td><i>//   used to endorse or promote products derived from this software without</i></td></tr>
<tr><th id="15">15</th><td><i>//   specific prior written permission.</i></td></tr>
<tr><th id="16">16</th><td><i>//</i></td></tr>
<tr><th id="17">17</th><td><i>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</i></td></tr>
<tr><th id="18">18</th><td><i>// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="19">19</th><td><i>// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="20">20</th><td><i>// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</i></td></tr>
<tr><th id="21">21</th><td><i>// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</i></td></tr>
<tr><th id="22">22</th><td><i>// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</i></td></tr>
<tr><th id="23">23</th><td><i>// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</i></td></tr>
<tr><th id="24">24</th><td><i>// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</i></td></tr>
<tr><th id="25">25</th><td><i>// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</i></td></tr>
<tr><th id="26">26</th><td><i>// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</i></td></tr>
<tr><th id="27">27</th><td><i>// POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="28">28</th><td><i>//</i></td></tr>
<tr><th id="29">29</th><td><i>// Author: sameeragarwal@google.com (Sameer Agarwal)</i></td></tr>
<tr><th id="30">30</th><td><i>//</i></td></tr>
<tr><th id="31">31</th><td><i>// Enums and other top level class definitions.</i></td></tr>
<tr><th id="32">32</th><td><i>//</i></td></tr>
<tr><th id="33">33</th><td><i>// Note: internal/types.cc defines stringification routines for some</i></td></tr>
<tr><th id="34">34</th><td><i>// of these enums. Please update those routines if you extend or</i></td></tr>
<tr><th id="35">35</th><td><i>// remove enums from here.</i></td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><u>#<span data-ppcond="37">ifndef</span> <span class="macro" data-ref="_M/CERES_PUBLIC_TYPES_H_">CERES_PUBLIC_TYPES_H_</span></u></td></tr>
<tr><th id="38">38</th><td><u>#define <dfn class="macro" id="_M/CERES_PUBLIC_TYPES_H_" data-ref="_M/CERES_PUBLIC_TYPES_H_">CERES_PUBLIC_TYPES_H_</dfn></u></td></tr>
<tr><th id="39">39</th><td></td></tr>
<tr><th id="40">40</th><td><u>#include <a href="../../../include/c++/4.8/string.html">&lt;string&gt;</a></u></td></tr>
<tr><th id="41">41</th><td></td></tr>
<tr><th id="42">42</th><td><u>#include <a href="internal/port.h.html">"ceres/internal/port.h"</a></u></td></tr>
<tr><th id="43">43</th><td><u>#include <a href="internal/disable_warnings.h.html">"ceres/internal/disable_warnings.h"</a></u></td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td><b>namespace</b> <span class="namespace">ceres</span> {</td></tr>
<tr><th id="46">46</th><td></td></tr>
<tr><th id="47">47</th><td><i>// Basic integer types. These typedefs are in the Ceres namespace to avoid</i></td></tr>
<tr><th id="48">48</th><td><i>// conflicts with other packages having similar typedefs.</i></td></tr>
<tr><th id="49">49</th><td><b>typedef</b> <em>int</em>   <dfn class="typedef" id="ceres::int32" title='ceres::int32' data-type='int' data-ref="ceres::int32">int32</dfn>;</td></tr>
<tr><th id="50">50</th><td></td></tr>
<tr><th id="51">51</th><td><i>// Argument type used in interfaces that can optionally take ownership</i></td></tr>
<tr><th id="52">52</th><td><i>// of a passed in argument. If TAKE_OWNERSHIP is passed, the called</i></td></tr>
<tr><th id="53">53</th><td><i>// object takes ownership of the pointer argument, and will call</i></td></tr>
<tr><th id="54">54</th><td><i>// delete on it upon completion.</i></td></tr>
<tr><th id="55">55</th><td><b>enum</b> <dfn class="type def" id="ceres::Ownership" title='ceres::Ownership' data-ref="ceres::Ownership">Ownership</dfn> {</td></tr>
<tr><th id="56">56</th><td>  <dfn class="enum" id="ceres::Ownership::DO_NOT_TAKE_OWNERSHIP" title='ceres::Ownership::DO_NOT_TAKE_OWNERSHIP' data-ref="ceres::Ownership::DO_NOT_TAKE_OWNERSHIP">DO_NOT_TAKE_OWNERSHIP</dfn>,</td></tr>
<tr><th id="57">57</th><td>  <dfn class="enum" id="ceres::Ownership::TAKE_OWNERSHIP" title='ceres::Ownership::TAKE_OWNERSHIP' data-ref="ceres::Ownership::TAKE_OWNERSHIP">TAKE_OWNERSHIP</dfn></td></tr>
<tr><th id="58">58</th><td>};</td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td><i>// TODO(keir): Considerably expand the explanations of each solver type.</i></td></tr>
<tr><th id="61">61</th><td><b>enum</b> <dfn class="type def" id="ceres::LinearSolverType" title='ceres::LinearSolverType' data-ref="ceres::LinearSolverType">LinearSolverType</dfn> {</td></tr>
<tr><th id="62">62</th><td>  <i>// These solvers are for general rectangular systems formed from the</i></td></tr>
<tr><th id="63">63</th><td><i>  // normal equations A'A x = A'b. They are direct solvers and do not</i></td></tr>
<tr><th id="64">64</th><td><i>  // assume any special problem structure.</i></td></tr>
<tr><th id="65">65</th><td><i></i></td></tr>
<tr><th id="66">66</th><td><i>  // Solve the normal equations using a dense Cholesky solver; based</i></td></tr>
<tr><th id="67">67</th><td><i>  // on Eigen.</i></td></tr>
<tr><th id="68">68</th><td>  <dfn class="enum" id="ceres::LinearSolverType::DENSE_NORMAL_CHOLESKY" title='ceres::LinearSolverType::DENSE_NORMAL_CHOLESKY' data-ref="ceres::LinearSolverType::DENSE_NORMAL_CHOLESKY">DENSE_NORMAL_CHOLESKY</dfn>,</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td>  <i>// Solve the normal equations using a dense QR solver; based on</i></td></tr>
<tr><th id="71">71</th><td><i>  // Eigen.</i></td></tr>
<tr><th id="72">72</th><td>  <dfn class="enum" id="ceres::LinearSolverType::DENSE_QR" title='ceres::LinearSolverType::DENSE_QR' data-ref="ceres::LinearSolverType::DENSE_QR">DENSE_QR</dfn>,</td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td>  <i>// Solve the normal equations using a sparse cholesky solver; requires</i></td></tr>
<tr><th id="75">75</th><td><i>  // SuiteSparse or CXSparse.</i></td></tr>
<tr><th id="76">76</th><td>  <dfn class="enum" id="ceres::LinearSolverType::SPARSE_NORMAL_CHOLESKY" title='ceres::LinearSolverType::SPARSE_NORMAL_CHOLESKY' data-ref="ceres::LinearSolverType::SPARSE_NORMAL_CHOLESKY">SPARSE_NORMAL_CHOLESKY</dfn>,</td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td>  <i>// Specialized solvers, specific to problems with a generalized</i></td></tr>
<tr><th id="79">79</th><td><i>  // bi-partitite structure.</i></td></tr>
<tr><th id="80">80</th><td><i></i></td></tr>
<tr><th id="81">81</th><td><i>  // Solves the reduced linear system using a dense Cholesky solver;</i></td></tr>
<tr><th id="82">82</th><td><i>  // based on Eigen.</i></td></tr>
<tr><th id="83">83</th><td>  <dfn class="enum" id="ceres::LinearSolverType::DENSE_SCHUR" title='ceres::LinearSolverType::DENSE_SCHUR' data-ref="ceres::LinearSolverType::DENSE_SCHUR">DENSE_SCHUR</dfn>,</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td>  <i>// Solves the reduced linear system using a sparse Cholesky solver;</i></td></tr>
<tr><th id="86">86</th><td><i>  // based on CHOLMOD.</i></td></tr>
<tr><th id="87">87</th><td>  <dfn class="enum" id="ceres::LinearSolverType::SPARSE_SCHUR" title='ceres::LinearSolverType::SPARSE_SCHUR' data-ref="ceres::LinearSolverType::SPARSE_SCHUR">SPARSE_SCHUR</dfn>,</td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td>  <i>// Solves the reduced linear system using Conjugate Gradients, based</i></td></tr>
<tr><th id="90">90</th><td><i>  // on a new Ceres implementation.  Suitable for large scale</i></td></tr>
<tr><th id="91">91</th><td><i>  // problems.</i></td></tr>
<tr><th id="92">92</th><td>  <dfn class="enum" id="ceres::LinearSolverType::ITERATIVE_SCHUR" title='ceres::LinearSolverType::ITERATIVE_SCHUR' data-ref="ceres::LinearSolverType::ITERATIVE_SCHUR">ITERATIVE_SCHUR</dfn>,</td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td>  <i>// Conjugate gradients on the normal equations.</i></td></tr>
<tr><th id="95">95</th><td>  <dfn class="enum" id="ceres::LinearSolverType::CGNR" title='ceres::LinearSolverType::CGNR' data-ref="ceres::LinearSolverType::CGNR">CGNR</dfn></td></tr>
<tr><th id="96">96</th><td>};</td></tr>
<tr><th id="97">97</th><td></td></tr>
<tr><th id="98">98</th><td><b>enum</b> <dfn class="type def" id="ceres::PreconditionerType" title='ceres::PreconditionerType' data-ref="ceres::PreconditionerType">PreconditionerType</dfn> {</td></tr>
<tr><th id="99">99</th><td>  <i>// Trivial preconditioner - the identity matrix.</i></td></tr>
<tr><th id="100">100</th><td>  <dfn class="enum" id="ceres::PreconditionerType::IDENTITY" title='ceres::PreconditionerType::IDENTITY' data-ref="ceres::PreconditionerType::IDENTITY">IDENTITY</dfn>,</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td>  <i>// Block diagonal of the Gauss-Newton Hessian.</i></td></tr>
<tr><th id="103">103</th><td>  <dfn class="enum" id="ceres::PreconditionerType::JACOBI" title='ceres::PreconditionerType::JACOBI' data-ref="ceres::PreconditionerType::JACOBI">JACOBI</dfn>,</td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td>  <i>// Note: The following three preconditioners can only be used with</i></td></tr>
<tr><th id="106">106</th><td><i>  // the ITERATIVE_SCHUR solver. They are well suited for Structure</i></td></tr>
<tr><th id="107">107</th><td><i>  // from Motion problems.</i></td></tr>
<tr><th id="108">108</th><td><i></i></td></tr>
<tr><th id="109">109</th><td><i>  // Block diagonal of the Schur complement. This preconditioner may</i></td></tr>
<tr><th id="110">110</th><td><i>  // only be used with the ITERATIVE_SCHUR solver.</i></td></tr>
<tr><th id="111">111</th><td>  <dfn class="enum" id="ceres::PreconditionerType::SCHUR_JACOBI" title='ceres::PreconditionerType::SCHUR_JACOBI' data-ref="ceres::PreconditionerType::SCHUR_JACOBI">SCHUR_JACOBI</dfn>,</td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td>  <i>// Visibility clustering based preconditioners.</i></td></tr>
<tr><th id="114">114</th><td><i>  //</i></td></tr>
<tr><th id="115">115</th><td><i>  // The following two preconditioners use the visibility structure of</i></td></tr>
<tr><th id="116">116</th><td><i>  // the scene to determine the sparsity structure of the</i></td></tr>
<tr><th id="117">117</th><td><i>  // preconditioner. This is done using a clustering algorithm. The</i></td></tr>
<tr><th id="118">118</th><td><i>  // available visibility clustering algorithms are described below.</i></td></tr>
<tr><th id="119">119</th><td><i>  //</i></td></tr>
<tr><th id="120">120</th><td><i>  // Note: Requires SuiteSparse.</i></td></tr>
<tr><th id="121">121</th><td>  <dfn class="enum" id="ceres::PreconditionerType::CLUSTER_JACOBI" title='ceres::PreconditionerType::CLUSTER_JACOBI' data-ref="ceres::PreconditionerType::CLUSTER_JACOBI">CLUSTER_JACOBI</dfn>,</td></tr>
<tr><th id="122">122</th><td>  <dfn class="enum" id="ceres::PreconditionerType::CLUSTER_TRIDIAGONAL" title='ceres::PreconditionerType::CLUSTER_TRIDIAGONAL' data-ref="ceres::PreconditionerType::CLUSTER_TRIDIAGONAL">CLUSTER_TRIDIAGONAL</dfn></td></tr>
<tr><th id="123">123</th><td>};</td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><b>enum</b> <dfn class="type def" id="ceres::VisibilityClusteringType" title='ceres::VisibilityClusteringType' data-ref="ceres::VisibilityClusteringType">VisibilityClusteringType</dfn> {</td></tr>
<tr><th id="126">126</th><td>  <i>// Canonical views algorithm as described in</i></td></tr>
<tr><th id="127">127</th><td><i>  //</i></td></tr>
<tr><th id="128">128</th><td><i>  // "Scene Summarization for Online Image Collections", Ian Simon, Noah</i></td></tr>
<tr><th id="129">129</th><td><i>  // Snavely, Steven M. Seitz, ICCV 2007.</i></td></tr>
<tr><th id="130">130</th><td><i>  //</i></td></tr>
<tr><th id="131">131</th><td><i>  // This clustering algorithm can be quite slow, but gives high</i></td></tr>
<tr><th id="132">132</th><td><i>  // quality clusters. The original visibility based clustering paper</i></td></tr>
<tr><th id="133">133</th><td><i>  // used this algorithm.</i></td></tr>
<tr><th id="134">134</th><td>  <dfn class="enum" id="ceres::VisibilityClusteringType::CANONICAL_VIEWS" title='ceres::VisibilityClusteringType::CANONICAL_VIEWS' data-ref="ceres::VisibilityClusteringType::CANONICAL_VIEWS">CANONICAL_VIEWS</dfn>,</td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td>  <i>// The classic single linkage algorithm. It is extremely fast as</i></td></tr>
<tr><th id="137">137</th><td><i>  // compared to CANONICAL_VIEWS, but can give slightly poorer</i></td></tr>
<tr><th id="138">138</th><td><i>  // results. For problems with large number of cameras though, this</i></td></tr>
<tr><th id="139">139</th><td><i>  // is generally a pretty good option.</i></td></tr>
<tr><th id="140">140</th><td><i>  //</i></td></tr>
<tr><th id="141">141</th><td><i>  // If you are using SCHUR_JACOBI preconditioner and have SuiteSparse</i></td></tr>
<tr><th id="142">142</th><td><i>  // available, CLUSTER_JACOBI and CLUSTER_TRIDIAGONAL in combination</i></td></tr>
<tr><th id="143">143</th><td><i>  // with the SINGLE_LINKAGE algorithm will generally give better</i></td></tr>
<tr><th id="144">144</th><td><i>  // results.</i></td></tr>
<tr><th id="145">145</th><td>  <dfn class="enum" id="ceres::VisibilityClusteringType::SINGLE_LINKAGE" title='ceres::VisibilityClusteringType::SINGLE_LINKAGE' data-ref="ceres::VisibilityClusteringType::SINGLE_LINKAGE">SINGLE_LINKAGE</dfn></td></tr>
<tr><th id="146">146</th><td>};</td></tr>
<tr><th id="147">147</th><td></td></tr>
<tr><th id="148">148</th><td><b>enum</b> <dfn class="type def" id="ceres::SparseLinearAlgebraLibraryType" title='ceres::SparseLinearAlgebraLibraryType' data-ref="ceres::SparseLinearAlgebraLibraryType">SparseLinearAlgebraLibraryType</dfn> {</td></tr>
<tr><th id="149">149</th><td>  <i>// High performance sparse Cholesky factorization and approximate</i></td></tr>
<tr><th id="150">150</th><td><i>  // minimum degree ordering.</i></td></tr>
<tr><th id="151">151</th><td>  <dfn class="enum" id="ceres::SparseLinearAlgebraLibraryType::SUITE_SPARSE" title='ceres::SparseLinearAlgebraLibraryType::SUITE_SPARSE' data-ref="ceres::SparseLinearAlgebraLibraryType::SUITE_SPARSE">SUITE_SPARSE</dfn>,</td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td>  <i>// A lightweight replacment for SuiteSparse, which does not require</i></td></tr>
<tr><th id="154">154</th><td><i>  // a LAPACK/BLAS implementation. Consequently, its performance is</i></td></tr>
<tr><th id="155">155</th><td><i>  // also a bit lower than SuiteSparse.</i></td></tr>
<tr><th id="156">156</th><td>  <dfn class="enum" id="ceres::SparseLinearAlgebraLibraryType::CX_SPARSE" title='ceres::SparseLinearAlgebraLibraryType::CX_SPARSE' data-ref="ceres::SparseLinearAlgebraLibraryType::CX_SPARSE">CX_SPARSE</dfn>,</td></tr>
<tr><th id="157">157</th><td></td></tr>
<tr><th id="158">158</th><td>  <i>// Eigen's sparse linear algebra routines. In particular Ceres uses</i></td></tr>
<tr><th id="159">159</th><td><i>  // the Simplicial LDLT routines.</i></td></tr>
<tr><th id="160">160</th><td>  <dfn class="enum" id="ceres::SparseLinearAlgebraLibraryType::EIGEN_SPARSE" title='ceres::SparseLinearAlgebraLibraryType::EIGEN_SPARSE' data-ref="ceres::SparseLinearAlgebraLibraryType::EIGEN_SPARSE">EIGEN_SPARSE</dfn>,</td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td>  <i>// No sparse linear solver should be used.  This does not necessarily</i></td></tr>
<tr><th id="163">163</th><td><i>  // imply that Ceres was built without any sparse library, although that</i></td></tr>
<tr><th id="164">164</th><td><i>  // is the likely use case, merely that one should not be used.</i></td></tr>
<tr><th id="165">165</th><td>  <dfn class="enum" id="ceres::SparseLinearAlgebraLibraryType::NO_SPARSE" title='ceres::SparseLinearAlgebraLibraryType::NO_SPARSE' data-ref="ceres::SparseLinearAlgebraLibraryType::NO_SPARSE">NO_SPARSE</dfn></td></tr>
<tr><th id="166">166</th><td>};</td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td><b>enum</b> <dfn class="type def" id="ceres::DenseLinearAlgebraLibraryType" title='ceres::DenseLinearAlgebraLibraryType' data-ref="ceres::DenseLinearAlgebraLibraryType">DenseLinearAlgebraLibraryType</dfn> {</td></tr>
<tr><th id="169">169</th><td>  <dfn class="enum" id="ceres::DenseLinearAlgebraLibraryType::EIGEN" title='ceres::DenseLinearAlgebraLibraryType::EIGEN' data-ref="ceres::DenseLinearAlgebraLibraryType::EIGEN">EIGEN</dfn>,</td></tr>
<tr><th id="170">170</th><td>  <dfn class="enum" id="ceres::DenseLinearAlgebraLibraryType::LAPACK" title='ceres::DenseLinearAlgebraLibraryType::LAPACK' data-ref="ceres::DenseLinearAlgebraLibraryType::LAPACK">LAPACK</dfn></td></tr>
<tr><th id="171">171</th><td>};</td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td><i>// Logging options</i></td></tr>
<tr><th id="174">174</th><td><i>// The options get progressively noisier.</i></td></tr>
<tr><th id="175">175</th><td><b>enum</b> <dfn class="type def" id="ceres::LoggingType" title='ceres::LoggingType' data-ref="ceres::LoggingType">LoggingType</dfn> {</td></tr>
<tr><th id="176">176</th><td>  <dfn class="enum" id="ceres::LoggingType::SILENT" title='ceres::LoggingType::SILENT' data-ref="ceres::LoggingType::SILENT">SILENT</dfn>,</td></tr>
<tr><th id="177">177</th><td>  <dfn class="enum" id="ceres::LoggingType::PER_MINIMIZER_ITERATION" title='ceres::LoggingType::PER_MINIMIZER_ITERATION' data-ref="ceres::LoggingType::PER_MINIMIZER_ITERATION">PER_MINIMIZER_ITERATION</dfn></td></tr>
<tr><th id="178">178</th><td>};</td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><b>enum</b> <dfn class="type def" id="ceres::MinimizerType" title='ceres::MinimizerType' data-ref="ceres::MinimizerType">MinimizerType</dfn> {</td></tr>
<tr><th id="181">181</th><td>  <dfn class="enum" id="ceres::MinimizerType::LINE_SEARCH" title='ceres::MinimizerType::LINE_SEARCH' data-ref="ceres::MinimizerType::LINE_SEARCH">LINE_SEARCH</dfn>,</td></tr>
<tr><th id="182">182</th><td>  <dfn class="enum" id="ceres::MinimizerType::TRUST_REGION" title='ceres::MinimizerType::TRUST_REGION' data-ref="ceres::MinimizerType::TRUST_REGION">TRUST_REGION</dfn></td></tr>
<tr><th id="183">183</th><td>};</td></tr>
<tr><th id="184">184</th><td></td></tr>
<tr><th id="185">185</th><td><b>enum</b> <dfn class="type def" id="ceres::LineSearchDirectionType" title='ceres::LineSearchDirectionType' data-ref="ceres::LineSearchDirectionType">LineSearchDirectionType</dfn> {</td></tr>
<tr><th id="186">186</th><td>  <i>// Negative of the gradient.</i></td></tr>
<tr><th id="187">187</th><td>  <dfn class="enum" id="ceres::LineSearchDirectionType::STEEPEST_DESCENT" title='ceres::LineSearchDirectionType::STEEPEST_DESCENT' data-ref="ceres::LineSearchDirectionType::STEEPEST_DESCENT">STEEPEST_DESCENT</dfn>,</td></tr>
<tr><th id="188">188</th><td></td></tr>
<tr><th id="189">189</th><td>  <i>// A generalization of the Conjugate Gradient method to non-linear</i></td></tr>
<tr><th id="190">190</th><td><i>  // functions. The generalization can be performed in a number of</i></td></tr>
<tr><th id="191">191</th><td><i>  // different ways, resulting in a variety of search directions. The</i></td></tr>
<tr><th id="192">192</th><td><i>  // precise choice of the non-linear conjugate gradient algorithm</i></td></tr>
<tr><th id="193">193</th><td><i>  // used is determined by NonlinerConjuateGradientType.</i></td></tr>
<tr><th id="194">194</th><td>  <dfn class="enum" id="ceres::LineSearchDirectionType::NONLINEAR_CONJUGATE_GRADIENT" title='ceres::LineSearchDirectionType::NONLINEAR_CONJUGATE_GRADIENT' data-ref="ceres::LineSearchDirectionType::NONLINEAR_CONJUGATE_GRADIENT">NONLINEAR_CONJUGATE_GRADIENT</dfn>,</td></tr>
<tr><th id="195">195</th><td></td></tr>
<tr><th id="196">196</th><td>  <i>// BFGS, and it's limited memory approximation L-BFGS, are quasi-Newton</i></td></tr>
<tr><th id="197">197</th><td><i>  // algorithms that approximate the Hessian matrix by iteratively refining</i></td></tr>
<tr><th id="198">198</th><td><i>  // an initial estimate with rank-one updates using the gradient at each</i></td></tr>
<tr><th id="199">199</th><td><i>  // iteration. They are a generalisation of the Secant method and satisfy</i></td></tr>
<tr><th id="200">200</th><td><i>  // the Secant equation.  The Secant equation has an infinium of solutions</i></td></tr>
<tr><th id="201">201</th><td><i>  // in multiple dimensions, as there are N*(N+1)/2 degrees of freedom in a</i></td></tr>
<tr><th id="202">202</th><td><i>  // symmetric matrix but only N conditions are specified by the Secant</i></td></tr>
<tr><th id="203">203</th><td><i>  // equation. The requirement that the Hessian approximation be positive</i></td></tr>
<tr><th id="204">204</th><td><i>  // definite imposes another N additional constraints, but that still leaves</i></td></tr>
<tr><th id="205">205</th><td><i>  // remaining degrees-of-freedom.  (L)BFGS methods uniquely deteremine the</i></td></tr>
<tr><th id="206">206</th><td><i>  // approximate Hessian by imposing the additional constraints that the</i></td></tr>
<tr><th id="207">207</th><td><i>  // approximation at the next iteration must be the 'closest' to the current</i></td></tr>
<tr><th id="208">208</th><td><i>  // approximation (the nature of how this proximity is measured is actually</i></td></tr>
<tr><th id="209">209</th><td><i>  // the defining difference between a family of quasi-Newton methods including</i></td></tr>
<tr><th id="210">210</th><td><i>  // (L)BFGS &amp; DFP). (L)BFGS is currently regarded as being the best known</i></td></tr>
<tr><th id="211">211</th><td><i>  // general quasi-Newton method.</i></td></tr>
<tr><th id="212">212</th><td><i>  //</i></td></tr>
<tr><th id="213">213</th><td><i>  // The principal difference between BFGS and L-BFGS is that whilst BFGS</i></td></tr>
<tr><th id="214">214</th><td><i>  // maintains a full, dense approximation to the (inverse) Hessian, L-BFGS</i></td></tr>
<tr><th id="215">215</th><td><i>  // maintains only a window of the last M observations of the parameters and</i></td></tr>
<tr><th id="216">216</th><td><i>  // gradients. Using this observation history, the calculation of the next</i></td></tr>
<tr><th id="217">217</th><td><i>  // search direction can be computed without requiring the construction of the</i></td></tr>
<tr><th id="218">218</th><td><i>  // full dense inverse Hessian approximation. This is particularly important</i></td></tr>
<tr><th id="219">219</th><td><i>  // for problems with a large number of parameters, where storage of an N-by-N</i></td></tr>
<tr><th id="220">220</th><td><i>  // matrix in memory would be prohibitive.</i></td></tr>
<tr><th id="221">221</th><td><i>  //</i></td></tr>
<tr><th id="222">222</th><td><i>  // For more details on BFGS see:</i></td></tr>
<tr><th id="223">223</th><td><i>  //</i></td></tr>
<tr><th id="224">224</th><td><i>  // Broyden, C.G., "The Convergence of a Class of Double-rank Minimization</i></td></tr>
<tr><th id="225">225</th><td><i>  // Algorithms,"; J. Inst. Maths. Applics., Vol. 6, pp 76–90, 1970.</i></td></tr>
<tr><th id="226">226</th><td><i>  //</i></td></tr>
<tr><th id="227">227</th><td><i>  // Fletcher, R., "A New Approach to Variable Metric Algorithms,"</i></td></tr>
<tr><th id="228">228</th><td><i>  // Computer Journal, Vol. 13, pp 317–322, 1970.</i></td></tr>
<tr><th id="229">229</th><td><i>  //</i></td></tr>
<tr><th id="230">230</th><td><i>  // Goldfarb, D., "A Family of Variable Metric Updates Derived by Variational</i></td></tr>
<tr><th id="231">231</th><td><i>  // Means," Mathematics of Computing, Vol. 24, pp 23–26, 1970.</i></td></tr>
<tr><th id="232">232</th><td><i>  //</i></td></tr>
<tr><th id="233">233</th><td><i>  // Shanno, D.F., "Conditioning of Quasi-Newton Methods for Function</i></td></tr>
<tr><th id="234">234</th><td><i>  // Minimization," Mathematics of Computing, Vol. 24, pp 647–656, 1970.</i></td></tr>
<tr><th id="235">235</th><td><i>  //</i></td></tr>
<tr><th id="236">236</th><td><i>  // For more details on L-BFGS see:</i></td></tr>
<tr><th id="237">237</th><td><i>  //</i></td></tr>
<tr><th id="238">238</th><td><i>  // Nocedal, J. (1980). "Updating Quasi-Newton Matrices with Limited</i></td></tr>
<tr><th id="239">239</th><td><i>  // Storage". Mathematics of Computation 35 (151): 773–782.</i></td></tr>
<tr><th id="240">240</th><td><i>  //</i></td></tr>
<tr><th id="241">241</th><td><i>  // Byrd, R. H.; Nocedal, J.; Schnabel, R. B. (1994).</i></td></tr>
<tr><th id="242">242</th><td><i>  // "Representations of Quasi-Newton Matrices and their use in</i></td></tr>
<tr><th id="243">243</th><td><i>  // Limited Memory Methods". Mathematical Programming 63 (4):</i></td></tr>
<tr><th id="244">244</th><td><i>  // 129–156.</i></td></tr>
<tr><th id="245">245</th><td><i>  //</i></td></tr>
<tr><th id="246">246</th><td><i>  // A general reference for both methods:</i></td></tr>
<tr><th id="247">247</th><td><i>  //</i></td></tr>
<tr><th id="248">248</th><td><i>  // Nocedal J., Wright S., Numerical Optimization, 2nd Ed. Springer, 1999.</i></td></tr>
<tr><th id="249">249</th><td>  <dfn class="enum" id="ceres::LineSearchDirectionType::LBFGS" title='ceres::LineSearchDirectionType::LBFGS' data-ref="ceres::LineSearchDirectionType::LBFGS">LBFGS</dfn>,</td></tr>
<tr><th id="250">250</th><td>  <dfn class="enum" id="ceres::LineSearchDirectionType::BFGS" title='ceres::LineSearchDirectionType::BFGS' data-ref="ceres::LineSearchDirectionType::BFGS">BFGS</dfn>,</td></tr>
<tr><th id="251">251</th><td>};</td></tr>
<tr><th id="252">252</th><td></td></tr>
<tr><th id="253">253</th><td><i>// Nonliner conjugate gradient methods are a generalization of the</i></td></tr>
<tr><th id="254">254</th><td><i>// method of Conjugate Gradients for linear systems. The</i></td></tr>
<tr><th id="255">255</th><td><i>// generalization can be carried out in a number of different ways</i></td></tr>
<tr><th id="256">256</th><td><i>// leading to number of different rules for computing the search</i></td></tr>
<tr><th id="257">257</th><td><i>// direction. Ceres provides a number of different variants. For more</i></td></tr>
<tr><th id="258">258</th><td><i>// details see Numerical Optimization by Nocedal &amp; Wright.</i></td></tr>
<tr><th id="259">259</th><td><b>enum</b> <dfn class="type def" id="ceres::NonlinearConjugateGradientType" title='ceres::NonlinearConjugateGradientType' data-ref="ceres::NonlinearConjugateGradientType">NonlinearConjugateGradientType</dfn> {</td></tr>
<tr><th id="260">260</th><td>  <dfn class="enum" id="ceres::NonlinearConjugateGradientType::FLETCHER_REEVES" title='ceres::NonlinearConjugateGradientType::FLETCHER_REEVES' data-ref="ceres::NonlinearConjugateGradientType::FLETCHER_REEVES">FLETCHER_REEVES</dfn>,</td></tr>
<tr><th id="261">261</th><td>  <dfn class="enum" id="ceres::NonlinearConjugateGradientType::POLAK_RIBIERE" title='ceres::NonlinearConjugateGradientType::POLAK_RIBIERE' data-ref="ceres::NonlinearConjugateGradientType::POLAK_RIBIERE">POLAK_RIBIERE</dfn>,</td></tr>
<tr><th id="262">262</th><td>  <dfn class="enum" id="ceres::NonlinearConjugateGradientType::HESTENES_STIEFEL" title='ceres::NonlinearConjugateGradientType::HESTENES_STIEFEL' data-ref="ceres::NonlinearConjugateGradientType::HESTENES_STIEFEL">HESTENES_STIEFEL</dfn>,</td></tr>
<tr><th id="263">263</th><td>};</td></tr>
<tr><th id="264">264</th><td></td></tr>
<tr><th id="265">265</th><td><b>enum</b> <dfn class="type def" id="ceres::LineSearchType" title='ceres::LineSearchType' data-ref="ceres::LineSearchType">LineSearchType</dfn> {</td></tr>
<tr><th id="266">266</th><td>  <i>// Backtracking line search with polynomial interpolation or</i></td></tr>
<tr><th id="267">267</th><td><i>  // bisection.</i></td></tr>
<tr><th id="268">268</th><td>  <dfn class="enum" id="ceres::LineSearchType::ARMIJO" title='ceres::LineSearchType::ARMIJO' data-ref="ceres::LineSearchType::ARMIJO">ARMIJO</dfn>,</td></tr>
<tr><th id="269">269</th><td>  <dfn class="enum" id="ceres::LineSearchType::WOLFE" title='ceres::LineSearchType::WOLFE' data-ref="ceres::LineSearchType::WOLFE">WOLFE</dfn>,</td></tr>
<tr><th id="270">270</th><td>};</td></tr>
<tr><th id="271">271</th><td></td></tr>
<tr><th id="272">272</th><td><i>// Ceres supports different strategies for computing the trust region</i></td></tr>
<tr><th id="273">273</th><td><i>// step.</i></td></tr>
<tr><th id="274">274</th><td><b>enum</b> <dfn class="type def" id="ceres::TrustRegionStrategyType" title='ceres::TrustRegionStrategyType' data-ref="ceres::TrustRegionStrategyType">TrustRegionStrategyType</dfn> {</td></tr>
<tr><th id="275">275</th><td>  <i>// The default trust region strategy is to use the step computation</i></td></tr>
<tr><th id="276">276</th><td><i>  // used in the Levenberg-Marquardt algorithm. For more details see</i></td></tr>
<tr><th id="277">277</th><td><i>  // levenberg_marquardt_strategy.h</i></td></tr>
<tr><th id="278">278</th><td>  <dfn class="enum" id="ceres::TrustRegionStrategyType::LEVENBERG_MARQUARDT" title='ceres::TrustRegionStrategyType::LEVENBERG_MARQUARDT' data-ref="ceres::TrustRegionStrategyType::LEVENBERG_MARQUARDT">LEVENBERG_MARQUARDT</dfn>,</td></tr>
<tr><th id="279">279</th><td></td></tr>
<tr><th id="280">280</th><td>  <i>// Powell's dogleg algorithm interpolates between the Cauchy point</i></td></tr>
<tr><th id="281">281</th><td><i>  // and the Gauss-Newton step. It is particularly useful if the</i></td></tr>
<tr><th id="282">282</th><td><i>  // LEVENBERG_MARQUARDT algorithm is making a large number of</i></td></tr>
<tr><th id="283">283</th><td><i>  // unsuccessful steps. For more details see dogleg_strategy.h.</i></td></tr>
<tr><th id="284">284</th><td><i>  //</i></td></tr>
<tr><th id="285">285</th><td><i>  // NOTES:</i></td></tr>
<tr><th id="286">286</th><td><i>  //</i></td></tr>
<tr><th id="287">287</th><td><i>  // 1. This strategy has not been experimented with or tested as</i></td></tr>
<tr><th id="288">288</th><td><i>  // extensively as LEVENBERG_MARQUARDT, and therefore it should be</i></td></tr>
<tr><th id="289">289</th><td><i>  // considered EXPERIMENTAL for now.</i></td></tr>
<tr><th id="290">290</th><td><i>  //</i></td></tr>
<tr><th id="291">291</th><td><i>  // 2. For now this strategy should only be used with exact</i></td></tr>
<tr><th id="292">292</th><td><i>  // factorization based linear solvers, i.e., SPARSE_SCHUR,</i></td></tr>
<tr><th id="293">293</th><td><i>  // DENSE_SCHUR, DENSE_QR and SPARSE_NORMAL_CHOLESKY.</i></td></tr>
<tr><th id="294">294</th><td>  <dfn class="enum" id="ceres::TrustRegionStrategyType::DOGLEG" title='ceres::TrustRegionStrategyType::DOGLEG' data-ref="ceres::TrustRegionStrategyType::DOGLEG">DOGLEG</dfn></td></tr>
<tr><th id="295">295</th><td>};</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i>// Ceres supports two different dogleg strategies.</i></td></tr>
<tr><th id="298">298</th><td><i>// The "traditional" dogleg method by Powell and the</i></td></tr>
<tr><th id="299">299</th><td><i>// "subspace" method described in</i></td></tr>
<tr><th id="300">300</th><td><i>// R. H. Byrd, R. B. Schnabel, and G. A. Shultz,</i></td></tr>
<tr><th id="301">301</th><td><i>// "Approximate solution of the trust region problem by minimization</i></td></tr>
<tr><th id="302">302</th><td><i>//  over two-dimensional subspaces", Mathematical Programming,</i></td></tr>
<tr><th id="303">303</th><td><i>// 40 (1988), pp. 247--263</i></td></tr>
<tr><th id="304">304</th><td><b>enum</b> <dfn class="type def" id="ceres::DoglegType" title='ceres::DoglegType' data-ref="ceres::DoglegType">DoglegType</dfn> {</td></tr>
<tr><th id="305">305</th><td>  <i>// The traditional approach constructs a dogleg path</i></td></tr>
<tr><th id="306">306</th><td><i>  // consisting of two line segments and finds the furthest</i></td></tr>
<tr><th id="307">307</th><td><i>  // point on that path that is still inside the trust region.</i></td></tr>
<tr><th id="308">308</th><td>  <dfn class="enum" id="ceres::DoglegType::TRADITIONAL_DOGLEG" title='ceres::DoglegType::TRADITIONAL_DOGLEG' data-ref="ceres::DoglegType::TRADITIONAL_DOGLEG">TRADITIONAL_DOGLEG</dfn>,</td></tr>
<tr><th id="309">309</th><td></td></tr>
<tr><th id="310">310</th><td>  <i>// The subspace approach finds the exact minimum of the model</i></td></tr>
<tr><th id="311">311</th><td><i>  // constrained to the subspace spanned by the dogleg path.</i></td></tr>
<tr><th id="312">312</th><td>  <dfn class="enum" id="ceres::DoglegType::SUBSPACE_DOGLEG" title='ceres::DoglegType::SUBSPACE_DOGLEG' data-ref="ceres::DoglegType::SUBSPACE_DOGLEG">SUBSPACE_DOGLEG</dfn></td></tr>
<tr><th id="313">313</th><td>};</td></tr>
<tr><th id="314">314</th><td></td></tr>
<tr><th id="315">315</th><td><b>enum</b> <dfn class="type def" id="ceres::TerminationType" title='ceres::TerminationType' data-ref="ceres::TerminationType">TerminationType</dfn> {</td></tr>
<tr><th id="316">316</th><td>  <i>// Minimizer terminated because one of the convergence criterion set</i></td></tr>
<tr><th id="317">317</th><td><i>  // by the user was satisfied.</i></td></tr>
<tr><th id="318">318</th><td><i>  //</i></td></tr>
<tr><th id="319">319</th><td><i>  // 1.  (new_cost - old_cost) &lt; function_tolerance * old_cost;</i></td></tr>
<tr><th id="320">320</th><td><i>  // 2.  max_i |gradient_i| &lt; gradient_tolerance</i></td></tr>
<tr><th id="321">321</th><td><i>  // 3.  |step|_2 &lt;= parameter_tolerance * ( |x|_2 +  parameter_tolerance)</i></td></tr>
<tr><th id="322">322</th><td><i>  //</i></td></tr>
<tr><th id="323">323</th><td><i>  // The user's parameter blocks will be updated with the solution.</i></td></tr>
<tr><th id="324">324</th><td>  <dfn class="enum" id="ceres::TerminationType::CONVERGENCE" title='ceres::TerminationType::CONVERGENCE' data-ref="ceres::TerminationType::CONVERGENCE">CONVERGENCE</dfn>,</td></tr>
<tr><th id="325">325</th><td></td></tr>
<tr><th id="326">326</th><td>  <i>// The solver ran for maximum number of iterations or maximum amount</i></td></tr>
<tr><th id="327">327</th><td><i>  // of time specified by the user, but none of the convergence</i></td></tr>
<tr><th id="328">328</th><td><i>  // criterion specified by the user were met. The user's parameter</i></td></tr>
<tr><th id="329">329</th><td><i>  // blocks will be updated with the solution found so far.</i></td></tr>
<tr><th id="330">330</th><td>  <dfn class="enum" id="ceres::TerminationType::NO_CONVERGENCE" title='ceres::TerminationType::NO_CONVERGENCE' data-ref="ceres::TerminationType::NO_CONVERGENCE">NO_CONVERGENCE</dfn>,</td></tr>
<tr><th id="331">331</th><td></td></tr>
<tr><th id="332">332</th><td>  <i>// The minimizer terminated because of an error.  The user's</i></td></tr>
<tr><th id="333">333</th><td><i>  // parameter blocks will not be updated.</i></td></tr>
<tr><th id="334">334</th><td>  <dfn class="enum" id="ceres::TerminationType::FAILURE" title='ceres::TerminationType::FAILURE' data-ref="ceres::TerminationType::FAILURE">FAILURE</dfn>,</td></tr>
<tr><th id="335">335</th><td></td></tr>
<tr><th id="336">336</th><td>  <i>// Using an IterationCallback object, user code can control the</i></td></tr>
<tr><th id="337">337</th><td><i>  // minimizer. The following enums indicate that the user code was</i></td></tr>
<tr><th id="338">338</th><td><i>  // responsible for termination.</i></td></tr>
<tr><th id="339">339</th><td><i>  //</i></td></tr>
<tr><th id="340">340</th><td><i>  // Minimizer terminated successfully because a user</i></td></tr>
<tr><th id="341">341</th><td><i>  // IterationCallback returned SOLVER_TERMINATE_SUCCESSFULLY.</i></td></tr>
<tr><th id="342">342</th><td><i>  //</i></td></tr>
<tr><th id="343">343</th><td><i>  // The user's parameter blocks will be updated with the solution.</i></td></tr>
<tr><th id="344">344</th><td>  <dfn class="enum" id="ceres::TerminationType::USER_SUCCESS" title='ceres::TerminationType::USER_SUCCESS' data-ref="ceres::TerminationType::USER_SUCCESS">USER_SUCCESS</dfn>,</td></tr>
<tr><th id="345">345</th><td></td></tr>
<tr><th id="346">346</th><td>  <i>// Minimizer terminated because because a user IterationCallback</i></td></tr>
<tr><th id="347">347</th><td><i>  // returned SOLVER_ABORT.</i></td></tr>
<tr><th id="348">348</th><td><i>  //</i></td></tr>
<tr><th id="349">349</th><td><i>  // The user's parameter blocks will not be updated.</i></td></tr>
<tr><th id="350">350</th><td>  <dfn class="enum" id="ceres::TerminationType::USER_FAILURE" title='ceres::TerminationType::USER_FAILURE' data-ref="ceres::TerminationType::USER_FAILURE">USER_FAILURE</dfn></td></tr>
<tr><th id="351">351</th><td>};</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td><i>// Enums used by the IterationCallback instances to indicate to the</i></td></tr>
<tr><th id="354">354</th><td><i>// solver whether it should continue solving, the user detected an</i></td></tr>
<tr><th id="355">355</th><td><i>// error or the solution is good enough and the solver should</i></td></tr>
<tr><th id="356">356</th><td><i>// terminate.</i></td></tr>
<tr><th id="357">357</th><td><b>enum</b> <dfn class="type def" id="ceres::CallbackReturnType" title='ceres::CallbackReturnType' data-ref="ceres::CallbackReturnType">CallbackReturnType</dfn> {</td></tr>
<tr><th id="358">358</th><td>  <i>// Continue solving to next iteration.</i></td></tr>
<tr><th id="359">359</th><td>  <dfn class="enum" id="ceres::CallbackReturnType::SOLVER_CONTINUE" title='ceres::CallbackReturnType::SOLVER_CONTINUE' data-ref="ceres::CallbackReturnType::SOLVER_CONTINUE">SOLVER_CONTINUE</dfn>,</td></tr>
<tr><th id="360">360</th><td></td></tr>
<tr><th id="361">361</th><td>  <i>// Terminate solver, and do not update the parameter blocks upon</i></td></tr>
<tr><th id="362">362</th><td><i>  // return. Unless the user has set</i></td></tr>
<tr><th id="363">363</th><td><i>  // Solver:Options:::update_state_every_iteration, in which case the</i></td></tr>
<tr><th id="364">364</th><td><i>  // state would have been updated every iteration</i></td></tr>
<tr><th id="365">365</th><td><i>  // anyways. Solver::Summary::termination_type is set to USER_ABORT.</i></td></tr>
<tr><th id="366">366</th><td>  <dfn class="enum" id="ceres::CallbackReturnType::SOLVER_ABORT" title='ceres::CallbackReturnType::SOLVER_ABORT' data-ref="ceres::CallbackReturnType::SOLVER_ABORT">SOLVER_ABORT</dfn>,</td></tr>
<tr><th id="367">367</th><td></td></tr>
<tr><th id="368">368</th><td>  <i>// Terminate solver, update state and</i></td></tr>
<tr><th id="369">369</th><td><i>  // return. Solver::Summary::termination_type is set to USER_SUCCESS.</i></td></tr>
<tr><th id="370">370</th><td>  <dfn class="enum" id="ceres::CallbackReturnType::SOLVER_TERMINATE_SUCCESSFULLY" title='ceres::CallbackReturnType::SOLVER_TERMINATE_SUCCESSFULLY' data-ref="ceres::CallbackReturnType::SOLVER_TERMINATE_SUCCESSFULLY">SOLVER_TERMINATE_SUCCESSFULLY</dfn></td></tr>
<tr><th id="371">371</th><td>};</td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td><i>// The format in which linear least squares problems should be logged</i></td></tr>
<tr><th id="374">374</th><td><i>// when Solver::Options::lsqp_iterations_to_dump is non-empty.</i></td></tr>
<tr><th id="375">375</th><td><b>enum</b> <dfn class="type def" id="ceres::DumpFormatType" title='ceres::DumpFormatType' data-ref="ceres::DumpFormatType">DumpFormatType</dfn> {</td></tr>
<tr><th id="376">376</th><td>  <i>// Print the linear least squares problem in a human readable format</i></td></tr>
<tr><th id="377">377</th><td><i>  // to stderr. The Jacobian is printed as a dense matrix. The vectors</i></td></tr>
<tr><th id="378">378</th><td><i>  // D, x and f are printed as dense vectors. This should only be used</i></td></tr>
<tr><th id="379">379</th><td><i>  // for small problems.</i></td></tr>
<tr><th id="380">380</th><td>  <dfn class="enum" id="ceres::DumpFormatType::CONSOLE" title='ceres::DumpFormatType::CONSOLE' data-ref="ceres::DumpFormatType::CONSOLE">CONSOLE</dfn>,</td></tr>
<tr><th id="381">381</th><td></td></tr>
<tr><th id="382">382</th><td>  <i>// Write out the linear least squares problem to the directory</i></td></tr>
<tr><th id="383">383</th><td><i>  // pointed to by Solver::Options::lsqp_dump_directory as text files</i></td></tr>
<tr><th id="384">384</th><td><i>  // which can be read into MATLAB/Octave. The Jacobian is dumped as a</i></td></tr>
<tr><th id="385">385</th><td><i>  // text file containing (i,j,s) triplets, the vectors D, x and f are</i></td></tr>
<tr><th id="386">386</th><td><i>  // dumped as text files containing a list of their values.</i></td></tr>
<tr><th id="387">387</th><td><i>  //</i></td></tr>
<tr><th id="388">388</th><td><i>  // A MATLAB/octave script called lm_iteration_???.m is also output,</i></td></tr>
<tr><th id="389">389</th><td><i>  // which can be used to parse and load the problem into memory.</i></td></tr>
<tr><th id="390">390</th><td>  <dfn class="enum" id="ceres::DumpFormatType::TEXTFILE" title='ceres::DumpFormatType::TEXTFILE' data-ref="ceres::DumpFormatType::TEXTFILE">TEXTFILE</dfn></td></tr>
<tr><th id="391">391</th><td>};</td></tr>
<tr><th id="392">392</th><td></td></tr>
<tr><th id="393">393</th><td><i>// For SizedCostFunction and AutoDiffCostFunction, DYNAMIC can be</i></td></tr>
<tr><th id="394">394</th><td><i>// specified for the number of residuals. If specified, then the</i></td></tr>
<tr><th id="395">395</th><td><i>// number of residuas for that cost function can vary at runtime.</i></td></tr>
<tr><th id="396">396</th><td><b>enum</b> <dfn class="type def" id="ceres::DimensionType" title='ceres::DimensionType' data-ref="ceres::DimensionType">DimensionType</dfn> {</td></tr>
<tr><th id="397">397</th><td>  <dfn class="enum" id="ceres::DimensionType::DYNAMIC" title='ceres::DimensionType::DYNAMIC' data-ref="ceres::DimensionType::DYNAMIC">DYNAMIC</dfn> = -<var>1</var></td></tr>
<tr><th id="398">398</th><td>};</td></tr>
<tr><th id="399">399</th><td></td></tr>
<tr><th id="400">400</th><td><i>// The differentiation method used to compute numerical derivatives in</i></td></tr>
<tr><th id="401">401</th><td><i>// NumericDiffCostFunction and DynamicNumericDiffCostFunction.</i></td></tr>
<tr><th id="402">402</th><td><b>enum</b> <dfn class="type def" id="ceres::NumericDiffMethodType" title='ceres::NumericDiffMethodType' data-ref="ceres::NumericDiffMethodType">NumericDiffMethodType</dfn> {</td></tr>
<tr><th id="403">403</th><td>  <i>// Compute central finite difference: f'(x) ~ (f(x+h) - f(x-h)) / 2h.</i></td></tr>
<tr><th id="404">404</th><td>  <dfn class="enum" id="ceres::NumericDiffMethodType::CENTRAL" title='ceres::NumericDiffMethodType::CENTRAL' data-ref="ceres::NumericDiffMethodType::CENTRAL">CENTRAL</dfn>,</td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td>  <i>// Compute forward finite difference: f'(x) ~ (f(x+h) - f(x)) / h.</i></td></tr>
<tr><th id="407">407</th><td>  <dfn class="enum" id="ceres::NumericDiffMethodType::FORWARD" title='ceres::NumericDiffMethodType::FORWARD' data-ref="ceres::NumericDiffMethodType::FORWARD">FORWARD</dfn>,</td></tr>
<tr><th id="408">408</th><td></td></tr>
<tr><th id="409">409</th><td>  <i>// Adaptive numerical differentiation using Ridders' method. Provides more</i></td></tr>
<tr><th id="410">410</th><td><i>  // accurate and robust derivatives at the expense of additional cost</i></td></tr>
<tr><th id="411">411</th><td><i>  // function evaluations.</i></td></tr>
<tr><th id="412">412</th><td>  <dfn class="enum" id="ceres::NumericDiffMethodType::RIDDERS" title='ceres::NumericDiffMethodType::RIDDERS' data-ref="ceres::NumericDiffMethodType::RIDDERS">RIDDERS</dfn></td></tr>
<tr><th id="413">413</th><td>};</td></tr>
<tr><th id="414">414</th><td></td></tr>
<tr><th id="415">415</th><td><b>enum</b> <dfn class="type def" id="ceres::LineSearchInterpolationType" title='ceres::LineSearchInterpolationType' data-ref="ceres::LineSearchInterpolationType">LineSearchInterpolationType</dfn> {</td></tr>
<tr><th id="416">416</th><td>  <dfn class="enum" id="ceres::LineSearchInterpolationType::BISECTION" title='ceres::LineSearchInterpolationType::BISECTION' data-ref="ceres::LineSearchInterpolationType::BISECTION">BISECTION</dfn>,</td></tr>
<tr><th id="417">417</th><td>  <dfn class="enum" id="ceres::LineSearchInterpolationType::QUADRATIC" title='ceres::LineSearchInterpolationType::QUADRATIC' data-ref="ceres::LineSearchInterpolationType::QUADRATIC">QUADRATIC</dfn>,</td></tr>
<tr><th id="418">418</th><td>  <dfn class="enum" id="ceres::LineSearchInterpolationType::CUBIC" title='ceres::LineSearchInterpolationType::CUBIC' data-ref="ceres::LineSearchInterpolationType::CUBIC">CUBIC</dfn></td></tr>
<tr><th id="419">419</th><td>};</td></tr>
<tr><th id="420">420</th><td></td></tr>
<tr><th id="421">421</th><td><b>enum</b> <dfn class="type def" id="ceres::CovarianceAlgorithmType" title='ceres::CovarianceAlgorithmType' data-ref="ceres::CovarianceAlgorithmType">CovarianceAlgorithmType</dfn> {</td></tr>
<tr><th id="422">422</th><td>  <dfn class="enum" id="ceres::CovarianceAlgorithmType::DENSE_SVD" title='ceres::CovarianceAlgorithmType::DENSE_SVD' data-ref="ceres::CovarianceAlgorithmType::DENSE_SVD">DENSE_SVD</dfn>,</td></tr>
<tr><th id="423">423</th><td>  <dfn class="enum" id="ceres::CovarianceAlgorithmType::SPARSE_QR" title='ceres::CovarianceAlgorithmType::SPARSE_QR' data-ref="ceres::CovarianceAlgorithmType::SPARSE_QR">SPARSE_QR</dfn>,</td></tr>
<tr><th id="424">424</th><td>};</td></tr>
<tr><th id="425">425</th><td></td></tr>
<tr><th id="426">426</th><td><i>// It is a near impossibility that user code generates this exact</i></td></tr>
<tr><th id="427">427</th><td><i>// value in normal operation, thus we will use it to fill arrays</i></td></tr>
<tr><th id="428">428</th><td><i>// before passing them to user code. If on return an element of the</i></td></tr>
<tr><th id="429">429</th><td><i>// array still contains this value, we will assume that the user code</i></td></tr>
<tr><th id="430">430</th><td><i>// did not write to that memory location.</i></td></tr>
<tr><th id="431">431</th><td><em>const</em> <em>double</em> <dfn class="decl def" id="ceres::kImpossibleValue" title='ceres::kImpossibleValue' data-ref="ceres::kImpossibleValue">kImpossibleValue</dfn> = <var>1e302</var>;</td></tr>
<tr><th id="432">432</th><td></td></tr>
<tr><th id="433">433</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres24LinearSolverTypeToStringENS_16LinearSolverTypeE" title='ceres::LinearSolverTypeToString' data-ref="_ZN5ceres24LinearSolverTypeToStringENS_16LinearSolverTypeE">LinearSolverTypeToString</dfn>(</td></tr>
<tr><th id="434">434</th><td>    <a class="type" href="#ceres::LinearSolverType" title='ceres::LinearSolverType' data-ref="ceres::LinearSolverType">LinearSolverType</a> <dfn class="local col9 decl" id="389type" title='type' data-type='ceres::LinearSolverType' data-ref="389type">type</dfn>);</td></tr>
<tr><th id="435">435</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres24StringToLinearSolverTypeESsPNS_16LinearSolverTypeE" title='ceres::StringToLinearSolverType' data-ref="_ZN5ceres24StringToLinearSolverTypeESsPNS_16LinearSolverTypeE">StringToLinearSolverType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col0 decl" id="390value" title='value' data-type='std::string' data-ref="390value">value</dfn>,</td></tr>
<tr><th id="436">436</th><td>                                           <a class="type" href="#ceres::LinearSolverType" title='ceres::LinearSolverType' data-ref="ceres::LinearSolverType">LinearSolverType</a>* <dfn class="local col1 decl" id="391type" title='type' data-type='ceres::LinearSolverType *' data-ref="391type">type</dfn>);</td></tr>
<tr><th id="437">437</th><td></td></tr>
<tr><th id="438">438</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres26PreconditionerTypeToStringENS_18PreconditionerTypeE" title='ceres::PreconditionerTypeToString' data-ref="_ZN5ceres26PreconditionerTypeToStringENS_18PreconditionerTypeE">PreconditionerTypeToString</dfn>(<a class="type" href="#ceres::PreconditionerType" title='ceres::PreconditionerType' data-ref="ceres::PreconditionerType">PreconditionerType</a> <dfn class="local col2 decl" id="392type" title='type' data-type='ceres::PreconditionerType' data-ref="392type">type</dfn>);</td></tr>
<tr><th id="439">439</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres26StringToPreconditionerTypeESsPNS_18PreconditionerTypeE" title='ceres::StringToPreconditionerType' data-ref="_ZN5ceres26StringToPreconditionerTypeESsPNS_18PreconditionerTypeE">StringToPreconditionerType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col3 decl" id="393value" title='value' data-type='std::string' data-ref="393value">value</dfn>,</td></tr>
<tr><th id="440">440</th><td>                                             <a class="type" href="#ceres::PreconditionerType" title='ceres::PreconditionerType' data-ref="ceres::PreconditionerType">PreconditionerType</a>* <dfn class="local col4 decl" id="394type" title='type' data-type='ceres::PreconditionerType *' data-ref="394type">type</dfn>);</td></tr>
<tr><th id="441">441</th><td></td></tr>
<tr><th id="442">442</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres32VisibilityClusteringTypeToStringENS_24VisibilityClusteringTypeE" title='ceres::VisibilityClusteringTypeToString' data-ref="_ZN5ceres32VisibilityClusteringTypeToStringENS_24VisibilityClusteringTypeE">VisibilityClusteringTypeToString</dfn>(</td></tr>
<tr><th id="443">443</th><td>    <a class="type" href="#ceres::VisibilityClusteringType" title='ceres::VisibilityClusteringType' data-ref="ceres::VisibilityClusteringType">VisibilityClusteringType</a> <dfn class="local col5 decl" id="395type" title='type' data-type='ceres::VisibilityClusteringType' data-ref="395type">type</dfn>);</td></tr>
<tr><th id="444">444</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres32StringToVisibilityClusteringTypeESsPNS_24VisibilityClusteringTypeE" title='ceres::StringToVisibilityClusteringType' data-ref="_ZN5ceres32StringToVisibilityClusteringTypeESsPNS_24VisibilityClusteringTypeE">StringToVisibilityClusteringType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col6 decl" id="396value" title='value' data-type='std::string' data-ref="396value">value</dfn>,</td></tr>
<tr><th id="445">445</th><td>                                      <a class="type" href="#ceres::VisibilityClusteringType" title='ceres::VisibilityClusteringType' data-ref="ceres::VisibilityClusteringType">VisibilityClusteringType</a>* <dfn class="local col7 decl" id="397type" title='type' data-type='ceres::VisibilityClusteringType *' data-ref="397type">type</dfn>);</td></tr>
<tr><th id="446">446</th><td></td></tr>
<tr><th id="447">447</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres38SparseLinearAlgebraLibraryTypeToStringENS_30SparseLinearAlgebraLibraryTypeE" title='ceres::SparseLinearAlgebraLibraryTypeToString' data-ref="_ZN5ceres38SparseLinearAlgebraLibraryTypeToStringENS_30SparseLinearAlgebraLibraryTypeE">SparseLinearAlgebraLibraryTypeToString</dfn>(</td></tr>
<tr><th id="448">448</th><td>    <a class="type" href="#ceres::SparseLinearAlgebraLibraryType" title='ceres::SparseLinearAlgebraLibraryType' data-ref="ceres::SparseLinearAlgebraLibraryType">SparseLinearAlgebraLibraryType</a> <dfn class="local col8 decl" id="398type" title='type' data-type='ceres::SparseLinearAlgebraLibraryType' data-ref="398type">type</dfn>);</td></tr>
<tr><th id="449">449</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres38StringToSparseLinearAlgebraLibraryTypeESsPNS_30SparseLinearAlgebraLibraryTypeE" title='ceres::StringToSparseLinearAlgebraLibraryType' data-ref="_ZN5ceres38StringToSparseLinearAlgebraLibraryTypeESsPNS_30SparseLinearAlgebraLibraryTypeE">StringToSparseLinearAlgebraLibraryType</dfn>(</td></tr>
<tr><th id="450">450</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col9 decl" id="399value" title='value' data-type='std::string' data-ref="399value">value</dfn>,</td></tr>
<tr><th id="451">451</th><td>    <a class="type" href="#ceres::SparseLinearAlgebraLibraryType" title='ceres::SparseLinearAlgebraLibraryType' data-ref="ceres::SparseLinearAlgebraLibraryType">SparseLinearAlgebraLibraryType</a>* <dfn class="local col0 decl" id="400type" title='type' data-type='ceres::SparseLinearAlgebraLibraryType *' data-ref="400type">type</dfn>);</td></tr>
<tr><th id="452">452</th><td></td></tr>
<tr><th id="453">453</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres37DenseLinearAlgebraLibraryTypeToStringENS_29DenseLinearAlgebraLibraryTypeE" title='ceres::DenseLinearAlgebraLibraryTypeToString' data-ref="_ZN5ceres37DenseLinearAlgebraLibraryTypeToStringENS_29DenseLinearAlgebraLibraryTypeE">DenseLinearAlgebraLibraryTypeToString</dfn>(</td></tr>
<tr><th id="454">454</th><td>    <a class="type" href="#ceres::DenseLinearAlgebraLibraryType" title='ceres::DenseLinearAlgebraLibraryType' data-ref="ceres::DenseLinearAlgebraLibraryType">DenseLinearAlgebraLibraryType</a> <dfn class="local col1 decl" id="401type" title='type' data-type='ceres::DenseLinearAlgebraLibraryType' data-ref="401type">type</dfn>);</td></tr>
<tr><th id="455">455</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres37StringToDenseLinearAlgebraLibraryTypeESsPNS_29DenseLinearAlgebraLibraryTypeE" title='ceres::StringToDenseLinearAlgebraLibraryType' data-ref="_ZN5ceres37StringToDenseLinearAlgebraLibraryTypeESsPNS_29DenseLinearAlgebraLibraryTypeE">StringToDenseLinearAlgebraLibraryType</dfn>(</td></tr>
<tr><th id="456">456</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col2 decl" id="402value" title='value' data-type='std::string' data-ref="402value">value</dfn>,</td></tr>
<tr><th id="457">457</th><td>    <a class="type" href="#ceres::DenseLinearAlgebraLibraryType" title='ceres::DenseLinearAlgebraLibraryType' data-ref="ceres::DenseLinearAlgebraLibraryType">DenseLinearAlgebraLibraryType</a>* <dfn class="local col3 decl" id="403type" title='type' data-type='ceres::DenseLinearAlgebraLibraryType *' data-ref="403type">type</dfn>);</td></tr>
<tr><th id="458">458</th><td></td></tr>
<tr><th id="459">459</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres31TrustRegionStrategyTypeToStringENS_23TrustRegionStrategyTypeE" title='ceres::TrustRegionStrategyTypeToString' data-ref="_ZN5ceres31TrustRegionStrategyTypeToStringENS_23TrustRegionStrategyTypeE">TrustRegionStrategyTypeToString</dfn>(</td></tr>
<tr><th id="460">460</th><td>    <a class="type" href="#ceres::TrustRegionStrategyType" title='ceres::TrustRegionStrategyType' data-ref="ceres::TrustRegionStrategyType">TrustRegionStrategyType</a> <dfn class="local col4 decl" id="404type" title='type' data-type='ceres::TrustRegionStrategyType' data-ref="404type">type</dfn>);</td></tr>
<tr><th id="461">461</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres31StringToTrustRegionStrategyTypeESsPNS_23TrustRegionStrategyTypeE" title='ceres::StringToTrustRegionStrategyType' data-ref="_ZN5ceres31StringToTrustRegionStrategyTypeESsPNS_23TrustRegionStrategyTypeE">StringToTrustRegionStrategyType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col5 decl" id="405value" title='value' data-type='std::string' data-ref="405value">value</dfn>,</td></tr>
<tr><th id="462">462</th><td>                                     <a class="type" href="#ceres::TrustRegionStrategyType" title='ceres::TrustRegionStrategyType' data-ref="ceres::TrustRegionStrategyType">TrustRegionStrategyType</a>* <dfn class="local col6 decl" id="406type" title='type' data-type='ceres::TrustRegionStrategyType *' data-ref="406type">type</dfn>);</td></tr>
<tr><th id="463">463</th><td></td></tr>
<tr><th id="464">464</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres18DoglegTypeToStringENS_10DoglegTypeE" title='ceres::DoglegTypeToString' data-ref="_ZN5ceres18DoglegTypeToStringENS_10DoglegTypeE">DoglegTypeToString</dfn>(<a class="type" href="#ceres::DoglegType" title='ceres::DoglegType' data-ref="ceres::DoglegType">DoglegType</a> <dfn class="local col7 decl" id="407type" title='type' data-type='ceres::DoglegType' data-ref="407type">type</dfn>);</td></tr>
<tr><th id="465">465</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres18StringToDoglegTypeESsPNS_10DoglegTypeE" title='ceres::StringToDoglegType' data-ref="_ZN5ceres18StringToDoglegTypeESsPNS_10DoglegTypeE">StringToDoglegType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col8 decl" id="408value" title='value' data-type='std::string' data-ref="408value">value</dfn>, <a class="type" href="#ceres::DoglegType" title='ceres::DoglegType' data-ref="ceres::DoglegType">DoglegType</a>* <dfn class="local col9 decl" id="409type" title='type' data-type='ceres::DoglegType *' data-ref="409type">type</dfn>);</td></tr>
<tr><th id="466">466</th><td></td></tr>
<tr><th id="467">467</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres21MinimizerTypeToStringENS_13MinimizerTypeE" title='ceres::MinimizerTypeToString' data-ref="_ZN5ceres21MinimizerTypeToStringENS_13MinimizerTypeE">MinimizerTypeToString</dfn>(<a class="type" href="#ceres::MinimizerType" title='ceres::MinimizerType' data-ref="ceres::MinimizerType">MinimizerType</a> <dfn class="local col0 decl" id="410type" title='type' data-type='ceres::MinimizerType' data-ref="410type">type</dfn>);</td></tr>
<tr><th id="468">468</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres21StringToMinimizerTypeESsPNS_13MinimizerTypeE" title='ceres::StringToMinimizerType' data-ref="_ZN5ceres21StringToMinimizerTypeESsPNS_13MinimizerTypeE">StringToMinimizerType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col1 decl" id="411value" title='value' data-type='std::string' data-ref="411value">value</dfn>, <a class="type" href="#ceres::MinimizerType" title='ceres::MinimizerType' data-ref="ceres::MinimizerType">MinimizerType</a>* <dfn class="local col2 decl" id="412type" title='type' data-type='ceres::MinimizerType *' data-ref="412type">type</dfn>);</td></tr>
<tr><th id="469">469</th><td></td></tr>
<tr><th id="470">470</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres31LineSearchDirectionTypeToStringENS_23LineSearchDirectionTypeE" title='ceres::LineSearchDirectionTypeToString' data-ref="_ZN5ceres31LineSearchDirectionTypeToStringENS_23LineSearchDirectionTypeE">LineSearchDirectionTypeToString</dfn>(</td></tr>
<tr><th id="471">471</th><td>    <a class="type" href="#ceres::LineSearchDirectionType" title='ceres::LineSearchDirectionType' data-ref="ceres::LineSearchDirectionType">LineSearchDirectionType</a> <dfn class="local col3 decl" id="413type" title='type' data-type='ceres::LineSearchDirectionType' data-ref="413type">type</dfn>);</td></tr>
<tr><th id="472">472</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres31StringToLineSearchDirectionTypeESsPNS_23LineSearchDirectionTypeE" title='ceres::StringToLineSearchDirectionType' data-ref="_ZN5ceres31StringToLineSearchDirectionTypeESsPNS_23LineSearchDirectionTypeE">StringToLineSearchDirectionType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col4 decl" id="414value" title='value' data-type='std::string' data-ref="414value">value</dfn>,</td></tr>
<tr><th id="473">473</th><td>                                     <a class="type" href="#ceres::LineSearchDirectionType" title='ceres::LineSearchDirectionType' data-ref="ceres::LineSearchDirectionType">LineSearchDirectionType</a>* <dfn class="local col5 decl" id="415type" title='type' data-type='ceres::LineSearchDirectionType *' data-ref="415type">type</dfn>);</td></tr>
<tr><th id="474">474</th><td></td></tr>
<tr><th id="475">475</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres22LineSearchTypeToStringENS_14LineSearchTypeE" title='ceres::LineSearchTypeToString' data-ref="_ZN5ceres22LineSearchTypeToStringENS_14LineSearchTypeE">LineSearchTypeToString</dfn>(<a class="type" href="#ceres::LineSearchType" title='ceres::LineSearchType' data-ref="ceres::LineSearchType">LineSearchType</a> <dfn class="local col6 decl" id="416type" title='type' data-type='ceres::LineSearchType' data-ref="416type">type</dfn>);</td></tr>
<tr><th id="476">476</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres22StringToLineSearchTypeESsPNS_14LineSearchTypeE" title='ceres::StringToLineSearchType' data-ref="_ZN5ceres22StringToLineSearchTypeESsPNS_14LineSearchTypeE">StringToLineSearchType</dfn>(<span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col7 decl" id="417value" title='value' data-type='std::string' data-ref="417value">value</dfn>, <a class="type" href="#ceres::LineSearchType" title='ceres::LineSearchType' data-ref="ceres::LineSearchType">LineSearchType</a>* <dfn class="local col8 decl" id="418type" title='type' data-type='ceres::LineSearchType *' data-ref="418type">type</dfn>);</td></tr>
<tr><th id="477">477</th><td></td></tr>
<tr><th id="478">478</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres38NonlinearConjugateGradientTypeToStringENS_30NonlinearConjugateGradientTypeE" title='ceres::NonlinearConjugateGradientTypeToString' data-ref="_ZN5ceres38NonlinearConjugateGradientTypeToStringENS_30NonlinearConjugateGradientTypeE">NonlinearConjugateGradientTypeToString</dfn>(</td></tr>
<tr><th id="479">479</th><td>    <a class="type" href="#ceres::NonlinearConjugateGradientType" title='ceres::NonlinearConjugateGradientType' data-ref="ceres::NonlinearConjugateGradientType">NonlinearConjugateGradientType</a> <dfn class="local col9 decl" id="419type" title='type' data-type='ceres::NonlinearConjugateGradientType' data-ref="419type">type</dfn>);</td></tr>
<tr><th id="480">480</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres38StringToNonlinearConjugateGradientTypeESsPNS_30NonlinearConjugateGradientTypeE" title='ceres::StringToNonlinearConjugateGradientType' data-ref="_ZN5ceres38StringToNonlinearConjugateGradientTypeESsPNS_30NonlinearConjugateGradientTypeE">StringToNonlinearConjugateGradientType</dfn>(</td></tr>
<tr><th id="481">481</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col0 decl" id="420value" title='value' data-type='std::string' data-ref="420value">value</dfn>,</td></tr>
<tr><th id="482">482</th><td>    <a class="type" href="#ceres::NonlinearConjugateGradientType" title='ceres::NonlinearConjugateGradientType' data-ref="ceres::NonlinearConjugateGradientType">NonlinearConjugateGradientType</a>* <dfn class="local col1 decl" id="421type" title='type' data-type='ceres::NonlinearConjugateGradientType *' data-ref="421type">type</dfn>);</td></tr>
<tr><th id="483">483</th><td></td></tr>
<tr><th id="484">484</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres35LineSearchInterpolationTypeToStringENS_27LineSearchInterpolationTypeE" title='ceres::LineSearchInterpolationTypeToString' data-ref="_ZN5ceres35LineSearchInterpolationTypeToStringENS_27LineSearchInterpolationTypeE">LineSearchInterpolationTypeToString</dfn>(</td></tr>
<tr><th id="485">485</th><td>    <a class="type" href="#ceres::LineSearchInterpolationType" title='ceres::LineSearchInterpolationType' data-ref="ceres::LineSearchInterpolationType">LineSearchInterpolationType</a> <dfn class="local col2 decl" id="422type" title='type' data-type='ceres::LineSearchInterpolationType' data-ref="422type">type</dfn>);</td></tr>
<tr><th id="486">486</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres35StringToLineSearchInterpolationTypeESsPNS_27LineSearchInterpolationTypeE" title='ceres::StringToLineSearchInterpolationType' data-ref="_ZN5ceres35StringToLineSearchInterpolationTypeESsPNS_27LineSearchInterpolationTypeE">StringToLineSearchInterpolationType</dfn>(</td></tr>
<tr><th id="487">487</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col3 decl" id="423value" title='value' data-type='std::string' data-ref="423value">value</dfn>,</td></tr>
<tr><th id="488">488</th><td>    <a class="type" href="#ceres::LineSearchInterpolationType" title='ceres::LineSearchInterpolationType' data-ref="ceres::LineSearchInterpolationType">LineSearchInterpolationType</a>* <dfn class="local col4 decl" id="424type" title='type' data-type='ceres::LineSearchInterpolationType *' data-ref="424type">type</dfn>);</td></tr>
<tr><th id="489">489</th><td></td></tr>
<tr><th id="490">490</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres31CovarianceAlgorithmTypeToStringENS_23CovarianceAlgorithmTypeE" title='ceres::CovarianceAlgorithmTypeToString' data-ref="_ZN5ceres31CovarianceAlgorithmTypeToStringENS_23CovarianceAlgorithmTypeE">CovarianceAlgorithmTypeToString</dfn>(</td></tr>
<tr><th id="491">491</th><td>    <a class="type" href="#ceres::CovarianceAlgorithmType" title='ceres::CovarianceAlgorithmType' data-ref="ceres::CovarianceAlgorithmType">CovarianceAlgorithmType</a> <dfn class="local col5 decl" id="425type" title='type' data-type='ceres::CovarianceAlgorithmType' data-ref="425type">type</dfn>);</td></tr>
<tr><th id="492">492</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres31StringToCovarianceAlgorithmTypeESsPNS_23CovarianceAlgorithmTypeE" title='ceres::StringToCovarianceAlgorithmType' data-ref="_ZN5ceres31StringToCovarianceAlgorithmTypeESsPNS_23CovarianceAlgorithmTypeE">StringToCovarianceAlgorithmType</dfn>(</td></tr>
<tr><th id="493">493</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col6 decl" id="426value" title='value' data-type='std::string' data-ref="426value">value</dfn>,</td></tr>
<tr><th id="494">494</th><td>    <a class="type" href="#ceres::CovarianceAlgorithmType" title='ceres::CovarianceAlgorithmType' data-ref="ceres::CovarianceAlgorithmType">CovarianceAlgorithmType</a>* <dfn class="local col7 decl" id="427type" title='type' data-type='ceres::CovarianceAlgorithmType *' data-ref="427type">type</dfn>);</td></tr>
<tr><th id="495">495</th><td></td></tr>
<tr><th id="496">496</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres29NumericDiffMethodTypeToStringENS_21NumericDiffMethodTypeE" title='ceres::NumericDiffMethodTypeToString' data-ref="_ZN5ceres29NumericDiffMethodTypeToStringENS_21NumericDiffMethodTypeE">NumericDiffMethodTypeToString</dfn>(</td></tr>
<tr><th id="497">497</th><td>    <a class="type" href="#ceres::NumericDiffMethodType" title='ceres::NumericDiffMethodType' data-ref="ceres::NumericDiffMethodType">NumericDiffMethodType</a> <dfn class="local col8 decl" id="428type" title='type' data-type='ceres::NumericDiffMethodType' data-ref="428type">type</dfn>);</td></tr>
<tr><th id="498">498</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres29StringToNumericDiffMethodTypeESsPNS_21NumericDiffMethodTypeE" title='ceres::StringToNumericDiffMethodType' data-ref="_ZN5ceres29StringToNumericDiffMethodTypeESsPNS_21NumericDiffMethodTypeE">StringToNumericDiffMethodType</dfn>(</td></tr>
<tr><th id="499">499</th><td>    <span class="namespace">std::</span><a class="typedef" href="../../../include/c++/4.8/bits/stringfwd.h.html#std::string" title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string">string</a> <dfn class="local col9 decl" id="429value" title='value' data-type='std::string' data-ref="429value">value</dfn>,</td></tr>
<tr><th id="500">500</th><td>    <a class="type" href="#ceres::NumericDiffMethodType" title='ceres::NumericDiffMethodType' data-ref="ceres::NumericDiffMethodType">NumericDiffMethodType</a>* <dfn class="local col0 decl" id="430type" title='type' data-type='ceres::NumericDiffMethodType *' data-ref="430type">type</dfn>);</td></tr>
<tr><th id="501">501</th><td></td></tr>
<tr><th id="502">502</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>const</em> <em>char</em>* <dfn class="decl" id="_ZN5ceres23TerminationTypeToStringENS_15TerminationTypeE" title='ceres::TerminationTypeToString' data-ref="_ZN5ceres23TerminationTypeToStringENS_15TerminationTypeE">TerminationTypeToString</dfn>(<a class="type" href="#ceres::TerminationType" title='ceres::TerminationType' data-ref="ceres::TerminationType">TerminationType</a> <dfn class="local col1 decl" id="431type" title='type' data-type='ceres::TerminationType' data-ref="431type">type</dfn>);</td></tr>
<tr><th id="503">503</th><td></td></tr>
<tr><th id="504">504</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres11IsSchurTypeENS_16LinearSolverTypeE" title='ceres::IsSchurType' data-ref="_ZN5ceres11IsSchurTypeENS_16LinearSolverTypeE">IsSchurType</dfn>(<a class="type" href="#ceres::LinearSolverType" title='ceres::LinearSolverType' data-ref="ceres::LinearSolverType">LinearSolverType</a> <dfn class="local col2 decl" id="432type" title='type' data-type='ceres::LinearSolverType' data-ref="432type">type</dfn>);</td></tr>
<tr><th id="505">505</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres41IsSparseLinearAlgebraLibraryTypeAvailableENS_30SparseLinearAlgebraLibraryTypeE" title='ceres::IsSparseLinearAlgebraLibraryTypeAvailable' data-ref="_ZN5ceres41IsSparseLinearAlgebraLibraryTypeAvailableENS_30SparseLinearAlgebraLibraryTypeE">IsSparseLinearAlgebraLibraryTypeAvailable</dfn>(</td></tr>
<tr><th id="506">506</th><td>    <a class="type" href="#ceres::SparseLinearAlgebraLibraryType" title='ceres::SparseLinearAlgebraLibraryType' data-ref="ceres::SparseLinearAlgebraLibraryType">SparseLinearAlgebraLibraryType</a> <dfn class="local col3 decl" id="433type" title='type' data-type='ceres::SparseLinearAlgebraLibraryType' data-ref="433type">type</dfn>);</td></tr>
<tr><th id="507">507</th><td><a class="macro" href="internal/port.h.html#95" title="" data-ref="_M/CERES_EXPORT">CERES_EXPORT</a> <em>bool</em> <dfn class="decl" id="_ZN5ceres40IsDenseLinearAlgebraLibraryTypeAvailableENS_29DenseLinearAlgebraLibraryTypeE" title='ceres::IsDenseLinearAlgebraLibraryTypeAvailable' data-ref="_ZN5ceres40IsDenseLinearAlgebraLibraryTypeAvailableENS_29DenseLinearAlgebraLibraryTypeE">IsDenseLinearAlgebraLibraryTypeAvailable</dfn>(</td></tr>
<tr><th id="508">508</th><td>    <a class="type" href="#ceres::DenseLinearAlgebraLibraryType" title='ceres::DenseLinearAlgebraLibraryType' data-ref="ceres::DenseLinearAlgebraLibraryType">DenseLinearAlgebraLibraryType</a> <dfn class="local col4 decl" id="434type" title='type' data-type='ceres::DenseLinearAlgebraLibraryType' data-ref="434type">type</dfn>);</td></tr>
<tr><th id="509">509</th><td></td></tr>
<tr><th id="510">510</th><td>}  <i>// namespace ceres</i></td></tr>
<tr><th id="511">511</th><td></td></tr>
<tr><th id="512">512</th><td><u>#include <a href="internal/reenable_warnings.h.html">"ceres/internal/reenable_warnings.h"</a></u></td></tr>
<tr><th id="513">513</th><td></td></tr>
<tr><th id="514">514</th><td><u>#<span data-ppcond="37">endif</span>  // CERES_PUBLIC_TYPES_H_</u></td></tr>
<tr><th id="515">515</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../examples/bundle_adjuster.cc.html'>ceres-solver/examples/bundle_adjuster.cc</a><br/>Generated on <em>2017-May-11</em> from project ceres-solver revision <em>1.12.0-69-g39388bd</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.0.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
