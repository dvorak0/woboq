<dec f='ceres-solver/internal/ceres/compressed_row_sparse_matrix.h' l='246' type='static void ceres::internal::CompressedRowSparseMatrix::ComputeOuterProduct(const ceres::internal::CompressedRowSparseMatrix &amp; m, const std::vector&lt;int&gt; &amp; program, ceres::internal::CompressedRowSparseMatrix * result)'/>
<doc f='ceres-solver/internal/ceres/compressed_row_sparse_matrix.h' l='242'>// Compute the values array for the expression m.transpose() * m,
  // where the matrix used to store the result and a program have been
  // created using the CreateOuterProductMatrixAndProgram function
  // above.</doc>
<def f='ceres-solver/internal/ceres/compressed_row_sparse_matrix.cc' l='817' ll='893' type='static void ceres::internal::CompressedRowSparseMatrix::ComputeOuterProduct(const ceres::internal::CompressedRowSparseMatrix &amp; m, const vector&lt;int&gt; &amp; program, ceres::internal::CompressedRowSparseMatrix * result)'/>
<doc f='ceres-solver/internal/ceres/compressed_row_sparse_matrix.cc' l='784'>// Give input matrix m in Compressed Row Sparse Block format
//     (row_block, col_block)
// compute outer product m&apos; * m as sum of block multiplications
//     (row_block, col_block1)&apos; X (row_block, col_block2)
//
// Given row_block of the input matrix m, we use m_row_begin to represent
// the starting row of the row block and m_row_nnz to represent number of
// nonzero in each row of the row block, then the rows belonging to
// the row block can be represented as a dense matrix starting at
//     m.values() + m.rows()[m_row_begin]
// with dimension
//     &lt;m.row_blocks()[row_block], m_row_nnz&gt;
//
// Then each input matrix block (row_block, col_block) can be represented as
// a block of above dense matrix starting at position
//     (0, m_col_nnz)
// with size
//     &lt;m.row_blocks()[row_block], m.col_blocks()[col_block]&gt;
// where m_col_nnz is the number of nonzero before col_block in each row.
//
// The outer product block is represented similarly with m_row_begin,
// m_row_nnz, m_col_nnz, etc. replaced by row_begin, row_nnz, col_nnz,
// etc. The difference is, m_row_begin and m_col_nnz is counted
// during the traverse of block multiplication, while row_begin and
// col_nnz are got from pre-computed block_offsets and program.
//
// Due to the compression on rows, col_block is accessed through
// idx to crsb_col vector. So col_block is accessed as crsb_col[idx]
// in the code.
//
// Note this function produces a triangular matrix in block unit (i.e.
// diagonal block is a normal block) instead of standard triangular matrix.
// So there is no special handling for diagonal blocks.</doc>
<use f='ceres-solver/internal/ceres/compressed_row_sparse_matrix_test.cc' l='449' u='c' c='_ZN5ceres8internal50CompressedRowSparseMatrix_ComputeOuterProduct_Test8TestBodyEv'/>
<use f='ceres-solver/internal/ceres/sparse_normal_cholesky_solver.cc' l='192' u='c' c='_ZN5ceres8internal26SparseNormalCholeskySolver9SolveImplEPNS0_25CompressedRowSparseMatrixEPKdRKNS0_12LinearSolver15PerSolveOptionsEPd'/>
