<dec f='include/c++/4.8/tr1/hashtable_policy.h' l='403' type='std::pair&lt;bool, std::size_t&gt; std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt, std::size_t __n_ins) const'/>
<def f='include/c++/4.8/tr1/hashtable_policy.h' l='453' ll='481' type='std::pair&lt;bool, std::size_t&gt; std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt, std::size_t __n_ins) const'/>
<doc f='include/c++/4.8/tr1/hashtable_policy.h' l='398'>// __n_bkt is current bucket count, __n_elt is current element count,
    // and __n_ins is number of elements to be inserted.  Do we need to
    // increase bucket count?  If so, return make_pair(true, n), where n
    // is the new bucket count.  If not, return make_pair(false, 0).</doc>
<doc f='include/c++/4.8/tr1/hashtable_policy.h' l='444'>// Finds the smallest prime p such that alpha p &gt; __n_elt + __n_ins.
  // If p &gt; __n_bkt, return make_pair(true, p); otherwise return
  // make_pair(false, 0).  In principle this isn&apos;t very different from 
  // _M_bkt_for_elements.

  // The only tricky part is that we&apos;re caching the element count at
  // which we need to rehash, so we don&apos;t have to do a floating-point
  // multiply for every insertion.</doc>
