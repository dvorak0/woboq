<dec f='ceres-solver/internal/ceres/block_random_access_sparse_matrix.h' l='84' type='void ceres::internal::BlockRandomAccessSparseMatrix::SymmetricRightMultiply(const double * x, double * y) const'/>
<def f='ceres-solver/internal/ceres/block_random_access_sparse_matrix.cc' l='164' ll='193' type='void ceres::internal::BlockRandomAccessSparseMatrix::SymmetricRightMultiply(const double * x, double * y) const'/>
<doc f='ceres-solver/internal/ceres/block_random_access_sparse_matrix.h' l='80'>// Assume that the matrix is symmetric and only one half of the
  // matrix is stored.
  //
  // y += S * x</doc>
<use f='ceres-solver/internal/ceres/block_random_access_sparse_matrix_test.cc' l='131' u='c' c='_ZN5ceres8internal42BlockRandomAccessSparseMatrix_GetCell_Test8TestBodyEv'/>
<use f='ceres-solver/internal/ceres/schur_complement_solver.cc' l='80' u='c' c='_ZNK5ceres8internal12_GLOBAL__N_136BlockRandomAccessSparseMatrixAdapter13RightMultiplyEPKdPd'/>
<use f='ceres-solver/internal/ceres/schur_complement_solver.cc' l='85' u='c' c='_ZNK5ceres8internal12_GLOBAL__N_136BlockRandomAccessSparseMatrixAdapter12LeftMultiplyEPKdPd'/>
