<dec f='ceres-solver/internal/ceres/gmock/gmock.h' l='3205'/>
<doc f='ceres-solver/internal/ceres/gmock/gmock.h' l='3108'>// The ACTION* family of macros can be used in a namespace scope to
// define custom actions easily.  The syntax:
//
//   ACTION(name) { statements; }
//
// will define an action with the given name that executes the
// statements.  The value returned by the statements will be used as
// the return value of the action.  Inside the statements, you can
// refer to the K-th (0-based) argument of the mock function by
// &apos;argK&apos;, and refer to its type by &apos;argK_type&apos;.  For example:
//
//   ACTION(IncrementArg1) {
//     arg1_type temp = arg1;
//     return ++(*temp);
//   }
//
// allows you to write
//
//   ...WillOnce(IncrementArg1());
//
// You can also refer to the entire argument tuple and its type by
// &apos;args&apos; and &apos;args_type&apos;, and refer to the mock function type and its
// return type by &apos;function_type&apos; and &apos;return_type&apos;.
//
// Note that you don&apos;t need to specify the types of the mock function
// arguments.  However rest assured that your code is still type-safe:
// you&apos;ll get a compiler error if *arg1 doesn&apos;t support the ++
// operator, or if the type of ++(*arg1) isn&apos;t compatible with the
// mock function&apos;s return type, for example.
//
// Sometimes you&apos;ll want to parameterize the action.   For that you can use
// another macro:
//
//   ACTION_P(name, param_name) { statements; }
//
// For example:
//
//   ACTION_P(Add, n) { return arg0 + n; }
//
// will allow you to write:
//
//   ...WillOnce(Add(5));
//
// Note that you don&apos;t need to provide the type of the parameter
// either.  If you need to reference the type of a parameter named
// &apos;foo&apos;, you can write &apos;foo_type&apos;.  For example, in the body of
// ACTION_P(Add, n) above, you can write &apos;n_type&apos; to refer to the type
// of &apos;n&apos;.
//
// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support
// multi-parameter actions.
//
// For the purpose of typing, you can view
//
//   ACTION_Pk(Foo, p1, ..., pk) { ... }
//
// as shorthand for
//
//   template &lt;typename p1_type, ..., typename pk_type&gt;
//   FooActionPk&lt;p1_type, ..., pk_type&gt; Foo(p1_type p1, ..., pk_type pk) { ... }
//
// In particular, you can provide the template type arguments
// explicitly when invoking Foo(), as in Foo&lt;long, bool&gt;(5, false);
// although usually you can rely on the compiler to infer the types
// for you automatically.  You can assign the result of expression
// Foo(p1, ..., pk) to a variable of type FooActionPk&lt;p1_type, ...,
// pk_type&gt;.  This can be useful when composing actions.
//
// You can also overload actions with different numbers of parameters:
//
//   ACTION_P(Plus, a) { ... }
//   ACTION_P2(Plus, a, b) { ... }
//
// While it&apos;s tempting to always use the ACTION* macros when defining
// a new action, you should also consider implementing ActionInterface
// or using MakePolymorphicAction() instead, especially if you need to
// use the action a lot.  While these approaches require more work,
// they give you more control on the types of the mock function
// arguments and the action parameters, which in general leads to
// better compiler error messages that pay off in the long run.  They
// also allow overloading actions based on parameter types (as opposed
// to just based on the number of parameters).
//
// CAVEAT:
//
// ACTION*() can only be used in a namespace scope.  The reason is
// that C++ doesn&apos;t yet allow function-local types to be used to
// instantiate templates.  The up-coming C++0x standard will fix this.
// Once that&apos;s done, we&apos;ll consider supporting using ACTION*() inside
// a function.
//
// MORE INFORMATION:
//
// To learn more about using these macros, please search for &apos;ACTION&apos;
// on http://code.google.com/p/googlemock/wiki/CookBook.

// An internal macro needed for implementing ACTION*().</doc>
