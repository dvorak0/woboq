<dec f='ceres-solver/internal/ceres/gmock/gmock.h' l='13851'/>
<use f='ceres-solver/internal/ceres/gmock/gmock.h' l='14941' u='c'/>
<doc f='ceres-solver/internal/ceres/gmock/gmock.h' l='13636'>// The MATCHER* family of macros can be used in a namespace scope to
// define custom matchers easily.
//
// Basic Usage
// ===========
//
// The syntax
//
//   MATCHER(name, description_string) { statements; }
//
// defines a matcher with the given name that executes the statements,
// which must return a bool to indicate if the match succeeds.  Inside
// the statements, you can refer to the value being matched by &apos;arg&apos;,
// and refer to its type by &apos;arg_type&apos;.
//
// The description string documents what the matcher does, and is used
// to generate the failure message when the match fails.  Since a
// MATCHER() is usually defined in a header file shared by multiple
// C++ source files, we require the description to be a C-string
// literal to avoid possible side effects.  It can be empty, in which
// case we&apos;ll use the sequence of words in the matcher name as the
// description.
//
// For example:
//
//   MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }
//
// allows you to write
//
//   // Expects mock_foo.Bar(n) to be called where n is even.
//   EXPECT_CALL(mock_foo, Bar(IsEven()));
//
// or,
//
//   // Verifies that the value of some_expression is even.
//   EXPECT_THAT(some_expression, IsEven());
//
// If the above assertion fails, it will print something like:
//
//   Value of: some_expression
//   Expected: is even
//     Actual: 7
//
// where the description &quot;is even&quot; is automatically calculated from the
// matcher name IsEven.
//
// Argument Type
// =============
//
// Note that the type of the value being matched (arg_type) is
// determined by the context in which you use the matcher and is
// supplied to you by the compiler, so you don&apos;t need to worry about
// declaring it (nor can you).  This allows the matcher to be
// polymorphic.  For example, IsEven() can be used to match any type
// where the value of &quot;(arg % 2) == 0&quot; can be implicitly converted to
// a bool.  In the &quot;Bar(IsEven())&quot; example above, if method Bar()
// takes an int, &apos;arg_type&apos; will be int; if it takes an unsigned long,
// &apos;arg_type&apos; will be unsigned long; and so on.
//
// Parameterizing Matchers
// =======================
//
// Sometimes you&apos;ll want to parameterize the matcher.  For that you
// can use another macro:
//
//   MATCHER_P(name, param_name, description_string) { statements; }
//
// For example:
//
//   MATCHER_P(HasAbsoluteValue, value, &quot;&quot;) { return abs(arg) == value; }
//
// will allow you to write:
//
//   EXPECT_THAT(Blah(&quot;a&quot;), HasAbsoluteValue(n));
//
// which may lead to this message (assuming n is 10):
//
//   Value of: Blah(&quot;a&quot;)
//   Expected: has absolute value 10
//     Actual: -9
//
// Note that both the matcher description and its parameter are
// printed, making the message human-friendly.
//
// In the matcher definition body, you can write &apos;foo_type&apos; to
// reference the type of a parameter named &apos;foo&apos;.  For example, in the
// body of MATCHER_P(HasAbsoluteValue, value) above, you can write
// &apos;value_type&apos; to refer to the type of &apos;value&apos;.
//
// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to
// support multi-parameter matchers.
//
// Describing Parameterized Matchers
// =================================
//
// The last argument to MATCHER*() is a string-typed expression.  The
// expression can reference all of the matcher&apos;s parameters and a
// special bool-typed variable named &apos;negation&apos;.  When &apos;negation&apos; is
// false, the expression should evaluate to the matcher&apos;s description;
// otherwise it should evaluate to the description of the negation of
// the matcher.  For example,
//
//   using testing::PrintToString;
//
//   MATCHER_P2(InClosedRange, low, hi,
//       string(negation ? &quot;is not&quot; : &quot;is&quot;) + &quot; in range [&quot; +
//       PrintToString(low) + &quot;, &quot; + PrintToString(hi) + &quot;]&quot;) {
//     return low &lt;= arg &amp;&amp; arg &lt;= hi;
//   }
//   ...
//   EXPECT_THAT(3, InClosedRange(4, 6));
//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
//
// would generate two failures that contain the text:
//
//   Expected: is in range [4, 6]
//   ...
//   Expected: is not in range [2, 4]
//
// If you specify &quot;&quot; as the description, the failure message will
// contain the sequence of words in the matcher name followed by the
// parameter values printed as a tuple.  For example,
//
//   MATCHER_P2(InClosedRange, low, hi, &quot;&quot;) { ... }
//   ...
//   EXPECT_THAT(3, InClosedRange(4, 6));
//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
//
// would generate two failures that contain the text:
//
//   Expected: in closed range (4, 6)
//   ...
//   Expected: not (in closed range (2, 4))
//
// Types of Matcher Parameters
// ===========================
//
// For the purpose of typing, you can view
//
//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }
//
// as shorthand for
//
//   template &lt;typename p1_type, ..., typename pk_type&gt;
//   FooMatcherPk&lt;p1_type, ..., pk_type&gt;
//   Foo(p1_type p1, ..., pk_type pk) { ... }
//
// When you write Foo(v1, ..., vk), the compiler infers the types of
// the parameters v1, ..., and vk for you.  If you are not happy with
// the result of the type inference, you can specify the types by
// explicitly instantiating the template, as in Foo&lt;long, bool&gt;(5,
// false).  As said earlier, you don&apos;t get to (or need to) specify
// &apos;arg_type&apos; as that&apos;s determined by the context in which the matcher
// is used.  You can assign the result of expression Foo(p1, ..., pk)
// to a variable of type FooMatcherPk&lt;p1_type, ..., pk_type&gt;.  This
// can be useful when composing matchers.
//
// While you can instantiate a matcher template with reference types,
// passing the parameters by pointer usually makes your code more
// readable.  If, however, you still want to pass a parameter by
// reference, be aware that in the failure message generated by the
// matcher you will see the value of the referenced object but not its
// address.
//
// Explaining Match Results
// ========================
//
// Sometimes the matcher description alone isn&apos;t enough to explain why
// the match has failed or succeeded.  For example, when expecting a
// long string, it can be very helpful to also print the diff between
// the expected string and the actual one.  To achieve that, you can
// optionally stream additional information to a special variable
// named result_listener, whose type is a pointer to class
// MatchResultListener:
//
//   MATCHER_P(EqualsLongString, str, &quot;&quot;) {
//     if (arg == str) return true;
//
//     *result_listener &lt;&lt; &quot;the difference: &quot;
///                     &lt;&lt; DiffStrings(str, arg);
//     return false;
//   }
//
// Overloading Matchers
// ====================
//
// You can overload matchers with different numbers of parameters:
//
//   MATCHER_P(Blah, a, description_string1) { ... }
//   MATCHER_P2(Blah, a, b, description_string2) { ... }
//
// Caveats
// =======
//
// When defining a new matcher, you should also consider implementing
// MatcherInterface or using MakePolymorphicMatcher().  These
// approaches require more work than the MATCHER* macros, but also
// give you more control on the types of the value being matched and
// the matcher parameters, which may leads to better compiler error
// messages when the matcher is used wrong.  They also allow
// overloading matchers based on parameter types (as opposed to just
// based on the number of parameters).
//
// MATCHER*() can only be used in a namespace scope.  The reason is
// that C++ doesn&apos;t yet allow function-local types to be used to
// instantiate templates.  The up-coming C++0x standard will fix this.
// Once that&apos;s done, we&apos;ll consider supporting using MATCHER*() inside
// a function.
//
// More Information
// ================
//
// To learn more about using these macros, please search for &apos;MATCHER&apos;
// on http://code.google.com/p/googlemock/wiki/CookBook.</doc>
<use f='ceres-solver/internal/ceres/rotation_test.cc' l='71' u='c'/>
<use f='ceres-solver/internal/ceres/rotation_test.cc' l='181' u='c'/>
