<dec f='ceres-solver/internal/ceres/dynamic_compressed_row_sparse_matrix.h' l='79' type='void ceres::internal::DynamicCompressedRowSparseMatrix::InsertEntry(int row, int col, const double &amp; value)'/>
<use f='ceres-solver/internal/ceres/dynamic_compressed_row_jacobian_writer.cc' l='108' u='c' c='_ZN5ceres8internal34DynamicCompressedRowJacobianWriter5WriteEiiPPdPNS0_12SparseMatrixE'/>
<doc f='ceres-solver/internal/ceres/dynamic_compressed_row_sparse_matrix.h' l='72'>// Insert an entry at a given row and column position. This method is
  // thread-safe across rows i.e. different threads can insert values
  // simultaneously into different rows. It should be emphasised that this
  // method always inserts a new entry and does not check for existing
  // entries at the specified row and column position. Duplicate entries
  // for a given row and column position will result in undefined
  // behavior.</doc>
<def f='ceres-solver/internal/ceres/dynamic_compressed_row_sparse_matrix.cc' l='48' ll='57' type='void ceres::internal::DynamicCompressedRowSparseMatrix::InsertEntry(int row, int col, const double &amp; value)'/>
<use f='ceres-solver/internal/ceres/dynamic_compressed_row_sparse_matrix_test.cc' l='122' u='c' c='_ZN5ceres8internal36DynamicCompressedRowSparseMatrixTest38InsertNonZeroEntriesFromDenseReferenceEv'/>
