<dec f='ceres-solver/internal/ceres/visibility_based_preconditioner.h' l='155' type='void ceres::internal::VisibilityBasedPreconditioner::FlattenMembershipMap(const HashMap&lt;int, int&gt; &amp; membership_map, std::vector&lt;int&gt; * membership_vector) const'/>
<use f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='228' u='c' c='_ZN5ceres8internal29VisibilityBasedPreconditioner14ClusterCamerasERKSt6vectorISt3setIiSt4lessIiESaIiEESaIS7_EE'/>
<def f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='590' ll='628' type='void ceres::internal::VisibilityBasedPreconditioner::FlattenMembershipMap(const HashMap&lt;int, int&gt; &amp; membership_map, vector&lt;int&gt; * membership_vector) const'/>
<doc f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='582'>// Canonical views clustering returns a HashMap from vertices to
// cluster ids. Convert this into a flat array for quick lookup. It is
// possible that some of the vertices may not be associated with any
// cluster. In that case, randomly assign them to one of the clusters.
//
// The cluster ids can be non-contiguous integers. So as we flatten
// the membership_map, we also map the cluster ids to a contiguous set
// of integers so that the cluster ids are in [0, num_clusters_).</doc>
