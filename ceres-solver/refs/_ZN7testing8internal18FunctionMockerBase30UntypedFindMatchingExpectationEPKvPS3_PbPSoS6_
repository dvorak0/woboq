<inh f='ceres-solver/internal/ceres/gmock/gmock.h' l='9353' c='_ZN7testing8internal25UntypedFunctionMockerBase30UntypedFindMatchingExpectationEPKvPS3_PbPSoS6_'/>
<def f='ceres-solver/internal/ceres/gmock/gmock.h' l='10857' ll='10880' type='const testing::internal::ExpectationBase * testing::internal::FunctionMockerBase::UntypedFindMatchingExpectation(const void * untyped_args, const void ** untyped_action, bool * is_excessive, ::std::ostream * what, ::std::ostream * why)'/>
<doc f='ceres-solver/internal/ceres/gmock/gmock.h' l='10841'>// Returns the expectation that matches the given function arguments
  // (or NULL is there&apos;s no match); when a match is found,
  // untyped_action is set to point to the action that should be
  // performed (or NULL if the action is &quot;do default&quot;), and
  // is_excessive is modified to indicate whether the call exceeds the
  // expected number.
  //
  // Critical section: We must find the matching expectation and the
  // corresponding action that needs to be taken in an ATOMIC
  // transaction.  Otherwise another thread may call this mock
  // method in the middle and mess up the state.
  //
  // However, performing the action has to be left out of the critical
  // section.  The reason is that we have no control on what the
  // action does (it can invoke an arbitrary user function or even a
  // mock function) and excessive locking could cause a dead lock.</doc>
