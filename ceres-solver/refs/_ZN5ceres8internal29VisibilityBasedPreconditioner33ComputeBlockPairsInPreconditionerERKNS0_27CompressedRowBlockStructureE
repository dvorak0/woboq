<dec f='ceres-solver/internal/ceres/visibility_based_preconditioner.h' l='164' type='void ceres::internal::VisibilityBasedPreconditioner::ComputeBlockPairsInPreconditioner(const ceres::internal::CompressedRowBlockStructure &amp; bs)'/>
<use f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='186' u='c' c='_ZN5ceres8internal29VisibilityBasedPreconditioner11InitStorageERKNS0_27CompressedRowBlockStructureE'/>
<def f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='251' ll='332' type='void ceres::internal::VisibilityBasedPreconditioner::ComputeBlockPairsInPreconditioner(const ceres::internal::CompressedRowBlockStructure &amp; bs)'/>
<doc f='ceres-solver/internal/ceres/visibility_based_preconditioner.cc' l='231'>// Compute the block sparsity structure of the Schur complement
// matrix. For each pair of cameras contributing a non-zero cell to
// the schur complement, determine if that cell is present in the
// preconditioner or not.
//
// A pair of cameras contribute a cell to the preconditioner if they
// are part of the same cluster or if the the two clusters that they
// belong have an edge connecting them in the degree-2 maximum
// spanning forest.
//
// For example, a camera pair (i,j) where i belonges to cluster1 and
// j belongs to cluster2 (assume that cluster1 &lt; cluster2).
//
// The cell corresponding to (i,j) is present in the preconditioner
// if cluster1 == cluster2 or the pair (cluster1, cluster2) were
// connected by an edge in the degree-2 maximum spanning forest.
//
// Since we have already expanded the forest into a set of camera
// pairs/edges, including self edges, the check can be reduced to
// checking membership of (cluster1, cluster2) in cluster_pairs_.</doc>
