<dec f='ceres-solver/internal/ceres/compressed_col_sparse_matrix_utils.h' l='50' type='void ceres::internal::CompressedColumnScalarMatrixToBlockMatrix(const int * scalar_rows, const int * scalar_cols, const std::vector&lt;int&gt; &amp; row_blocks, const std::vector&lt;int&gt; &amp; col_blocks, std::vector&lt;int&gt; * block_rows, std::vector&lt;int&gt; * block_cols)'/>
<def f='ceres-solver/internal/ceres/compressed_col_sparse_matrix_utils.cc' l='43' ll='95' type='void ceres::internal::CompressedColumnScalarMatrixToBlockMatrix(const int * scalar_rows, const int * scalar_cols, const vector&lt;int&gt; &amp; row_blocks, const vector&lt;int&gt; &amp; col_blocks, vector&lt;int&gt; * block_rows, vector&lt;int&gt; * block_cols)'/>
<doc f='ceres-solver/internal/ceres/compressed_col_sparse_matrix_utils.h' l='40'>// Extract the block sparsity pattern of the scalar compressed columns
// matrix and return it in compressed column form. The compressed
// column form is stored in two vectors block_rows, and block_cols,
// which correspond to the row and column arrays in a compressed
// column sparse matrix.
//
// If c_ij is the block in the matrix A corresponding to row block i
// and column block j, then it is expected that A contains at least
// one non-zero entry corresponding to the top left entry of c_ij,
// as that entry is used to detect the presence of a non-zero c_ij.</doc>
<use f='ceres-solver/internal/ceres/compressed_col_sparse_matrix_utils_test.cc' l='176' u='c' c='_ZN5ceres8internal32__ScalarMatrixToBlockMatrix_Test8TestBodyEv'/>
<use f='ceres-solver/internal/ceres/cxsparse.cc' l='115' u='c' c='_ZN5ceres8internal8CXSparse20BlockAnalyzeCholeskyEP12cs_di_sparseRKSt6vectorIiSaIiEES8_'/>
<use f='ceres-solver/internal/ceres/suitesparse.cc' l='229' u='c' c='_ZN5ceres8internal11SuiteSparse16BlockAMDOrderingEPK21cholmod_sparse_structRKSt6vectorIiSaIiEES9_PS7_'/>
