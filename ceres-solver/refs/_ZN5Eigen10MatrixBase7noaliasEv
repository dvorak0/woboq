<dec f='include/eigen3/Eigen/src/Core/MatrixBase.h' l='304' type='NoAlias&lt;Derived, Eigen::MatrixBase&gt; Eigen::MatrixBase::noalias()'/>
<def f='include/eigen3/Eigen/src/Core/NoAlias.h' l='126' ll='130' type='NoAlias&lt;Derived, MatrixBase&gt; Eigen::MatrixBase::noalias()'/>
<doc f='include/eigen3/Eigen/src/Core/NoAlias.h' l='98'>/** \returns a pseudo expression of \c *this with an operator= assuming
  * no aliasing between \c *this and the source expression.
  *
  * More precisely, noalias() allows to bypass the EvalBeforeAssignBit flag.
  * Currently, even though several expressions may alias, only product
  * expressions have this flag. Therefore, noalias() is only usefull when
  * the source expression contains a matrix product.
  *
  * Here are some examples where noalias is usefull:
  * \code
  * D.noalias()  = A * B;
  * D.noalias() += A.transpose() * B;
  * D.noalias() -= 2 * A * B.adjoint();
  * \endcode
  *
  * On the other hand the following example will lead to a \b wrong result:
  * \code
  * A.noalias() = A * B;
  * \endcode
  * because the result matrix A is also an operand of the matrix product. Therefore,
  * there is no alternative than evaluating A * B in a temporary, that is the default
  * behavior when you write:
  * \code
  * A = A * B;
  * \endcode
  *
  * \sa class NoAlias
  */</doc>
<use f='ceres-solver/internal/ceres/block_random_access_diagonal_matrix.cc' l='146' u='c' c='_ZNK5ceres8internal31BlockRandomAccessDiagonalMatrix13RightMultiplyEPKdPd'/>
<use f='ceres-solver/internal/ceres/schur_eliminator_test.cc' l='85' u='c' c='_ZN5ceres8internal19SchurEliminatorTest24ComputeReferenceSolutionERKN5Eigen6MatrixIdLin1ELi1ELi0ELin1ELi1EEE'/>
