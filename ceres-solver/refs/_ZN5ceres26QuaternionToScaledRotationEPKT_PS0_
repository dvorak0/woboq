<dec f='ceres-solver/include/ceres/rotation.h' l='161' type='void ceres::QuaternionToScaledRotation(const T * q, T * R)'/>
<def f='ceres-solver/include/ceres/rotation.h' l='454' ll='457' type='void ceres::QuaternionToScaledRotation(const T * q, T * R)'/>
<doc f='ceres-solver/include/ceres/rotation.h' l='141'>// Convert a 4-vector to a 3x3 scaled rotation matrix.
//
// The choice of rotation is such that the quaternion [1 0 0 0] goes to an
// identity matrix and for small a, b, c the quaternion [1 a b c] goes to
// the matrix
//
//         [  0 -c  b ]
//   I + 2 [  c  0 -a ] + higher order terms
//         [ -b  a  0 ]
//
// which corresponds to a Rodrigues approximation, the last matrix being
// the cross-product matrix of [a b c]. Together with the property that
// R(q1 * q2) = R(q1) * R(q2) this uniquely defines the mapping from q to R.
//
// No normalization of the quaternion is performed, i.e.
// R = ||q||^2 * Q, where Q is an orthonormal matrix
// such that det(Q) = 1 and Q*Q&apos; = I
//
// WARNING: The rotation matrix is ROW MAJOR</doc>
<use f='ceres-solver/internal/ceres/rotation_test.cc' l='880' u='c' c='_ZN5ceres8internal66Quaternion_RotatePointGivesSameAnswerAsRotationByMatrixCanned_Test8TestBodyEv'/>
