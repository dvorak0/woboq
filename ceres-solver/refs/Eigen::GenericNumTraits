<def f='include/eigen3/Eigen/src/Core/NumTraits.h' l='51' ll='86'/>
<ovr f='include/eigen3/Eigen/src/Core/NumTraits.h' l='91' c='Eigen::NumTraits'/>
<ovr f='include/eigen3/Eigen/src/Core/NumTraits.h' l='97' c='Eigen::NumTraits'/>
<ovr f='include/eigen3/Eigen/src/Core/NumTraits.h' l='102' c='Eigen::NumTraits'/>
<doc f='include/eigen3/Eigen/src/Core/NumTraits.h' l='15'>/** \class NumTraits
  * \ingroup Core_Module
  *
  * \brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.
  *
  * \param T the numeric type at hand
  *
  * This class stores enums, typedefs and static methods giving information about a numeric type.
  *
  * The provided data consists of:
  * \li A typedef \a Real, giving the &quot;real part&quot; type of \a T. If \a T is already real,
  *     then \a Real is just a typedef to \a T. If \a T is \c std::complex&lt;U&gt; then \a Real
  *     is a typedef to \a U.
  * \li A typedef \a NonInteger, giving the type that should be used for operations producing non-integral values,
  *     such as quotients, square roots, etc. If \a T is a floating-point type, then this typedef just gives
  *     \a T again. Note however that many Eigen functions such as internal::sqrt simply refuse to
  *     take integers. Outside of a few cases, Eigen doesn&apos;t do automatic type promotion. Thus, this typedef is
  *     only intended as a helper for code that needs to explicitly promote types.
  * \li A typedef \a Nested giving the type to use to nest a value inside of the expression tree. If you don&apos;t know what
  *     this means, just use \a T here.
  * \li An enum value \a IsComplex. It is equal to 1 if \a T is a \c std::complex
  *     type, and to 0 otherwise.
  * \li An enum value \a IsInteger. It is equal to \c 1 if \a T is an integer type such as \c int,
  *     and to \c 0 otherwise.
  * \li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed
  *     to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.
  *     Stay vague here. No need to do architecture-specific stuff.
  * \li An enum value \a IsSigned. It is equal to \c 1 if \a T is a signed type and to 0 if \a T is unsigned.
  * \li An enum value \a RequireInitialization. It is equal to \c 1 if the constructor of the numeric type \a T must
  *     be called, and to 0 if it is safe not to call it. Default is 0 if \a T is an arithmetic type, and 1 otherwise.
  * \li An epsilon() function which, unlike std::numeric_limits::epsilon(), returns a \a Real instead of a \a T.
  * \li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default
  *     value by the fuzzy comparison operators.
  * \li highest() and lowest() functions returning the highest and lowest possible values respectively.
  */</doc>
<fun r='_ZN5Eigen16GenericNumTraits7epsilonEv'/>
<fun r='_ZN5Eigen16GenericNumTraits15dummy_precisionEv'/>
<fun r='_ZN5Eigen16GenericNumTraits7highestEv'/>
<fun r='_ZN5Eigen16GenericNumTraits6lowestEv'/>
