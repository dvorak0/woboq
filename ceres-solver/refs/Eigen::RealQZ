<def f='include/eigen3/Eigen/src/Eigenvalues/RealQZ.h' l='57' ll='213'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/RealQZ.h' l='15'>/** \eigenvalues_module \ingroup Eigenvalues_Module
   *
   *
   * \class RealQZ
   *
   * \brief Performs a real QZ decomposition of a pair of square matrices
   *
   * \tparam _MatrixType the type of the matrix of which we are computing the
   * real QZ decomposition; this is expected to be an instantiation of the
   * Matrix class template.
   *
   * Given a real square matrices A and B, this class computes the real QZ
   * decomposition: \f$ A = Q S Z \f$, \f$ B = Q T Z \f$ where Q and Z are
   * real orthogonal matrixes, T is upper-triangular matrix, and S is upper
   * quasi-triangular matrix. An orthogonal matrix is a matrix whose
   * inverse is equal to its transpose, \f$ U^{-1} = U^T \f$. A quasi-triangular
   * matrix is a block-triangular matrix whose diagonal consists of 1-by-1
   * blocks and 2-by-2 blocks where further reduction is impossible due to
   * complex eigenvalues. 
   *
   * The eigenvalues of the pencil \f$ A - z B \f$ can be obtained from
   * 1x1 and 2x2 blocks on the diagonals of S and T.
   *
   * Call the function compute() to compute the real QZ decomposition of a
   * given pair of matrices. Alternatively, you can use the 
   * RealQZ(const MatrixType&amp; B, const MatrixType&amp; B, bool computeQZ)
   * constructor which computes the real QZ decomposition at construction
   * time. Once the decomposition is computed, you can use the matrixS(),
   * matrixT(), matrixQ() and matrixZ() functions to retrieve the matrices
   * S, T, Q and Z in the decomposition. If computeQZ==false, some time
   * is saved by not computing matrices Q and Z.
   *
   * Example: \include RealQZ_compute.cpp
   * Output: \include RealQZ_compute.out
   *
   * \note The implementation is based on the algorithm in &quot;Matrix Computations&quot;
   * by Gene H. Golub and Charles F. Van Loan, and a paper &quot;An algorithm for
   * generalized eigenvalue problems&quot; by C.B.Moler and G.W.Stewart.
   *
   * \sa class RealSchur, class ComplexSchur, class EigenSolver, class ComplexEigenSolver
   */</doc>
<fun r='_ZN5Eigen6RealQZC1ENT_5IndexE'/>
<fun r='_ZN5Eigen6RealQZC1ERKT_S3_b'/>
<fun r='_ZNK5Eigen6RealQZ7matrixQEv'/>
<fun r='_ZNK5Eigen6RealQZ7matrixZEv'/>
<fun r='_ZNK5Eigen6RealQZ7matrixSEv'/>
<fun r='_ZNK5Eigen6RealQZ7matrixTEv'/>
<fun r='_ZN5Eigen6RealQZ7computeERKT_S3_b'/>
<fun r='_ZNK5Eigen6RealQZ4infoEv'/>
<fun r='_ZNK5Eigen6RealQZ10iterationsEv'/>
<fun r='_ZN5Eigen6RealQZ16setMaxIterationsENT_5IndexE'/>
<mbr r='Eigen::RealQZ::m_S' t='MatrixType'/>
<mbr r='Eigen::RealQZ::m_T' t='MatrixType'/>
<mbr r='Eigen::RealQZ::m_Q' t='MatrixType'/>
<mbr r='Eigen::RealQZ::m_Z' t='MatrixType'/>
<mbr r='Eigen::RealQZ::m_workspace' t='Matrix&lt;Scalar, Dynamic, 1&gt;'/>
<mbr r='Eigen::RealQZ::m_info' t='Eigen::ComputationInfo'/>
<mbr r='Eigen::RealQZ::m_maxIters' t='Index'/>
<mbr r='Eigen::RealQZ::m_isInitialized' t='bool'/>
<mbr r='Eigen::RealQZ::m_computeQZ' t='bool'/>
<mbr r='Eigen::RealQZ::m_normOfT' t='Scalar'/>
<mbr r='Eigen::RealQZ::m_normOfS' t='Scalar'/>
<mbr r='Eigen::RealQZ::m_global_iter' t='Index'/>
<fun r='_ZN5Eigen6RealQZ20hessenbergTriangularEv'/>
<fun r='_ZN5Eigen6RealQZ12computeNormsEv'/>
<fun r='_ZN5Eigen6RealQZ21findSmallSubdiagEntryENT_5IndexE'/>
<fun r='_ZN5Eigen6RealQZ18findSmallDiagEntryENT_5IndexES2_'/>
<fun r='_ZN5Eigen6RealQZ15splitOffTwoRowsENT_5IndexE'/>
<fun r='_ZN5Eigen6RealQZ12pushDownZeroENT_5IndexES2_S2_'/>
<fun r='_ZN5Eigen6RealQZ4stepENT_5IndexES2_S2_'/>
<fun r='_ZN5Eigen6RealQZ20hessenbergTriangularEv'/>
<fun r='_ZN5Eigen6RealQZ12computeNormsEv'/>
<fun r='_ZN5Eigen6RealQZ21findSmallSubdiagEntryENT_5IndexE'/>
<fun r='_ZN5Eigen6RealQZ18findSmallDiagEntryENT_5IndexES2_'/>
<fun r='_ZN5Eigen6RealQZ15splitOffTwoRowsENT_5IndexE'/>
<fun r='_ZN5Eigen6RealQZ12pushDownZeroENT_5IndexES2_S2_'/>
<fun r='_ZN5Eigen6RealQZ4stepENT_5IndexES2_S2_'/>
<fun r='_ZN5Eigen6RealQZ7computeERKT_S3_b'/>
