<dec f='include/eigen3/Eigen/src/Core/DenseBase.h' l='337' type='bool Eigen::DenseBase::isApprox(const DenseBase&lt;OtherDerived&gt; &amp; other, const RealScalar &amp; prec = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<def f='include/eigen3/Eigen/src/Core/Fuzzy.h' l='96' ll='104' type='bool Eigen::DenseBase::isApprox(const DenseBase&lt;OtherDerived&gt; &amp; other, const RealScalar &amp; prec = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<doc f='include/eigen3/Eigen/src/Core/Fuzzy.h' l='79'>/** \returns \c true if \c *this is approximately equal to \a other, within the precision
  * determined by \a prec.
  *
  * \note The fuzzy compares are done multiplicatively. Two vectors \f$ v \f$ and \f$ w \f$
  * are considered to be approximately equal within precision \f$ p \f$ if
  * \f[ \Vert v - w \Vert \leqslant p\,\min(\Vert v\Vert, \Vert w\Vert). \f]
  * For matrices, the comparison is done using the Hilbert-Schmidt norm (aka Frobenius norm
  * L2 norm).
  *
  * \note Because of the multiplicativeness of this comparison, one can&apos;t use this function
  * to check whether \c *this is approximately equal to the zero matrix or vector.
  * Indeed, \c isApprox(zero) returns false unless \c *this itself is exactly the zero matrix
  * or vector. If you want to test whether \c *this is zero, use internal::isMuchSmallerThan(const
  * RealScalar&amp;, RealScalar) instead.
  *
  * \sa internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) const
  */</doc>
<use f='ceres-solver/examples/libmv_homography.cc' l='240' u='c' c='_ZN12_GLOBAL__N_140Homography2DFromCorrespondencesLinearEucERKN5Eigen6MatrixIdLin1ELin1ELi0ELin1ELin1EEES4_PNS1_IdLi3ELi3ELi0ELi3ELi3EEEd'/>
