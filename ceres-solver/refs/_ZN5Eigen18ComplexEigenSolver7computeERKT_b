<use f='include/eigen3/Eigen/src/Eigenvalues/ComplexEigenSolver.h' l='133' u='c' c='_ZN5Eigen18ComplexEigenSolverC1ERKT_b'/>
<dec f='include/eigen3/Eigen/src/Eigenvalues/ComplexEigenSolver.h' l='211' type='ComplexEigenSolver&lt;_MatrixType&gt; &amp; Eigen::ComplexEigenSolver::compute(const MatrixType &amp; matrix, bool computeEigenvectors = true)'/>
<def f='include/eigen3/Eigen/src/Eigenvalues/ComplexEigenSolver.h' l='250' ll='272' type='ComplexEigenSolver&lt;MatrixType&gt; &amp; Eigen::ComplexEigenSolver::compute(const MatrixType &amp; matrix, bool computeEigenvectors = true)'/>
<doc f='include/eigen3/Eigen/src/Eigenvalues/ComplexEigenSolver.h' l='187'>/** \brief Computes eigendecomposition of given matrix.
      *
      * \param[in]  matrix  Square matrix whose eigendecomposition is to be computed.
      * \param[in]  computeEigenvectors  If true, both the eigenvectors and the
      *    eigenvalues are computed; if false, only the eigenvalues are
      *    computed.
      * \returns    Reference to \c *this
      *
      * This function computes the eigenvalues of the complex matrix \p matrix.
      * The eigenvalues() function can be used to retrieve them.  If
      * \p computeEigenvectors is true, then the eigenvectors are also computed
      * and can be retrieved by calling eigenvectors().
      *
      * The matrix is first reduced to Schur form using the
      * ComplexSchur class. The Schur decomposition is then used to
      * compute the eigenvalues and eigenvectors.
      *
      * The cost of the computation is dominated by the cost of the
      * Schur decomposition, which is \f$ O(n^3) \f$ where \f$ n \f$
      * is the size of the matrix.
      *
      * Example: \include ComplexEigenSolver_compute.cpp
      * Output: \verbinclude ComplexEigenSolver_compute.out
      */</doc>
