<dec f='ceres-solver/internal/ceres/trust_region_minimizer.h' l='67' type='void ceres::internal::TrustRegionMinimizer::ComputeCandidatePointAndEvaluateCost()'/>
<use f='ceres-solver/internal/ceres/trust_region_minimizer.cc' l='101' u='c' c='_ZN5ceres8internal20TrustRegionMinimizer8MinimizeERKNS0_9Minimizer7OptionsEPdPNS_6Solver7SummaryE'/>
<def f='ceres-solver/internal/ceres/trust_region_minimizer.cc' l='718' ll='734' type='void ceres::internal::TrustRegionMinimizer::ComputeCandidatePointAndEvaluateCost()'/>
<doc f='ceres-solver/internal/ceres/trust_region_minimizer.cc' l='707'>// Compute candidate_x_ = Plus(x_, delta_)
// Evaluate the cost of candidate_x_ as candidate_cost_.
//
// Failure to compute the step or the cost mean that candidate_cost_
// is set to std::numeric_limits&lt;double&gt;::max(). Unlike
// EvaluateGradientAndJacobian, failure in this function is not fatal
// as we are only computing and evaluating a candidate point, and if
// for some reason we are unable to evaluate it, we consider it to be
// a point with very high cost. This allows the user to deal with edge
// cases/constraints as part of the LocalParameterization and
// CostFunction objects.</doc>
