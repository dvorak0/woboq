<use f='ceres-solver/include/ceres/covariance.h' l='212' u='w' c='_ZN5ceres10Covariance7OptionsC1Ev'/>
<dec f='ceres-solver/include/ceres/covariance.h' l='287' type='double'/>
<offset>64</offset>
<doc f='ceres-solver/include/ceres/covariance.h' l='256'>// If the Jacobian matrix is near singular, then inverting J&apos;J
    // will result in unreliable results, e.g, if
    //
    //   J = [1.0 1.0         ]
    //       [1.0 1.0000001   ]
    //
    // which is essentially a rank deficient matrix, we have
    //
    //   inv(J&apos;J) = [ 2.0471e+14  -2.0471e+14]
    //              [-2.0471e+14   2.0471e+14]
    //
    // This is not a useful result. Therefore, by default
    // Covariance::Compute will return false if a rank deficient
    // Jacobian is encountered. How rank deficiency is detected
    // depends on the algorithm being used.
    //
    // 1. DENSE_SVD
    //
    //      min_sigma / max_sigma &lt; sqrt(min_reciprocal_condition_number)
    //
    //    where min_sigma and max_sigma are the minimum and maxiumum
    //    singular values of J respectively.
    //
    // 2. SPARSE_QR
    //
    //      rank(J) &lt; num_col(J)
    //
    //   Here rank(J) is the estimate of the rank of J returned by the
    //   sparse QR factorization algorithm. It is a fairly reliable
    //   indication of rank deficiency.
    //</doc>
<use f='ceres-solver/internal/ceres/covariance_impl.cc' l='774' u='r' c='_ZN5ceres8internal14CovarianceImpl36ComputeCovarianceValuesUsingDenseSVDEv'/>
<use f='ceres-solver/internal/ceres/covariance_impl.cc' l='802' u='r' c='_ZN5ceres8internal14CovarianceImpl36ComputeCovarianceValuesUsingDenseSVDEv'/>
<use f='ceres-solver/internal/ceres/covariance_test.cc' l='974' u='w' c='_ZN5ceres8internal33CovarianceTest_TruncatedRank_Test8TestBodyEv'/>
