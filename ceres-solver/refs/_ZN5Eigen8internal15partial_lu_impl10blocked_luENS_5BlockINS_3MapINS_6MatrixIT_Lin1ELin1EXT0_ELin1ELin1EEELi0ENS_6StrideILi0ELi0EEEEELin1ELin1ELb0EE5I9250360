<def f='include/eigen3/Eigen/src/LU/PartialPivLU.h' l='298' ll='368' type='static Index Eigen::internal::partial_lu_impl::blocked_lu(Index rows, Index cols, Scalar * lu_data, Index luStride, PivIndex * row_transpositions, PivIndex &amp; nb_transpositions, Index maxBlockSize = 256)'/>
<use f='include/eigen3/Eigen/src/LU/PartialPivLU.h' l='342' u='c' c='_ZN5Eigen8internal15partial_lu_impl10blocked_luENS_5BlockINS_3MapINS_6MatrixIT_Lin1ELin1EXT0_ELin1ELin1EEELi0ENS_6StrideILi0ELi0EEEEELin1ELin1ELb0EE5I9250360'/>
<doc f='include/eigen3/Eigen/src/LU/PartialPivLU.h' l='283'>/** \internal performs the LU decomposition in-place of the matrix represented
    * by the variables \a rows, \a cols, \a lu_data, and \a lu_stride using a
    * recursive, blocked algorithm.
    *
    * In addition, this function returns the row transpositions in the
    * vector \a row_transpositions which must have a size equal to the number
    * of columns of the matrix \a lu, and an integer \a nb_transpositions
    * which returns the actual number of transpositions.
    *
    * \returns The index of the first pivot which is exactly zero if any, or a negative number otherwise.
    *
    * \note This very low level interface using pointers, etc. is to:
    *   1 - reduce the number of instanciations to the strict minimum
    *   2 - avoid infinite recursion of the instanciations with Block&lt;Block&lt;Block&lt;...&gt; &gt; &gt;
    */</doc>
