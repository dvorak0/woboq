<dec f='include/eigen3/Eigen/src/SparseCore/SparseMatrixBase.h' l='339' type='const typename SparseSparseProductReturnType&lt;Derived, OtherDerived&gt;::Type Eigen::SparseMatrixBase::operator*(const SparseMatrixBase&lt;OtherDerived&gt; &amp; other) const'/>
<def f='include/eigen3/Eigen/src/SparseCore/SparseProduct.h' l='177' ll='183' type='const typename SparseSparseProductReturnType&lt;Derived, OtherDerived&gt;::Type Eigen::SparseMatrixBase::operator*(const SparseMatrixBase&lt;OtherDerived&gt; &amp; other) const'/>
<use f='ceres-solver/internal/ceres/compressed_row_sparse_matrix_test.cc' l='439' u='c' c='_ZN5ceres8internal50CompressedRowSparseMatrix_ComputeOuterProduct_Test8TestBodyEv'/>
<doc f='include/eigen3/Eigen/src/SparseCore/SparseProduct.h' l='166'>/** \returns an expression of the product of two sparse matrices.
  * By default a conservative product preserving the symbolic non zeros is performed.
  * The automatic pruning of the small values can be achieved by calling the pruned() function
  * in which case a totally different product algorithm is employed:
  * \code
  * C = (A*B).pruned();             // supress numerical zeros (exact)
  * C = (A*B).pruned(ref);
  * C = (A*B).pruned(ref,epsilon);
  * \endcode
  * where \c ref is a meaningful non zero reference value.
  * */</doc>
