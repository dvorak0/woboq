<def f='ceres-solver/internal/ceres/block_random_access_matrix.h' l='86' ll='97'/>
<size>72</size>
<doc f='ceres-solver/internal/ceres/block_random_access_matrix.h' l='41'>// A matrix implementing the BlockRandomAccessMatrix interface is a
// matrix whose rows and columns are divided into blocks. For example
// the matrix A:
//
//            3     4      5
//  A =  5 [c_11  c_12  c_13]
//       4 [c_21  c_22  c_23]
//
// has row blocks of size 5 and 4, and column blocks of size 3, 4 and
// 5. It has six cells corresponding to the six row-column block
// combinations.
//
// BlockRandomAccessMatrix objects provide access to cells c_ij using
// the GetCell method. when a cell is present, GetCell will return a
// CellInfo object containing a pointer to an array which contains the
// cell as a submatrix and a mutex that guards this submatrix. If the
// user is accessing the matrix concurrently, it is his responsibility
// to use the mutex to exclude other writers from writing to the cell
// concurrently.
//
// There is no requirement that all cells be present, i.e. the matrix
// itself can be block sparse. When a cell is not present, the GetCell
// method will return a NULL pointer.
//
// There is no requirement about how the cells are stored beyond that
// form a dense submatrix of a larger dense matrix. Like everywhere
// else in Ceres, RowMajor storage assumed.
//
// Example usage:
//
//  BlockRandomAccessMatrix* A = new BlockRandomAccessMatrixSubClass(...)
//
//  int row, col, row_stride, col_stride;
//  CellInfo* cell = A-&gt;GetCell(row_block_id, col_block_id,
//                              &amp;row, &amp;col,
//                              &amp;row_stride, &amp;col_stride);
//
//  if (cell != NULL) {
//     MatrixRef m(cell-&gt;values, row_stride, col_stride);
//     CeresMutexLock l(&amp;cell-&gt;m);
//     m.block(row, col, row_block_size, col_block_size) = ...
//  }

// Structure to carry a pointer to the array containing a cell and the
// Mutex guarding it.</doc>
<fun r='_ZN5ceres8internal8CellInfoC1Ev'/>
<fun r='_ZN5ceres8internal8CellInfoC1EPd'/>
<mbr r='ceres::internal::CellInfo::values' o='0' t='double *'/>
<mbr r='ceres::internal::CellInfo::m' o='64' t='ceres::internal::Mutex'/>
