<dec f='ceres-solver/include/ceres/problem.h' l='471' type='bool ceres::Problem::Evaluate(const ceres::Problem::EvaluateOptions &amp; options, double * cost, std::vector&lt;double&gt; * residuals, std::vector&lt;double&gt; * gradient, ceres::CRSMatrix * jacobian)'/>
<doc f='ceres-solver/include/ceres/problem.h' l='438'>// Evaluate Problem. Any of the output pointers can be NULL. Which
  // residual blocks and parameter blocks are used is controlled by
  // the EvaluateOptions struct above.
  //
  // Note 1: The evaluation will use the values stored in the memory
  // locations pointed to by the parameter block pointers used at the
  // time of the construction of the problem. i.e.,
  //
  //   Problem problem;
  //   double x = 1;
  //   problem.AddResidualBlock(new MyCostFunction, NULL, &amp;x);
  //
  //   double cost = 0.0;
  //   problem.Evaluate(Problem::EvaluateOptions(), &amp;cost, NULL, NULL, NULL);
  //
  // The cost is evaluated at x = 1. If you wish to evaluate the
  // problem at x = 2, then
  //
  //    x = 2;
  //    problem.Evaluate(Problem::EvaluateOptions(), &amp;cost, NULL, NULL, NULL);
  //
  // is the way to do so.
  //
  // Note 2: If no local parameterizations are used, then the size of
  // the gradient vector (and the number of columns in the jacobian)
  // is the sum of the sizes of all the parameter blocks. If a
  // parameter block has a local parameterization, then it contributes
  // &quot;LocalSize&quot; entries to the gradient vector (and the number of
  // columns in the jacobian).
  //
  // Note 3: This function cannot be called while the problem is being
  // solved, for example it cannot be called from an IterationCallback
  // at the end of an iteration during a solve.</doc>
<use f='ceres-solver/internal/ceres/test_util.h' l='176' u='c' c='_ZN5ceres8internal10SystemTest30SolveAndEvaluateFinalResidualsERKNS_6Solver7OptionsEPNS_7ProblemEPSt6vectorIdSaIdEE'/>
<def f='ceres-solver/internal/ceres/problem.cc' l='204' ll='214' type='bool ceres::Problem::Evaluate(const ceres::Problem::EvaluateOptions &amp; evaluate_options, double * cost, vector&lt;double&gt; * residuals, vector&lt;double&gt; * gradient, ceres::CRSMatrix * jacobian)'/>
