<dec f='ceres-solver/internal/ceres/suitesparse.h' l='217' type='bool ceres::internal::SuiteSparse::BlockAMDOrdering(const cholmod_sparse * A, const std::vector&lt;int&gt; &amp; row_blocks, const std::vector&lt;int&gt; &amp; col_blocks, std::vector&lt;int&gt; * ordering)'/>
<doc f='ceres-solver/internal/ceres/suitesparse.h' l='195'>// By virtue of the modeling layer in Ceres being block oriented,
  // all the matrices used by Ceres are also block oriented. When
  // doing sparse direct factorization of these matrices the
  // fill-reducing ordering algorithms (in particular AMD) can either
  // be run on the block or the scalar form of these matrices. The two
  // SuiteSparse::AnalyzeCholesky methods allows the the client to
  // compute the symbolic factorization of a matrix by either using
  // AMD on the matrix or a user provided ordering of the rows.
  //
  // But since the underlying matrices are block oriented, it is worth
  // running AMD on just the block structre of these matrices and then
  // lifting these block orderings to a full scalar ordering. This
  // preserves the block structure of the permuted matrix, and exposes
  // more of the super-nodal structure of the matrix to the numerical
  // factorization routines.
  //
  // Find the block oriented AMD ordering of a matrix A, whose row and
  // column blocks are given by row_blocks, and col_blocks
  // respectively. The matrix may or may not be symmetric. The entries
  // of col_blocks do not need to sum to the number of columns in
  // A. If this is the case, only the first sum(col_blocks) are used
  // to compute the ordering.</doc>
<use f='ceres-solver/internal/ceres/suitesparse.cc' l='168' u='c' c='_ZN5ceres8internal11SuiteSparse20BlockAnalyzeCholeskyEP21cholmod_sparse_structRKSt6vectorIiSaIiEES8_PSs'/>
<def f='ceres-solver/internal/ceres/suitesparse.cc' l='217' ll='257' type='bool ceres::internal::SuiteSparse::BlockAMDOrdering(const cholmod_sparse * A, const vector&lt;int&gt; &amp; row_blocks, const vector&lt;int&gt; &amp; col_blocks, vector&lt;int&gt; * ordering)'/>
