<dec f='include/eigen3/Eigen/src/Geometry/Transform.h' l='551' type='void Eigen::Transform::computeRotationScaling(RotationMatrixType * rotation, ScalingMatrixType * scaling) const'/>
<def f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1017' ll='1033' type='void Eigen::Transform::computeRotationScaling(RotationMatrixType * rotation, ScalingMatrixType * scaling) const'/>
<doc f='include/eigen3/Eigen/src/Geometry/Transform.h' l='1006'>/** decomposes the linear part of the transformation as a product rotation x scaling, the scaling being
  * not necessarily positive.
  *
  * If either pointer is zero, the corresponding computation is skipped.
  *
  *
  *
  * \svd_module
  *
  * \sa computeScalingRotation(), rotation(), class SVD
  */</doc>
