<dec f='ceres-solver/internal/ceres/implicit_schur_complement.h' l='143' type='void ceres::internal::ImplicitSchurComplement::AddDiagonalAndInvert(const double * D, ceres::internal::BlockSparseMatrix * matrix)'/>
<use f='ceres-solver/internal/ceres/implicit_schur_complement.cc' l='90' u='c' c='_ZN5ceres8internal23ImplicitSchurComplement4InitERKNS0_17BlockSparseMatrixEPKdS6_'/>
<use f='ceres-solver/internal/ceres/implicit_schur_complement.cc' l='92' u='c' c='_ZN5ceres8internal23ImplicitSchurComplement4InitERKNS0_17BlockSparseMatrixEPKdS6_'/>
<def f='ceres-solver/internal/ceres/implicit_schur_complement.cc' l='142' ll='164' type='void ceres::internal::ImplicitSchurComplement::AddDiagonalAndInvert(const double * D, ceres::internal::BlockSparseMatrix * block_diagonal)'/>
<doc f='ceres-solver/internal/ceres/implicit_schur_complement.cc' l='139'>// Given a block diagonal matrix and an optional array of diagonal
// entries D, add them to the diagonal of the matrix and compute the
// inverse of each diagonal block.</doc>
