<def f='ceres-solver/include/ceres/local_parameterization.h' l='112' ll='148'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='153' c='ceres::IdentityParameterization'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='174' c='ceres::SubsetParameterization'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='202' c='ceres::QuaternionParameterization'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='225' c='ceres::EigenQuaternionParameterization'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='250' c='ceres::HomogeneousVectorParameterization'/>
<ovr f='ceres-solver/include/ceres/local_parameterization.h' l='283' c='ceres::ProductParameterization'/>
<ovr f='ceres-solver/include/ceres/autodiff_local_parameterization.h' l='108' c='ceres::AutoDiffLocalParameterization'/>
<size>8</size>
<doc f='ceres-solver/include/ceres/local_parameterization.h' l='42'>// Purpose: Sometimes parameter blocks x can overparameterize a problem
//
//   min f(x)
//    x
//
// In that case it is desirable to choose a parameterization for the
// block itself to remove the null directions of the cost. More
// generally, if x lies on a manifold of a smaller dimension than the
// ambient space that it is embedded in, then it is numerically and
// computationally more effective to optimize it using a
// parameterization that lives in the tangent space of that manifold
// at each point.
//
// For example, a sphere in three dimensions is a 2 dimensional
// manifold, embedded in a three dimensional space. At each point on
// the sphere, the plane tangent to it defines a two dimensional
// tangent space. For a cost function defined on this sphere, given a
// point x, moving in the direction normal to the sphere at that point
// is not useful. Thus a better way to do a local optimization is to
// optimize over two dimensional vector delta in the tangent space at
// that point and then &quot;move&quot; to the point x + delta, where the move
// operation involves projecting back onto the sphere. Doing so
// removes a redundent dimension from the optimization, making it
// numerically more robust and efficient.
//
// More generally we can define a function
//
//   x_plus_delta = Plus(x, delta),
//
// where x_plus_delta has the same size as x, and delta is of size
// less than or equal to x. The function Plus, generalizes the
// definition of vector addition. Thus it satisfies the identify
//
//   Plus(x, 0) = x, for all x.
//
// A trivial version of Plus is when delta is of the same size as x
// and
//
//   Plus(x, delta) = x + delta
//
// A more interesting case if x is two dimensional vector, and the
// user wishes to hold the first coordinate constant. Then, delta is a
// scalar and Plus is defined as
//
//   Plus(x, delta) = x + [0] * delta
//                        [1]
//
// An example that occurs commonly in Structure from Motion problems
// is when camera rotations are parameterized using Quaternion. There,
// it is useful only make updates orthogonal to that 4-vector defining
// the quaternion. One way to do this is to let delta be a 3
// dimensional vector and define Plus to be
//
//   Plus(x, delta) = [cos(|delta|), sin(|delta|) delta / |delta|] * x
//
// The multiplication between the two 4-vectors on the RHS is the
// standard quaternion product.
//
// Given g and a point x, optimizing f can now be restated as
//
//     min  f(Plus(x, delta))
//    delta
//
// Given a solution delta to this problem, the optimal value is then
// given by
//
//   x* = Plus(x, delta)
//
// The class LocalParameterization defines the function Plus and its
// Jacobian which is needed to compute the Jacobian of f w.r.t delta.</doc>
<fun r='_ZN5ceres21LocalParameterizationD1Ev'/>
<fun r='_ZNK5ceres21LocalParameterization4PlusEPKdS2_Pd'/>
<fun r='_ZNK5ceres21LocalParameterization15ComputeJacobianEPKdPd'/>
<fun r='_ZNK5ceres21LocalParameterization18MultiplyByJacobianEPKdiS2_Pd'/>
<fun r='_ZNK5ceres21LocalParameterization10GlobalSizeEv'/>
<fun r='_ZNK5ceres21LocalParameterization9LocalSizeEv'/>
<ovr f='ceres-solver/internal/ceres/covariance_test.cc' l='130' c='ceres::internal::PolynomialParameterization'/>
<ovr f='ceres-solver/internal/ceres/gradient_checker_test.cc' l='347' c='ceres::internal::MatrixParameterization'/>
<ovr f='ceres-solver/internal/ceres/parameter_block_test.cc' l='131' c='ceres::internal::TestParameterization'/>
<ovr f='ceres-solver/internal/ceres/parameter_block_test.cc' l='174' c='ceres::internal::BadLocalParameterization'/>
