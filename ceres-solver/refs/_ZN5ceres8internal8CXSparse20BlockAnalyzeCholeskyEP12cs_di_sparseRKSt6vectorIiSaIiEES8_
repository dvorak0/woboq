<dec f='ceres-solver/internal/ceres/cxsparse.h' l='109' type='cs_dis * ceres::internal::CXSparse::BlockAnalyzeCholesky(cs_di * A, const std::vector&lt;int&gt; &amp; row_blocks, const std::vector&lt;int&gt; &amp; col_blocks)'/>
<def f='ceres-solver/internal/ceres/cxsparse.cc' l='107' ll='166' type='cs_dis * ceres::internal::CXSparse::BlockAnalyzeCholesky(cs_di * A, const vector&lt;int&gt; &amp; row_blocks, const vector&lt;int&gt; &amp; col_blocks)'/>
<doc f='ceres-solver/internal/ceres/cxsparse.h' l='98'>// Computes a symbolic factorization of A that can be used in
  // SolveCholesky. The difference from AnalyzeCholesky is that this
  // function first detects the block sparsity of the matrix using
  // information about the row and column blocks and uses this block
  // sparse matrix to find a fill-reducing ordering. This ordering is
  // then used to find a symbolic factorization. This can result in a
  // significant performance improvement AnalyzeCholesky on block
  // sparse matrices.
  //
  // The returned matrix should be deallocated with Free when not used
  // anymore.</doc>
<use f='ceres-solver/internal/ceres/schur_complement_solver.cc' l='494' u='c' c='_ZN5ceres8internal27SparseSchurComplementSolver37SolveReducedLinearSystemUsingCXSparseERKNS0_12LinearSolver15PerSolveOptionsEPd'/>
<use f='ceres-solver/internal/ceres/sparse_normal_cholesky_solver.cc' l='318' u='c' c='_ZN5ceres8internal26SparseNormalCholeskySolver22SolveImplUsingCXSparseEPd'/>
