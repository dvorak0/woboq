<dec f='ceres-solver/internal/ceres/schur_eliminator.h' l='315' type='void ceres::internal::SchurEliminator::NoEBlockRowOuterProduct(const ceres::internal::BlockSparseMatrix * A, int row_block_index, ceres::internal::BlockRandomAccessMatrix * lhs)'/>
<use f='ceres-solver/internal/ceres/schur_eliminator_impl.h' l='574' u='c' c='_ZN5ceres8internal15SchurEliminator18NoEBlockRowsUpdateEPKNS0_17BlockSparseMatrixEPKdiPNS0_23BlockRandomAccessMatrixEPd'/>
<def f='ceres-solver/internal/ceres/schur_eliminator_impl.h' l='593' ll='641' type='void ceres::internal::SchurEliminator::NoEBlockRowOuterProduct(const ceres::internal::BlockSparseMatrix * A, int row_block_index, ceres::internal::BlockRandomAccessMatrix * lhs)'/>
<doc f='ceres-solver/internal/ceres/schur_eliminator_impl.h' l='579'>// A row r of A, which has no e_blocks gets added to the Schur
// Complement as S += r r&apos;. This function is responsible for computing
// the contribution of a single row r to the Schur complement. It is
// very similar in structure to EBlockRowOuterProduct except for
// one difference. It does not use any of the template
// parameters. This is because the algorithm used for detecting the
// static structure of the matrix A only pays attention to rows with
// e_blocks. This is becase rows without e_blocks are rare and
// typically arise from regularization terms in the original
// optimization problem, and have a very different structure than the
// rows with e_blocks. Including them in the static structure
// detection will lead to most template parameters being set to
// dynamic. Since the number of rows without e_blocks is small, the
// lack of templating is not an issue.</doc>
