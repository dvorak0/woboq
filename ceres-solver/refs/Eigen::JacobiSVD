<def f='include/eigen3/Eigen/src/SVD/JacobiSVD.h' l='492' ll='690'/>
<doc f='include/eigen3/Eigen/src/SVD/JacobiSVD.h' l='439'>/** \ingroup SVD_Module
  *
  *
  * \class JacobiSVD
  *
  * \brief Two-sided Jacobi SVD decomposition of a rectangular matrix
  *
  * \param MatrixType the type of the matrix of which we are computing the SVD decomposition
  * \param QRPreconditioner this optional parameter allows to specify the type of QR decomposition that will be used internally
  *                        for the R-SVD step for non-square matrices. See discussion of possible values below.
  *
  * SVD decomposition consists in decomposing any n-by-p matrix \a A as a product
  *   \f[ A = U S V^* \f]
  * where \a U is a n-by-n unitary, \a V is a p-by-p unitary, and \a S is a n-by-p real positive matrix which is zero outside of its main diagonal;
  * the diagonal entries of S are known as the \em singular \em values of \a A and the columns of \a U and \a V are known as the left
  * and right \em singular \em vectors of \a A respectively.
  *
  * Singular values are always sorted in decreasing order.
  *
  * This JacobiSVD decomposition computes only the singular values by default. If you want \a U or \a V, you need to ask for them explicitly.
  *
  * You can ask for only \em thin \a U or \a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \a m be the
  * smaller value among \a n and \a p, there are only \a m singular vectors; the remaining columns of \a U and \a V do not correspond to actual
  * singular vectors. Asking for \em thin \a U or \a V means asking for only their \a m first columns to be formed. So \a U is then a n-by-m matrix,
  * and \a V is then a p-by-m matrix. Notice that thin \a U and \a V are all you need for (least squares) solving.
  *
  * Here&apos;s an example demonstrating basic usage:
  * \include JacobiSVD_basic.cpp
  * Output: \verbinclude JacobiSVD_basic.out
  *
  * This JacobiSVD class is a two-sided Jacobi R-SVD decomposition, ensuring optimal reliability and accuracy. The downside is that it&apos;s slower than
  * bidiagonalizing SVD algorithms for large square matrices; however its complexity is still \f$ O(n^2p) \f$ where \a n is the smaller dimension and
  * \a p is the greater dimension, meaning that it is still of the same order of complexity as the faster bidiagonalizing R-SVD algorithms.
  * In particular, like any R-SVD, it takes advantage of non-squareness in that its complexity is only linear in the greater dimension.
  *
  * If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to
  * terminate in finite (and reasonable) time.
  *
  * The possible values for QRPreconditioner are:
  * \li ColPivHouseholderQRPreconditioner is the default. In practice it&apos;s very safe. It uses column-pivoting QR.
  * \li FullPivHouseholderQRPreconditioner, is the safest and slowest. It uses full-pivoting QR.
  *     Contrary to other QRs, it doesn&apos;t allow computing thin unitaries.
  * \li HouseholderQRPreconditioner is the fastest, and less safe and accurate than the pivoting variants. It uses non-pivoting QR.
  *     This is very similar in safety and accuracy to the bidiagonalization process used by bidiagonalizing SVD algorithms (since bidiagonalization
  *     is inherently non-pivoting). However the resulting SVD is still more reliable than bidiagonalizing SVDs because the Jacobi-based iterarive
  *     process is more reliable than the optimized bidiagonal SVD iterations.
  * \li NoQRPreconditioner allows not to use a QR preconditioner at all. This is useful if you know that you will only be computing
  *     JacobiSVD decompositions of square matrices. Non-square matrices require a QR preconditioner. Using this option will result in
  *     faster compilation and smaller executable code. It won&apos;t significantly speed up computation, since JacobiSVD is always checking
  *     if QR preconditioning is needed before applying it anyway.
  *
  * \sa MatrixBase::jacobiSvd()
  */</doc>
<fun r='_ZN5Eigen9JacobiSVDC1Ev'/>
<fun r='_ZN5Eigen9JacobiSVDC1ENT_5IndexES2_j'/>
<fun r='_ZN5Eigen9JacobiSVDC1ERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_'/>
<fun r='_ZNK5Eigen9JacobiSVD7matrixUEv'/>
<fun r='_ZNK5Eigen9JacobiSVD7matrixVEv'/>
<fun r='_ZNK5Eigen9JacobiSVD14singularValuesEv'/>
<fun r='_ZNK5Eigen9JacobiSVD8computeUEv'/>
<fun r='_ZNK5Eigen9JacobiSVD8computeVEv'/>
<fun r='_ZNK5Eigen9JacobiSVD5solveERKNS_10MatrixBaseIT_EE'/>
<fun r='_ZNK5Eigen9JacobiSVD21nonzeroSingularValuesEv'/>
<fun r='_ZNK5Eigen9JacobiSVD4rowsEv'/>
<fun r='_ZNK5Eigen9JacobiSVD4colsEv'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateENT_5IndexES2_j'/>
<mbr r='Eigen::JacobiSVD::m_matrixU' t='MatrixUType'/>
<mbr r='Eigen::JacobiSVD::m_matrixV' t='MatrixVType'/>
<mbr r='Eigen::JacobiSVD::m_singularValues' t='SingularValuesType'/>
<mbr r='Eigen::JacobiSVD::m_workMatrix' t='WorkMatrixType'/>
<mbr r='Eigen::JacobiSVD::m_isInitialized' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_isAllocated' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_computeFullU' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_computeThinU' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_computeFullV' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_computeThinV' t='bool'/>
<mbr r='Eigen::JacobiSVD::m_computationOptions' t='unsigned int'/>
<mbr r='Eigen::JacobiSVD::m_nonzeroSingularValues' t='Index'/>
<mbr r='Eigen::JacobiSVD::m_rows' t='Index'/>
<mbr r='Eigen::JacobiSVD::m_cols' t='Index'/>
<mbr r='Eigen::JacobiSVD::m_diagSize' t='Index'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morecols' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows&gt;'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morerows' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols&gt;'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateENT_5IndexES2_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
